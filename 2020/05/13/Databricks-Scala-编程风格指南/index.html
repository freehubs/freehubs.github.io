<!DOCTYPE html><html lang="zh-Hans"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/1281.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/323.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/161.png">
  <link rel="mask-icon" href="/images/atom.svg" color="#222">







<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://freehubs.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="声明 (Disclaimer)The Chinese version of the Databricks Scala Guide is contributed and maintained by community member Hawstein. We do not guarantee that it will always be kept up-to-date. 本文档翻译自 Databric">
<meta name="keywords" content="scala">
<meta property="og:type" content="article">
<meta property="og:title" content="Databricks-Scala 编程风格指南">
<meta property="og:url" content="https://freehubs.github.io/2020/05/13/Databricks-Scala-编程风格指南/index.html">
<meta property="og:site_name" content="Freehubs">
<meta property="og:description" content="声明 (Disclaimer)The Chinese version of the Databricks Scala Guide is contributed and maintained by community member Hawstein. We do not guarantee that it will always be kept up-to-date. 本文档翻译自 Databric">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-05-13T15:14:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Databricks-Scala 编程风格指南">
<meta name="twitter:description" content="声明 (Disclaimer)The Chinese version of the Databricks Scala Guide is contributed and maintained by community member Hawstein. We do not guarantee that it will always be kept up-to-date. 本文档翻译自 Databric">

<link rel="canonical" href="https://freehubs.github.io/2020/05/13/Databricks-Scala-编程风格指南/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Databricks-Scala 编程风格指南 | Freehubs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Freehubs" type="application/atom+xml">
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('//stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css');loadCss('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="//stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"></noscript></head>

<body itemscope="" itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Freehubs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-数工">

    <a href="/bigdata" rel="section">数工</a>

  </li>
        <li class="menu-item menu-item-面试">

    <a href="/tags/offer/" rel="section">面试</a>

  </li>
        <li class="menu-item menu-item-算法">

    <a href="/tags/algo/" rel="section">算法</a>

  </li>
        <li class="menu-item menu-item-gem">

    <a href="/gem/" rel="section">GEM</a>

  </li>
        <li class="menu-item menu-item-生活">

    <a href="/tags/life/" rel="section">生活</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section">归档</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section">标签</a>

  </li>
        <li class="menu-item menu-item-博客">

    <a href="/categories/blog/" rel="section">博客</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Searching..." spellcheck="false" type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://freehubs.github.io/2020/05/13/Databricks-Scala-编程风格指南/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freehuber">
      <meta itemprop="description" content="左手写诗，右手撸码">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freehubs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Databricks-Scala 编程风格指南<a href="https://github.com/freehubs/freehubs.github.io.source/tree/master/source/_posts/Databricks-Scala-编程风格指南.md" class="post-edit-link" title="Edit this post" rel="noopener" target="_blank"><i class="fa fa-pencil"></i></a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-13 15:14:08" itemprop="dateCreated datePublished" datetime="2020-05-13T15:14:08+00:00">2020-05-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index">
                    <span itemprop="name">scala</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="声明-Disclaimer"><a href="#声明-Disclaimer" class="headerlink" title="声明 (Disclaimer)"></a>声明 (Disclaimer)</h2><p>The Chinese version of the <a href="https://github.com/databricks/scala-style-guide" target="_blank" rel="noopener">Databricks Scala Guide</a> is contributed and maintained by community member <a href="https://github.com/Hawstein" target="_blank" rel="noopener">Hawstein</a>. We do not guarantee that it will always be kept up-to-date.</p>
<p>本文档翻译自 <a href="https://github.com/databricks/scala-style-guide" target="_blank" rel="noopener">Databricks Scala Guide</a>，目前由 <a href="https://github.com/Hawstein" target="_blank" rel="noopener">Hawstein</a> 进行维护。由于是利用业余时间进行翻译并维护，因此该中文文档并不保证总是与<a href="https://github.com/databricks/scala-style-guide" target="_blank" rel="noopener">原文档</a>一样处于最新版本，不过我会尽可能及时地去更新它。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spark 有超过 1000 位贡献者，就我们所知，应该是目前大数据领域里最大的开源项目且是最活跃的 Scala 项目。这份指南是在我们指导，或是与 Spark 贡献者及 <a href="http://databricks.com/" target="_blank" rel="noopener">Databricks</a> 工程团队一起工作时总结出来的。</p>
<p>代码由作者 <strong>一次编写</strong> ，然后由大量工程师 <strong>多次阅读并修改</strong> 。事实上，大部分的 bug 来源于后人对代码的修改，因此我们需要长期去优化我们的代码，提升代码的可读性和可维护性。达到这个目标最好的方式就是编写简单易懂的代码。</p>
<p>Scala 是一种强大到令人难以置信的多范式编程语言。我们总结出了以下指南，它可以很好地应用在一个高速发展的项目。当然，这个指南并非绝对，根据团队需求的不同，可以有不同的标准。</p>
<p>This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</p>
<a id="more"></a>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><a name="TOC">目录</a></h2><ol>
<li><p><a href="#history">文档历史</a></p>
</li>
<li><p><a href="#syntactic">语法风格</a></p>
<ul>
<li><a href="#naming">命名约定</a></li>
<li><a href="#variable-naming">变量命名约定</a></li>
<li><a href="#linelength">一行长度</a></li>
<li><a href="#rule_of_30">30 法则</a></li>
<li><a href="#indent">空格与缩进</a></li>
<li><a href="#blanklines">空行</a></li>
<li><a href="#parentheses">括号</a></li>
<li><a href="#curly">大括号</a></li>
<li><a href="#long_literal">长整型字面量</a></li>
<li><a href="#doc">文档风格</a></li>
<li><a href="#ordering_class">类内秩序</a></li>
<li><a href="#imports">Imports</a></li>
<li><a href="#pattern-matching">模式匹配</a></li>
<li><a href="#infix">中缀方法</a></li>
<li><a href="#anonymous">匿名方法</a></li>
</ul>
</li>
<li><p><a href="#lang">Scala 语言特性</a></p>
<ul>
<li><a href="#case_class_immutability">样例类与不可变性</a></li>
<li><a href="#apply_method">apply 方法</a></li>
<li><a href="#override_modifier">override 修饰符</a></li>
<li><a href="#destruct_bind">解构绑定</a></li>
<li><a href="#call_by_name">按名称传参</a></li>
<li><a href="#multi-param-list">多参数列表</a></li>
<li><a href="#symbolic_methods">符号方法 (运算符重载)</a></li>
<li><a href="#type_inference">类型推导</a></li>
<li><a href="#return">Return 语句</a></li>
<li><a href="#recursion">递归及尾递归</a></li>
<li><a href="#implicits">Implicits</a></li>
<li><a href="#exception">异常处理 (Try 还是 try)</a></li>
<li><a href="#option">Options</a></li>
<li><a href="#chaining">单子链接</a></li>
<li><a href="#symbol">符号文本</a></li>
</ul>
</li>
<li><p><a href="#concurrency">并发</a></p>
<ul>
<li><a href="#concurrency-scala-collection">Scala concurrent.Map</a></li>
<li><a href="#concurrency-sync-vs-map">显式同步 vs 并发集合</a></li>
<li><a href="#concurrency-sync-vs-atomic">显式同步 vs 原子变量 vs @volatile</a></li>
<li><a href="#concurrency-private-this">私有字段</a></li>
<li><a href="#concurrency-isolation">隔离</a></li>
</ul>
</li>
<li><p><a href="#perf">性能</a></p>
<ul>
<li><a href="#perf-microbenchmarks">Microbenchmarks</a></li>
<li><a href="#perf-whileloops">Traversal 与 zipWithIndex</a></li>
<li><a href="#perf-option">Option 与 null</a></li>
<li><a href="#perf-collection">Scala 集合库</a></li>
<li><a href="#perf-private">private[this]</a></li>
</ul>
</li>
<li><p><a href="#java">与 Java 的互操作性</a></p>
<ul>
<li><a href="#java-missing-features">Scala 中缺失的 Java 特性</a></li>
<li><a href="#java-traits">Traits 与抽象类</a></li>
<li><a href="#java-type-alias">类型别名</a></li>
<li><a href="#java-default-param-values">默认参数值</a></li>
<li><a href="#java-multi-param-list">多参数列表</a></li>
<li><a href="#java-varargs">可变参数</a></li>
<li><a href="#java-implicits">Implicits</a></li>
<li><a href="#java-companion-object">伴生对象, 静态方法与字段</a></li>
</ul>
</li>
<li><p><a href="#testing">测试</a></p>
<ul>
<li><a href="#testing-intercepting">异常拦截</a></li>
</ul>
</li>
<li><p><a href="#misc">其它</a></p>
<ul>
<li><a href="#misc_currentTimeMillis_vs_nanoTime">优先使用 nanoTime 而非 currentTimeMillis</a></li>
<li><a href="#misc_uri_url">优先使用 URI 而非 URL</a></li>
<li><a href="#misc_well_tested_method">优先使用现存的经过良好测试的方法而非重新发明轮子</a></li>
</ul>
</li>
</ol>
<h2 id="文档历史"><a href="#文档历史" class="headerlink" title="文档历史"></a><a name="history">文档历史</a></h2><ul>
<li>2015-03-16: 最初版本。</li>
<li>2015-05-25: 增加 <a href="#override_modifier">override 修饰符</a> 一节。</li>
<li>2015-08-23: 把一些规则的严重程度从「不要」降级到「避免」。</li>
<li>2015-11-17: 更新 <a href="#apply_method">apply 方法</a> 一节：伴生对象中的 apply 方法应该返回其伴生类。</li>
<li>2015-11-17: 该指南被翻译成<a href="README-ZH.md">中文</a>，由 <a href="https://github.com/Hawstein" target="_blank" rel="noopener">Hawstein</a> 进行维护，中文文档并不保证总是与原文档一样处于最新版本。</li>
<li>2015-12-14: 该指南被翻译成<a href="README-KO.md">韩文</a>, 韩文版本由 <a href="https://github.com/HyukjinKwon" target="_blank" rel="noopener">Hyukjin Kwon</a> 进行翻译并且由 <a href="https://github.com/yunpark93" target="_blank" rel="noopener">Yun Park</a>, <a href="https://github.com/swkimme" target="_blank" rel="noopener">Kevin (Sangwoo) Kim</a>, <a href="https://github.com/RetrieverJo" target="_blank" rel="noopener">Hyunje Jo</a> 和 <a href="https://github.com/socialpercon" target="_blank" rel="noopener">Woochel Choi</a> 进行校对。韩文版本并不保证总是与原文档一样处于最新版本。</li>
<li>2016-06-15: 增加 <a href="#anonymous">匿名方法</a> 一节。</li>
<li>2016-06-21: 增加 <a href="#variable-naming">变量命名约定</a> 一节。</li>
<li>2016-12-24: 增加 <a href="#case_class_immutability">样例类与不可变性</a> 一节。</li>
<li>2017-02-23: 增加 <a href="#testing">测试</a> 一节。</li>
<li>2017-04-18: 增加 <a href="#misc_well_tested_method">优先使用现存的经过良好测试的方法而非重新发明轮子</a> 一节。</li>
<li>2019-12-18: 增加 <a href="#symbol">符号文本</a> 一节。</li>
</ul>
<h2 id="语法风格"><a href="#语法风格" class="headerlink" title="语法风格"></a><a name="syntactic">语法风格</a></h2><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a><a name="naming">命名约定</a></h3><p>我们主要遵循 Java 和 Scala 的标准命名约定。</p>
<ul>
<li><p>类，trait, 对象应该遵循 Java 中类的命名约定，即 PascalCase 风格。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClusterManager</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">trait</span> <span class="title">Expression</span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>包名应该遵循 Java 中包名的命名约定，即使用全小写的 ASCII 字母。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.databricks.resourcemanager</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>方法/函数应当使用驼峰式风格命名。</p>
</li>
<li><p>常量命名使用全大写字母，并将它们放在伴生对象中。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Configuration</span> </span>{</span><br><span class="line">  <span class="keyword">val</span> <span class="type">DEFAULT_PORT</span> = <span class="number">10000</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>从 <code>Enumeration</code> 类继承的枚举类或对象应遵循类或对象的相关约定，比如：命名应使用 PascalCase 风格。枚举值的命名则应采用大写字母的形式，并在单词之间使用下划线 <code>_</code> 进行分隔。例如： </p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">object</span> <span class="title">ParseState</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>{</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">ParseState</span> </span>= <span class="type">Value</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">PREFIX</span>,</span><br><span class="line">      <span class="type">TRIM_BEFORE_SIGN</span>,</span><br><span class="line">      <span class="type">SIGN</span>,</span><br><span class="line">      <span class="type">TRIM_BEFORE_VALUE</span>,</span><br><span class="line">      <span class="type">VALUE</span>,</span><br><span class="line">      <span class="type">VALUE_FRACTIONAL_PART</span>,</span><br><span class="line">      <span class="type">TRIM_BEFORE_UNIT</span>,</span><br><span class="line">      <span class="type">UNIT_BEGIN</span>,</span><br><span class="line">      <span class="type">UNIT_SUFFIX</span>,</span><br><span class="line">      <span class="type">UNIT_END</span> = <span class="type">Value</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>注解也应遵循 Java 中的约定，即使用 PascalCase 风格。注意，这一点与 Scala 的官方指南不同。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotation</span> <span class="keyword">extends</span> <span class="title">StaticAnnotation</span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="变量命名约定"><a href="#变量命名约定" class="headerlink" title="变量命名约定"></a><a name="variable-naming">变量命名约定</a></h3><ul>
<li><p>变量命名应当遵循驼峰式命名方法，并且变量名应当是不言而喻的，即变量名可以直观地反应它的涵义。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> serverPort = <span class="number">1000</span></span><br><span class="line"><span class="keyword">val</span> clientPort = <span class="number">2000</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>可以在小段的局部代码中使用单字符的变量名，比如在小段的循环体中（例如 10 行以内的代码），“i” 常常被用作循环索引。然而，即使在小段的代码中，也不要使用 “l” （Larry 中的 l）作为标识符，因为它看起来和 “1”，“|”，“I” 很像，难以区分，容易搞错。</p>
</li>
</ul>
<h3 id="一行长度"><a href="#一行长度" class="headerlink" title="一行长度"></a><a name="linelength">一行长度</a></h3><ul>
<li>一行长度的上限是 100 个字符。</li>
<li>唯一的例外是 import 语句和 URL (即便如此，也尽量将它们保持在 100 个字符以下)。</li>
</ul>
<h3 id="30-法则"><a href="#30-法则" class="headerlink" title="30 法则"></a><a name="rule_of_30">30 法则</a></h3><p>「如果一个元素包含的子元素超过 30 个，那么极有可能出现了严重的问题」 - <a href="http://www.amazon.com/Refactoring-Large-Software-Projects-Restructurings/dp/0470858923" target="_blank" rel="noopener">Refactoring in Large Software Projects</a>。</p>
<p>一般来说:</p>
<ul>
<li>一个方法包含的代码行数不宜超过 30 行。</li>
<li>一个类包含的方法数量不宜超过 30 个。</li>
</ul>
<h3 id="空格与缩进"><a href="#空格与缩进" class="headerlink" title="空格与缩进"></a><a name="indent">空格与缩进</a></h3><ul>
<li><p>运算符前后保留一个空格，包括赋值运算符。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(int1: <span class="type">Int</span>, int2: <span class="type">Int</span>): <span class="type">Int</span> = int1 + int2</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>逗号后保留一个空格。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Seq</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>) <span class="comment">// 使用这种方式</span></span><br><span class="line"></span><br><span class="line"><span class="type">Seq</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>) <span class="comment">// 不要忽略逗号后的空格</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>冒号后保留一个空格。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用这种方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getConf</span></span>(key: <span class="type">String</span>, defaultValue: <span class="type">String</span>): <span class="type">String</span> = {</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒号前不需要使用空格</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateHeaderPortionInBytes</span></span>(count: <span class="type">Int</span>) : <span class="type">Int</span> = {</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要忽略冒号后的空格</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(int1:<span class="type">Int</span>, int2:<span class="type">Int</span>): <span class="type">Int</span> = int1 * int2</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>一般情况下，使用两个空格的缩进。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) {</span><br><span class="line">  println(<span class="string">"Wow!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>对于方法声明，如果两行无法容纳下所有的参数，那么将每个参数单独放在一行，并使用 4 个空格进行缩进。返回类型可以与最后一个参数在同一行，也可以放在新的一行，使用两个空格缩进。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newAPIHadoopFile</span></span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">F</span> &lt;: <span class="type">NewInputFormat</span>[<span class="type">K</span>, <span class="type">V</span>]](</span><br><span class="line">    path: <span class="type">String</span>,</span><br><span class="line">    fClass: <span class="type">Class</span>[<span class="type">F</span>],</span><br><span class="line">    kClass: <span class="type">Class</span>[<span class="type">K</span>],</span><br><span class="line">    vClass: <span class="type">Class</span>[<span class="type">V</span>],</span><br><span class="line">    conf: <span class="type">Configuration</span> = hadoopConfiguration): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)] = {</span><br><span class="line">  <span class="comment">// 方法体</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newAPIHadoopFile</span></span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">F</span> &lt;: <span class="type">NewInputFormat</span>[<span class="type">K</span>, <span class="type">V</span>]](</span><br><span class="line">    path: <span class="type">String</span>,</span><br><span class="line">    fClass: <span class="type">Class</span>[<span class="type">F</span>],</span><br><span class="line">    kClass: <span class="type">Class</span>[<span class="type">K</span>],</span><br><span class="line">    vClass: <span class="type">Class</span>[<span class="type">V</span>],</span><br><span class="line">    conf: <span class="type">Configuration</span> = hadoopConfiguration)</span><br><span class="line">  : <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)] = {</span><br><span class="line">  <span class="comment">// 方法体</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>如果两行无法容纳下类头（即 { 前面的部分），那么将每个类参数单独放在一行，并使用 4 个空格进行缩进；将 extends 关键字放在（最后一个参数的）下一行，并使用 2 个空格进行缩进。在类头定义结束后空一行，再开始类内函数或变量的定义。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    val param1: <span class="type">String</span>,  // 对参数使用 4 个空格进行缩进</span></span></span><br><span class="line"><span class="class"><span class="params">    val param2: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val param3: <span class="type">Array</span>[<span class="type">Byte</span>]</span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">FooInterface</span>  <span class="title">//</span> <span class="title">这里使用</span> 2 <span class="title">个空格进行缩进</span></span></span><br><span class="line"><span class="class">  <span class="keyword">with</span> <span class="title">Logging</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">firstMethod</span></span>(): <span class="type">Unit</span> = { ... }  <span class="comment">// 上面空一行</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>对于方法和类的构造函数调用，如果两行无法容纳下所有的参数，那么将每个参数单独放在一行，并使用 2 个空格进行缩进。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(</span><br><span class="line">  someVeryLongFieldName,  <span class="comment">// 这里使用 2 个空格进行缩进</span></span><br><span class="line">  andAnotherVeryLongFieldName,</span><br><span class="line">  <span class="string">"this is a string"</span>,</span><br><span class="line">  <span class="number">3.1415</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">Bar</span>(</span><br><span class="line">  someVeryLongFieldName,  <span class="comment">// 这里使用 2 个空格进行缩进</span></span><br><span class="line">  andAnotherVeryLongFieldName,</span><br><span class="line">  <span class="string">"this is a string"</span>,</span><br><span class="line">  <span class="number">3.1415</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>不要使用垂直对齐。它使你的注意力放在代码的错误部分并增大了后人修改代码的难度。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要（对等于号）使用垂直对齐</span></span><br><span class="line"><span class="keyword">val</span> plus     = <span class="string">"+"</span></span><br><span class="line"><span class="keyword">val</span> minus    = <span class="string">"-"</span></span><br><span class="line"><span class="keyword">val</span> multiply = <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用下面的写法</span></span><br><span class="line"><span class="keyword">val</span> plus = <span class="string">"+"</span></span><br><span class="line"><span class="keyword">val</span> minus = <span class="string">"-"</span></span><br><span class="line"><span class="keyword">val</span> multiply = <span class="string">"*"</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a><a name="blanklines">空行</a></h3><ul>
<li>一个空行可以出现在：<ul>
<li>连续的类成员或初始化器（initializers）之间：字段，构造函数，方法，嵌套类，静态初始化器及实例初始化器。<ul>
<li>例外：连续的两个字段之间的空行是可选的（前提是它们之间没有其它代码），这一类空行主要为这些字段做逻辑上的分组。</li>
</ul>
</li>
<li>在方法体内，根据需要，使用空行来为语句创建逻辑上的分组。</li>
<li>在类的第一个成员之前或最后一个成员之后，空行都是可选的（既不鼓励也不阻止）。</li>
</ul>
</li>
<li>使用一个或两个空行来分隔不同类或对象的定义。</li>
<li>不鼓励使用过多的空行。</li>
</ul>
<h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a><a name="parentheses">括号</a></h3><ul>
<li><p>方法声明应该加括号（即使没有参数列表），除非它们是没有副作用（状态改变，IO 操作都认为是有副作用的）的访问器（accessor）。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>{</span><br><span class="line">  <span class="comment">// 错误：killJob 会改变状态，应该加上括号。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">killJob</span></span>: <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确：</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">killJob</span></span>(): <span class="type">Unit</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>函数调用应该与函数声明在形式上保持一致，也就是说，如果一个方法声明时带了括号，那调用时也要把括号带上。注意这不仅仅是语法层面的人为约定，当返回对象中定义了 <code>apply</code> 方法时，这一点还会影响正确性。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(args: <span class="type">String</span>*): <span class="type">Int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>: <span class="type">Foo</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">Bar</span>().foo  <span class="comment">// 这里返回一个 Foo 对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">Bar</span>().foo()  <span class="comment">// 这里返回一个 Int 值！</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a><a name="curly">大括号</a></h3><p>即使条件语句或循环语句只有一行时，也请使用大括号。唯一的例外是，当你把 if/else 作为一个单行的三元操作符来使用并且没有副作用时，这时你可以不加大括号。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) {</span><br><span class="line">  println(<span class="string">"Wow!"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) statement1 <span class="keyword">else</span> statement2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  foo()</span><br><span class="line">} <span class="keyword">catch</span> {</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  println(<span class="string">"Wow!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：</span></span><br><span class="line"><span class="keyword">try</span> foo() <span class="keyword">catch</span> {</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="长整型字面量"><a href="#长整型字面量" class="headerlink" title="长整型字面量"></a><a name="long_literal">长整型字面量</a></h3><p>长整型字面量使用大写的 <code>L</code> 作为后缀，不要使用小写，因为它和数字 <code>1</code> 长得很像，常常难以区分。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> longValue = <span class="number">5432</span>L  <span class="comment">// 这样写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> longValue = <span class="number">5432</span>l  <span class="comment">// 不要这样写</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="文档风格"><a href="#文档风格" class="headerlink" title="文档风格"></a><a name="doc">文档风格</a></h3><p>使用 Java Doc 风格，而非 Scala Doc 风格。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This is a correct one-liner, short description. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is correct multi-line JavaDoc comment. And</span></span><br><span class="line"><span class="comment"> * this is my second line, and if I keep typing, this would be</span></span><br><span class="line"><span class="comment"> * my third line.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** In Spark, we don't use the ScalaDoc style so this</span></span><br><span class="line"><span class="comment">  * is not correct.</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="类内秩序"><a href="#类内秩序" class="headerlink" title="类内秩序"></a><a name="ordering_class">类内秩序</a></h3><p>如果一个类很长，包含许多的方法，那么在逻辑上把它们分成不同的部分并加上注释头，以此组织它们。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataFrame</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">///////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">  <span class="comment">// DataFrame operations</span></span><br><span class="line">  <span class="comment">///////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">///////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">  <span class="comment">// RDD operations</span></span><br><span class="line">  <span class="comment">///////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当然，强烈不建议把一个类写得这么长，一般只有在构建某些公共 API 时才允许这么做。</p>
<h3 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a><a name="imports">Imports</a></h3><ul>
<li><strong>导入时避免使用通配符</strong>, 除非你需要导入超过 6 个实体或者隐式方法。通配符导入会使代码在面对外部变化时不够健壮。</li>
<li>始终使用绝对路径来导入包 (如：<code>scala.util.Random</code>) ，而不是相对路径 (如：<code>util.Random</code>)。</li>
<li>此外，导入语句按照以下顺序排序：<ul>
<li><code>java.*</code> 和 <code>javax.*</code></li>
<li><code>scala.*</code></li>
<li>第三方库 (<code>org.*</code>, <code>com.*</code>, 等)</li>
<li>项目中的类 (对于 Spark 项目，即 <code>com.databricks.*</code> 或 <code>org.apache.spark</code>)</li>
</ul>
</li>
<li>在每一组导入语句内，按照字母序进行排序。</li>
<li><p>你可以使用 IntelliJ 的「import organizer」来自动处理，请使用以下配置：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">javax</span><br><span class="line">_______ blank line _______</span><br><span class="line">scala</span><br><span class="line">_______ blank line _______</span><br><span class="line">all other imports</span><br><span class="line">_______ blank line _______</span><br><span class="line">com.databricks  // or org.apache.spark if you are working on spark</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a><a name="pattern-matching">模式匹配</a></h3><ul>
<li><p>如果整个方法就是一个模式匹配表达式，可能的话，可以把 match 关键词与方法声明放在同一行，以此减少一级缩进。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(msg: <span class="type">Message</span>): <span class="type">Unit</span> = msg <span class="keyword">match</span> {</span><br><span class="line">  <span class="keyword">case</span> ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>当以闭包形式调用一个函数时，如果只有一个 case 语句，那么把 case 语句与函数调用放在同一行。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.zipWithIndex.map { <span class="keyword">case</span> (elem, i) =&gt;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果有多个 case 语句，把它们缩进并且包起来。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.map {</span><br><span class="line">  <span class="keyword">case</span> a: <span class="type">Foo</span> =&gt;  ...</span><br><span class="line">  <span class="keyword">case</span> b: <span class="type">Bar</span> =&gt;  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>如果唯一的目的就是想匹配某个对象的类型，那么不要展开所有的参数来做模式匹配，这样会使得重构变得更加困难，代码更容易出错。</p>
</li>
</ul>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Pokemon</span>(<span class="params">name: <span class="type">String</span>, weight: <span class="type">Int</span>, hp: <span class="type">Int</span>, attack: <span class="type">Int</span>, defense: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Human</span>(<span class="params">name: <span class="type">String</span>, hp: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">不要像下面那样做，因为</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> 1. <span class="title">当</span> <span class="title">pokemon</span> <span class="title">加入一个新的字段，我们需要改变下面的模式匹配代码</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> 2. <span class="title">非常容易发生误匹配，尤其是当所有字段的类型都一样的时候</span></span></span><br><span class="line"><span class="class"><span class="title">targets</span>.<span class="title">foreach</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> target @ <span class="type">Pokemon</span>(_, _, hp, _, defense) =&gt;</span><br><span class="line">    <span class="keyword">val</span> loss = sys.min(<span class="number">0</span>, myAttack - defense)</span><br><span class="line">    target.copy(hp = hp - loss)</span><br><span class="line">  <span class="keyword">case</span> target @ <span class="type">Human</span>(_, hp) =&gt;</span><br><span class="line">    target.copy(hp = hp - myAttack)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像下面这样做就好多了:</span></span><br><span class="line">targets.foreach {</span><br><span class="line">  <span class="keyword">case</span> target: <span class="type">Pokemon</span> =&gt;</span><br><span class="line">    <span class="keyword">val</span> loss = sys.min(<span class="number">0</span>, myAttack - target.defense)</span><br><span class="line">    target.copy(hp = target.hp - loss)</span><br><span class="line">  <span class="keyword">case</span> target: <span class="type">Human</span> =&gt;</span><br><span class="line">    target.copy(hp = target.hp - myAttack)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="中缀方法"><a href="#中缀方法" class="headerlink" title="中缀方法"></a><a name="infix">中缀方法</a></h3><p><strong>避免中缀表示法</strong>，除非是符号方法（即运算符重载）。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line">list.map(func)</span><br><span class="line">string.contains(<span class="string">"foo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">list map (func)</span><br><span class="line">string contains <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载的运算符应该以中缀形式调用</span></span><br><span class="line">arrayBuffer += elem</span><br></pre></td></tr></tbody></table></figure>
<h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a><a name="anonymous">匿名方法</a></h3><p>对于匿名方法，<strong>避免使用过多的小括号和花括号</strong>。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line">list.map { item =&gt;</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">list.map(item =&gt; ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">list.map(item =&gt; {</span><br><span class="line">  ...</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">list.map { item =&gt; {</span><br><span class="line">  ...</span><br><span class="line">}}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">list.map({ item =&gt; ... })</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Scala-语言特性"><a href="#Scala-语言特性" class="headerlink" title="Scala 语言特性"></a><a name="lang">Scala 语言特性</a></h2><h3 id="样例类与不可变性"><a href="#样例类与不可变性" class="headerlink" title="样例类与不可变性"></a><a name="case_class_immutability">样例类与不可变性</a></h3><p>样例类（case class）本质也是普通的类，编译器会自动地为它加上以下支持：</p>
<ul>
<li>构造器参数的公有 getter 方法</li>
<li>拷贝构造函数</li>
<li>构造器参数的模式匹配</li>
<li>默认的 toString/hash/equals 实现</li>
</ul>
<p>对于样例类来说，构造器参数不应设为可变的，可以使用拷贝构造函数达到同样的效果。使用可变的样例类容易出错，例如，哈希表中，对象根据旧的哈希值被放在错误的位置上。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是 OK 的</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">这是不</span> <span class="title">OK</span> <span class="title">的</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, var age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">通过拷贝构造函数创建一个新的实例来改变其中的值</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">p1</span> </span>= <span class="type">Person</span>(<span class="string">"Peter"</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">val</span> p2 = p1.copy(age = <span class="number">16</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a><a name="apply_method">apply 方法</a></h3><p>避免在类里定义 apply 方法。这些方法往往会使代码的可读性变差，尤其是对于不熟悉 Scala 的人。它也难以被 IDE（或 grep）所跟踪。在最坏的情况下，它还可能影响代码的正确性，正如你在<a href="#parentheses">括号</a>一节中看到的。</p>
<p>然而，将 apply 方法作为工厂方法定义在伴生对象中是可以接受的。在这种情况下，apply 方法应该返回其伴生类的类型。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TreeNode</span> </span>{</span><br><span class="line">  <span class="comment">// 下面这种定义是 OK 的</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>): <span class="type">TreeNode</span> = ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不要像下面那样定义，因为它没有返回其伴生类的类型：TreeNode</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>): <span class="type">String</span> = ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="override-修饰符"><a href="#override-修饰符" class="headerlink" title="override 修饰符"></a><a name="override_modifier">override 修饰符</a></h3><p>无论是覆盖具体的方法还是实现抽象的方法，始终都为方法加上 override 修饰符。实现抽象方法时，不加 override 修饰符，Scala 编译器也不会报错。即便如此，我们也应该始终把 override 修饰符加上，以此显式地表示覆盖行为。以此避免由于方法签名不同（而你也难以发现）而导致没有覆盖到本应覆盖的方法。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Parent</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(data: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]): <span class="type">Unit</span> = {</span><br><span class="line">    print(data)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>{</span><br><span class="line">  <span class="keyword">import</span> scala.collection.<span class="type">Map</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面的方法没有覆盖 Parent.hello,</span></span><br><span class="line">  <span class="comment">// 因为两个 Map 的类型是不同的。</span></span><br><span class="line">  <span class="comment">// 如果我们加上 override 修饰符，编译器就会帮你找出问题并报错。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(data: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]): <span class="type">Unit</span> = {</span><br><span class="line">    print(<span class="string">"This is supposed to override the parent method, but it is actually not!"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="解构绑定"><a href="#解构绑定" class="headerlink" title="解构绑定"></a><a name="destruct_bind">解构绑定</a></h3><p>解构绑定（有时也叫元组提取）是一种在一个表达式中为两个变量赋值的便捷方式。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (a, b) = (<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>然而，请不要在构造函数中使用它们，尤其是当 <code>a</code> 和 <code>b</code> 需要被标记为 <code>transient</code> 的时候。Scala 编译器会产生一个额外的 Tuple2 字段，而它并不是暂态的（transient）。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>{</span><br><span class="line">  <span class="comment">// 以下代码无法 work，因为编译器会产生一个非暂态的 Tuple2 指向 a 和 b</span></span><br><span class="line">  <span class="meta">@transient</span> <span class="keyword">private</span> <span class="keyword">val</span> (a, b) = someFuncThatReturnsTuple2()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="按名称传参"><a href="#按名称传参" class="headerlink" title="按名称传参"></a><a name="call_by_name">按名称传参</a></h3><p><strong>避免使用按名传参</strong>. 显式地使用 <code>() =&gt; T</code> 。</p>
<p>背景：Scala 允许按名称来定义方法参数，例如：以下例子是可以成功执行的：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span></span>(value: =&gt; <span class="type">Int</span>): <span class="type">Unit</span> = {</span><br><span class="line">  println(value)</span><br><span class="line">  println(value + <span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inc</span></span>(): <span class="type">Int</span> = {</span><br><span class="line">  a += <span class="number">1</span></span><br><span class="line">  a</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">print(inc())</span><br></pre></td></tr></tbody></table></figure>
<p>在上面的代码中，<code>inc()</code> 以闭包的形式传递给 <code>print</code> 函数，并且在 <code>print</code> 函数中被执行了两次，而不是以数值 <code>1</code> 传入。按名传参的一个主要问题是在方法调用处，我们无法区分是按名传参还是按值传参。因此无法确切地知道这个表达式是否会被执行（更糟糕的是它可能会被执行多次）。对于带有副作用的表达式来说，这一点是非常危险的。</p>
<h3 id="多参数列表"><a href="#多参数列表" class="headerlink" title="多参数列表"></a><a name="multi-param-list">多参数列表</a></h3><p><strong>避免使用多参数列表</strong>。它们使运算符重载变得复杂，并且会使不熟悉 Scala 的程序员感到困惑。例如：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免出现下面的写法！</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)(<span class="params">secret: <span class="type">String</span></span>)</span></span><br></pre></td></tr></tbody></table></figure>
<p>一个值得注意的例外是，当在定义底层库时，可以使用第二个参数列表来存放隐式（implicit）参数。尽管如此，<a href="#implicits">我们应该避免使用 implicits</a>！</p>
<h3 id="符号方法（运算符重载）"><a href="#符号方法（运算符重载）" class="headerlink" title="符号方法（运算符重载）"></a><a name="symbolic_methods">符号方法（运算符重载）</a></h3><p><strong>不要使用符号作为方法名</strong>，除非你是在定义算术运算的方法（如：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>），否则在任何其它情况下，都不要使用。符号化的方法名让人难以理解方法的意图是什么，来看下面两个例子：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 符号化的方法名难以理解</span></span><br><span class="line">channel ! msg</span><br><span class="line">stream1 &gt;&gt;= stream2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的方法意图则不言而喻</span></span><br><span class="line">channel.send(msg)</span><br><span class="line">stream1.join(stream2)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a><a name="type_inference">类型推导</a></h3><p>Scala 的类型推导，尤其是左侧类型推导以及闭包推导，可以使代码变得更加简洁。尽管如此，也有一些情况我们是需要显式地声明类型的：</p>
<ul>
<li><strong>公有方法应该显式地声明类型</strong>，编译器推导出来的类型往往会使你大吃一惊。</li>
<li><strong>隐式方法应该显式地声明类型</strong>，否则在增量编译时，它会使 Scala 编译器崩溃。</li>
<li><strong>如果变量或闭包的类型并非显而易见，请显式声明类型</strong>。一个不错的判断准则是，如果评审代码的人无法在 3 秒内确定相应实体的类型，那么你就应该显式地声明类型。</li>
</ul>
<h3 id="Return-语句"><a href="#Return-语句" class="headerlink" title="Return 语句"></a><a name="return">Return 语句</a></h3><p><strong>闭包中避免使用 return</strong>。<code>return</code> 会被编译器转成 <code>scala.runtime.NonLocalReturnControl</code> 异常的 <code>try/catch</code> 语句，这可能会导致意外行为。请看下面的例子：</p>
  <figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>(rpc: <span class="type">WebSocketRPC</span>): <span class="type">Option</span>[<span class="type">Response</span>] = {</span><br><span class="line">  tableFut.onComplete { table =&gt;</span><br><span class="line">    <span class="keyword">if</span> (table.isFailure) {</span><br><span class="line">      <span class="keyword">return</span> <span class="type">None</span> <span class="comment">// 不要这样做！</span></span><br><span class="line">    } <span class="keyword">else</span> { ... }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>.onComplete</code> 方法接收一个匿名闭包并把它传递到一个不同的线程中。这个闭包最终会抛出一个 <code>NonLocalReturnControl</code> 异常，并在 <strong>一个不同的线程中</strong>被捕获，而这里执行的方法却没有任何影响。</p>
<p>然而，也有少数情况我们是推荐使用 <code>return</code> 的。</p>
<ul>
<li><p>使用 <code>return</code> 来简化控制流，避免增加一级缩进。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doSomething</span></span>(obj: <span class="type">Any</span>): <span class="type">Any</span> = {</span><br><span class="line">  <span class="keyword">if</span> (obj eq <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用 <code>return</code> 来提前终止循环，这样就不用额外构造状态标志。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">  <span class="keyword">if</span> (cond) {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="递归及尾递归"><a href="#递归及尾递归" class="headerlink" title="递归及尾递归"></a><a name="recursion">递归及尾递归</a></h3><p><strong>避免使用递归</strong>，除非问题可以非常自然地用递归来描述（比如，图和树的遍历）。</p>
<p>对于那些你意欲使之成为尾递归的方法，请加上 <code>@tailrec</code> 注解以确保编译器去检查它是否真的是尾递归（你会非常惊讶地看到，由于使用了闭包和函数变换，许多看似尾递归的代码事实并非尾递归）。</p>
<p>大多数的代码使用简单的循环和状态机会更容易推理，使用尾递归反而可能会使它更加繁琐且难以理解。例如，下面的例子中，命令式的代码比尾递归版本的代码要更加易读：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tail recursive version.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(data: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = {</span><br><span class="line">  <span class="meta">@tailrec</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">max0</span></span>(data: <span class="type">Array</span>[<span class="type">Int</span>], pos: <span class="type">Int</span>, max: <span class="type">Int</span>): <span class="type">Int</span> = {</span><br><span class="line">    <span class="keyword">if</span> (pos == data.length) {</span><br><span class="line">      max</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      max0(data, pos + <span class="number">1</span>, <span class="keyword">if</span> (data(pos) &gt; max) data(pos) <span class="keyword">else</span> max)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  max0(data, <span class="number">0</span>, <span class="type">Int</span>.<span class="type">MinValue</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Explicit loop version</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(data: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = {</span><br><span class="line">  <span class="keyword">var</span> max = <span class="type">Int</span>.<span class="type">MinValue</span></span><br><span class="line">  <span class="keyword">for</span> (v &lt;- data) {</span><br><span class="line">    <span class="keyword">if</span> (v &gt; max) {</span><br><span class="line">      max = v</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  max</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Implicits"><a href="#Implicits" class="headerlink" title="Implicits"></a><a name="implicits">Implicits</a></h3><p><strong>避免使用 implicit</strong>，除非：</p>
<ul>
<li>你在构建领域特定的语言（DSL）</li>
<li>你在隐式类型参数中使用它（如：<code>ClassTag</code>，<code>TypeTag</code>）</li>
<li>你在你自己的类中使用它（意指不要污染外部空间），以此减少类型转换的冗余度（如：Scala 闭包到 Java 闭包的转换）。</li>
</ul>
<p>当使用 implicit 时，我们应该确保另一个工程师可以直接理解使用语义，而无需去阅读隐式定义本身。Implicit 有着非常复杂的解析规则，这会使代码变得极其难以理解。Twitter 的 Effective Scala 指南中写道：「如果你发现你在使用 implicit，始终停下来问一下你自己，是否可以在不使用 implicit 的条件下达到相同的效果」。</p>
<p>如果你必需使用它们（比如：丰富 DSL），那么不要重载隐式方法，即确保每个隐式方法有着不同的名字，这样使用者就可以选择性地导入它们。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 别这么做，这样使用者无法选择性地只导入其中一个方法。</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitHolder</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toRdd</span></span>(seq: <span class="type">Seq</span>[<span class="type">Int</span>]): <span class="type">RDD</span>[<span class="type">Int</span>] = ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toRdd</span></span>(seq: <span class="type">Seq</span>[<span class="type">Long</span>]): <span class="type">RDD</span>[<span class="type">Long</span>] = ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应该将它们定义为不同的名字：</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitHolder</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">intSeqToRdd</span></span>(seq: <span class="type">Seq</span>[<span class="type">Int</span>]): <span class="type">RDD</span>[<span class="type">Int</span>] = ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">longSeqToRdd</span></span>(seq: <span class="type">Seq</span>[<span class="type">Long</span>]): <span class="type">RDD</span>[<span class="type">Long</span>] = ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="符号文本"><a href="#符号文本" class="headerlink" title="符号文本"></a><a name="symbol">符号文本</a></h3><p><strong>避免使用符号文本</strong>。在 Scala 2.13 中，符号文本（如：<code>'column</code>）已根据 <a href="https://contributors.scala-lang.org/t/proposal-to-deprecate-and-remove-symbol-literals/2953" target="_blank" rel="noopener">关于弃用和删除符号文字的建议</a> 弃用. Apache Spark 曾经利用符号文本来实现其 DSL，但是目前它已经开始移除这项弃用的特性。参见：<a href="https://issues.apache.org/jira/browse/SPARK-29392" target="_blank" rel="noopener">SPARK-29392</a>。</p>
<h2 id="异常处理-Try-还是-try"><a href="#异常处理-Try-还是-try" class="headerlink" title="异常处理 (Try 还是 try)"></a><a name="exception">异常处理 (Try 还是 try)</a></h2><ul>
<li><p>不要捕获 Throwable 或 Exception 类型的异常。请使用 <code>scala.util.control.NonFatal</code>：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  ...</span><br><span class="line">} <span class="keyword">catch</span> {</span><br><span class="line">  <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">    <span class="comment">// 异常处理；注意 NonFatal 无法匹配 InterruptedException 类型的异常</span></span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">InterruptedException</span> =&gt;</span><br><span class="line">    <span class="comment">// 处理 InterruptedException</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这能保证我们不会去捕获 <code>NonLocalReturnControl</code> 异常（正如在<a href="#return">Return 语句</a>中所解释的）。</p>
</li>
<li><p>不要在 API 中使用 <code>Try</code>，即，不要在任何方法中返回 Try。对于异常执行，请显式地抛出异常，并使用 Java 风格的 try/catch 做异常处理。</p>
<p>背景资料：Scala 提供了单子（monadic）错误处理（通过 <code>Try</code>，<code>Success</code> 和 <code>Failure</code>），这样便于做链式处理。然而，根据我们的经验，发现使用它通常会带来更多的嵌套层级，使得代码难以阅读。此外，对于预期错误还是异常，在语义上常常是不明晰的。因此，我们不鼓励使用 <code>Try</code> 来做错误处理，尤其是以下情况：</p>
<p>一个人为的例子：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>{</span><br><span class="line">  <span class="comment">/** 在用户数据库中查找用户信息。 */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(userId: <span class="type">Int</span>): <span class="type">Try</span>[<span class="type">User</span>]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>以下的写法会更好：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>{</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在用户数据库中查找用户信息。</span></span><br><span class="line"><span class="comment">   * @return None 如果查找不到用户</span></span><br><span class="line"><span class="comment">   * @throws DatabaseConnectionException 当连接数据库发生异常时</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@throws</span>(<span class="type">DatabaseConnectionException</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(userId: <span class="type">Int</span>): <span class="type">Option</span>[<span class="type">User</span>]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第二种写法非常明显地能让调用者知道需要处理哪些错误情况。</p>
</li>
</ul>
<h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a><a name="option">Options</a></h3><ul>
<li>如果一个值可能为空，那么请使用 <code>Option</code>。相对于 <code>null</code>，<code>Option</code> 显式地表明了一个 API 的返回值可能为空。</li>
<li><p>构造 <code>Option</code> 值时，请使用 <code>Option</code> 而非 <code>Some</code>，以防那个值为 <code>null</code>。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMethod1</span></span>(input: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">Option</span>(transform(input))</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is not as robust because transform can return null, and then</span></span><br><span class="line"><span class="comment">// myMethod2 will return Some(null).</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMethod2</span></span>(input: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">Some</span>(transform(input))</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>不要使用 None 来表示异常，有异常时请显式抛出。</p>
</li>
<li>不要在一个 <code>Option</code> 值上直接调用 <code>get</code> 方法，除非你百分百确定那个 <code>Option</code> 值不是 <code>None</code>。</li>
</ul>
<h3 id="单子链接"><a href="#单子链接" class="headerlink" title="单子链接"></a><a name="chaining">单子链接</a></h3><p>单子链接是 Scala 的一个强大特性。Scala 中几乎一切都是单子（如：集合，Option，Future，Try 等），对它们的操作可以链接在一起。这是一个非常强大的概念，但你应该谨慎使用，尤其是：</p>
<ul>
<li>避免链接（或嵌套）超过 3 个操作。</li>
<li>如果需要花超过 5 秒钟来理解其中的逻辑，那么你应该尽量去想想有没什么办法在不使用单子链接的条件下来达到相同的效果。一般来说，你需要注意的是：不要滥用 <code>flatMap</code> 和 <code>fold</code>。</li>
<li>链接应该在 flatMap 之后断开（因为类型发生了变化）。</li>
</ul>
<p>通过给中间结果显式地赋予一个变量名，将链接断开变成一种更加过程化的风格，能让单子链接更加易于理解。来看下面的例子：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val data: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]</span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">database</span> </span>= <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Person</span>]</span><br><span class="line"><span class="comment">// 有时客户端会给 address 赋予一个 null 值，因此下面的代码用了 Option.apply 来处理这种情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A monadic chaining approach</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAddress</span></span>(name: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">String</span>] = {</span><br><span class="line">  database.get(name).flatMap { elem =&gt;</span><br><span class="line">    elem.data.get(<span class="string">"address"</span>)</span><br><span class="line">      .flatMap(<span class="type">Option</span>.apply)  <span class="comment">// 处理 null 值</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管代码会长一些，但以下方法可读性更高</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAddress</span></span>(name: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">String</span>] = {</span><br><span class="line">  <span class="keyword">if</span> (!database.contains(name)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="type">None</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  database(name).data.get(<span class="string">"address"</span>) <span class="keyword">match</span> {</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(<span class="literal">null</span>) =&gt; <span class="type">None</span>  <span class="comment">// handle null value</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(addr) =&gt; <span class="type">Option</span>(addr)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a><a name="concurrency">并发</a></h2><h3 id="Scala-concurrent-Map"><a href="#Scala-concurrent-Map" class="headerlink" title="Scala concurrent.Map"></a><a name="concurrency-scala-collection">Scala concurrent.Map</a></h3><p><strong>优先考虑使用 <code>java.util.concurrent.ConcurrentHashMap</code> 而非 <code>scala.collection.concurrent.Map</code></strong>。尤其是 <code>scala.collection.concurrent.Map</code> 中的 <code>getOrElseUpdate</code> 方法要慎用，它并非原子操作（这个问题在 Scala 2.11.16 中 fix 了：<a href="https://issues.scala-lang.org/browse/SI-7943" target="_blank" rel="noopener">SI-7943</a>）。由于我们做的所有项目都需要在 Scala 2.10 和 Scala 2.11 上使用，因此要避免使用 <code>scala.collection.concurrent.Map</code>。</p>
<h3 id="显式同步-vs-并发集合"><a href="#显式同步-vs-并发集合" class="headerlink" title="显式同步 vs 并发集合"></a><a name="concurrency-sync-vs-map">显式同步 vs 并发集合</a></h3><p>有 3 种推荐的方法来安全地并发访问共享状态。<strong>不要混用它们</strong>，因为这会使程序变得难以推理，并且可能导致死锁。</p>
<ul>
<li><p><code>java.util.concurrent.ConcurrentHashMap</code>：当所有的状态都存储在一个 map 中，并且有高程度的竞争时使用。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> map = <span class="keyword">new</span> java.util.concurrent.<span class="type">ConcurrentHashMap</span>[<span class="type">String</span>, <span class="type">String</span>]</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>java.util.Collections.synchronizedMap</code>：使用情景：当所有状态都存储在一个 map 中，并且预期不存在竞争情况，但你仍想确保代码在并发下是安全的。如果没有竞争出现，JVM 的 JIT 编译器能够通过偏置锁（biased locking）移除同步开销。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> map = java.util.<span class="type">Collections</span>.synchronizedMap(<span class="keyword">new</span> java.util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>])</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>通过同步所有临界区进行显式同步，可用于监视多个变量。与 2 相似，JVM 的 JIT 编译器能够通过偏置锁（biased locking）移除同步开销。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>{</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> map = <span class="keyword">new</span> java.util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(key: <span class="type">String</span>, value: <span class="type">String</span>): <span class="type">Unit</span> = synchronized {</span><br><span class="line">    map.put(key, value)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getCount</span></span>: <span class="type">Int</span> = synchronized { count }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>注意，对于 case 1 和 case 2，不要让集合的视图或迭代器从保护区域逃逸。这可能会以一种不明显的方式发生，比如：返回了 <code>Map.keySet</code> 或 <code>Map.values</code>。如果需要传递集合的视图或值，生成一份数据拷贝再传递。</p>
  <figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = java.util.<span class="type">Collections</span>.synchronizedMap(<span class="keyword">new</span> java.util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是有问题的！</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">values</span></span>: <span class="type">Iterable</span>[<span class="type">String</span>] = map.values</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用使用下面的写法，把元素拷贝一份。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">values</span></span>: <span class="type">Iterable</span>[<span class="type">String</span>] = map.synchronized { <span class="type">Seq</span>(map.values: _*) }</span><br></pre></td></tr></tbody></table></figure>
<h3 id="显式同步-vs-原子变量-vs-volatile"><a href="#显式同步-vs-原子变量-vs-volatile" class="headerlink" title="显式同步 vs 原子变量 vs @volatile"></a><a name="concurrency-sync-vs-atomic">显式同步 vs 原子变量 vs @volatile</a></h3><p><code>java.util.concurrent.atomic</code> 包提供了对基本类型的无锁访问，比如：<code>AtomicBoolean</code>, <code>AtomicInteger</code> 和 <code>AtomicReference</code>。</p>
<p>始终优先考虑使用原子变量而非 <code>@volatile</code>，它们是相关功能的严格超集并且从代码上看更加明显。原子变量的底层实现使用了 <code>@volatile</code>。</p>
<p>优先考虑使用原子变量而非显式同步的情况：（1）一个对象的所有临界区更新都被限制在单个变量里并且预期会有竞争情况出现。原子变量是无锁的并且允许更为有效的竞争。（2）同步被明确地表示为 <code>getAndSet</code> 操作。例如：</p>
  <figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good: 明确又有效地表达了下面的并发代码只执行一次</span></span><br><span class="line"><span class="keyword">val</span> initialized = <span class="keyword">new</span> <span class="type">AtomicBoolean</span>(<span class="literal">false</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!initialized.getAndSet(<span class="literal">true</span>)) {</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// poor: 下面的同步就没那么明晰，而且会出现不必要的同步</span></span><br><span class="line"><span class="keyword">val</span> initialized = <span class="literal">false</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> wasInitialized = <span class="literal">false</span></span><br><span class="line">synchronized {</span><br><span class="line">  wasInitialized = initialized</span><br><span class="line">  initialized = <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!wasInitialized) {</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="私有字段"><a href="#私有字段" class="headerlink" title="私有字段"></a><a name="concurrency-private-this">私有字段</a></h3><p>注意，<code>private</code> 字段仍然可以被相同类的其它实例所访问，所以仅仅通过 <code>this.synchronized</code>（或 <code>synchronized</code>）来保护它从技术上来说是不够的，不过你可以通过 <code>private[this]</code> 修饰私有字段来达到目的。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码仍然是不安全的。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> count: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inc</span></span>(): <span class="type">Unit</span> = synchronized { count += <span class="number">1</span> }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码是安全的。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>{</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> count: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inc</span></span>(): <span class="type">Unit</span> = synchronized { count += <span class="number">1</span> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a><a name="concurrency-isolation">隔离</a></h3><p>一般来说，并发和同步逻辑应该尽可能地被隔离和包含起来。这实际上意味着：</p>
<ul>
<li>避免在 API 层面、面向用户的方法以及回调中暴露同步原语。</li>
<li>对于复杂模块，创建一个小的内部模块来包含并发原语。</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a><a name="perf">性能</a></h2><p>对于你写的绝大多数代码，性能都不应该成为一个问题。然而，对于一些性能敏感的代码，以下有一些小建议：</p>
<h3 id="Microbenchmarks"><a href="#Microbenchmarks" class="headerlink" title="Microbenchmarks"></a><a name="perf-microbenchmarks">Microbenchmarks</a></h3><p>由于 Scala 编译器和 JVM JIT 编译器会对你的代码做许多神奇的事情，因此要写出一个好的微基准程序（microbenchmark）是极其困难的。更多的情况往往是你的微基准程序并没有测量你想要测量的东西。</p>
<p>如果你要写一个微基准程序，请使用 <a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">jmh</a>。请确保你阅读了<a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/" target="_blank" rel="noopener">所有的样例</a>，这样你才理解微基准程序中「死代码」移除、常量折叠以及循环展开的效果。</p>
<h3 id="Traversal-与-zipWithIndex"><a href="#Traversal-与-zipWithIndex" class="headerlink" title="Traversal 与 zipWithIndex"></a><a name="perf-whileloops">Traversal 与 zipWithIndex</a></h3><p>使用 <code>while</code> 循环而非 <code>for</code> 循环或函数变换（如：<code>map</code>、<code>foreach</code>），for 循环和函数变换非常慢（由于虚函数调用和装箱的缘故）。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> arr = <span class="comment">// array of ints</span></span><br><span class="line"><span class="comment">// 偶数位置的数置零</span></span><br><span class="line"><span class="keyword">val</span> newArr = list.zipWithIndex.map { <span class="keyword">case</span> (elem, i) =&gt;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> elem</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是上面代码的高性能版本</span></span><br><span class="line"><span class="keyword">val</span> newArr = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](arr.length)</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> len = newArr.length</span><br><span class="line"><span class="keyword">while</span> (i &lt; len) {</span><br><span class="line">  newArr(i) = <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> arr(i)</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Option-与-null"><a href="#Option-与-null" class="headerlink" title="Option 与 null"></a><a name="perf-option">Option 与 null</a></h3><p>对于性能有要求的代码，优先考虑使用 <code>null</code> 而不是 <code>Option</code>，以此避免虚函数调用以及装箱操作。用 Nullable 注解明确标示出可能为 <code>null</code> 的值。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>{</span><br><span class="line">  <span class="meta">@javax</span>.annotation.<span class="type">Nullable</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> nullableField: <span class="type">Bar</span> = _</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Scala-集合库"><a href="#Scala-集合库" class="headerlink" title="Scala 集合库"></a><a name="perf-collection">Scala 集合库</a></h3><p>对于性能有要求的代码，优先考虑使用 Java 集合库而非 Scala 集合库，因为一般来说，Scala 集合库要比 Java 的集合库慢。</p>
<h3 id="private-this"><a href="#private-this" class="headerlink" title="private[this]"></a><a name="perf-private">private[this]</a></h3><p>对于性能有要求的代码，优先考虑使用 <code>private[this]</code> 而非 <code>private</code>。<code>private[this]</code> 生成一个字段而非生成一个访问方法。根据我们的经验，JVM JIT 编译器并不总是会内联 <code>private</code> 字段的访问方法，因此通过使用<br><code>private[this]</code> 来确保没有虚函数调用会更保险。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> field1 = ...</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> field2 = ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">perfSensitiveMethod</span></span>(): <span class="type">Unit</span> = {</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">1000000</span>) {</span><br><span class="line">      field1  <span class="comment">// This might invoke a virtual method call</span></span><br><span class="line">      field2  <span class="comment">// This is just a field access</span></span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="与-Java-的互操作性"><a href="#与-Java-的互操作性" class="headerlink" title="与 Java 的互操作性"></a><a name="java">与 Java 的互操作性</a></h2><p>本节内容介绍的是构建 Java 兼容 API 的准则。如果你构建的组件并不需要与 Java 有交互，那么请无视这一节。这一节的内容主要是从我们开发 Spark 的 Java API 的经历中得出的。</p>
<h3 id="Scala-中缺失的-Java-特性"><a href="#Scala-中缺失的-Java-特性" class="headerlink" title="Scala 中缺失的 Java 特性"></a><a name="java-missing-features">Scala 中缺失的 Java 特性</a></h3><p>以下的 Java 特性在 Scala 中是没有的，如果你需要使用以下特性，请在 Java 中定义它们。然而，需要提醒一点的是，你无法为 Java 源文件生成 ScalaDoc。</p>
<ul>
<li>静态字段</li>
<li>静态内部类</li>
<li>Java 枚举</li>
<li>注解</li>
</ul>
<h3 id="Traits-与抽象类"><a href="#Traits-与抽象类" class="headerlink" title="Traits 与抽象类"></a><a name="java-traits">Traits 与抽象类</a></h3><p>对于允许从外部实现的接口，请记住以下几点：</p>
<ul>
<li>包含了默认方法实现的 trait 是无法在 Java 中使用的，请使用抽象类来代替。</li>
<li>一般情况下，请避免使用 trait，除非你百分百确定这个接口即使在未来也不会有默认的方法实现。</li>
</ul>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下默认实现无法在 Java 中使用</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Listener</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onTermination</span></span>(): <span class="type">Unit</span> = { ... }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在 Java 中使用</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onTermination</span></span>(): <span class="type">Unit</span> = { ... }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a><a name="java-type-alias">类型别名</a></h3><p>不要使用类型别名，它们在字节码和 Java 中是不可见的。</p>
<h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a><a name="java-default-param-values">默认参数值</a></h3><p>不要使用默认参数值，通过重载方法来代替。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打破了与 Java 的互操作性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span></span>(ratio: <span class="type">Double</span>, withReplacement: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">RDD</span>[<span class="type">T</span>] = { ... }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下方法是 work 的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span></span>(ratio: <span class="type">Double</span>, withReplacement: <span class="type">Boolean</span>): <span class="type">RDD</span>[<span class="type">T</span>] = { ... }</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span></span>(ratio: <span class="type">Double</span>): <span class="type">RDD</span>[<span class="type">T</span>] = sample(ratio, withReplacement = <span class="literal">false</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="多参数列表-1"><a href="#多参数列表-1" class="headerlink" title="多参数列表"></a><a name="java-multi-param-list">多参数列表</a></h3><p>不要使用多参数列表。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><a name="java-varargs">可变参数</a></h3><ul>
<li><p>为可变参数方法添加 <a href="mailto:`@scala.annotation.varargs" target="_blank" rel="noopener">`@scala.annotation.varargs</a>` 注解，以确保它能在 Java 中使用。Scala 编译器会生成两个方法，一个给 Scala 使用（字节码参数是一个 Seq），另一个给 Java 使用（字节码参数是一个数组）。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@scala</span>.annotation.varargs</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span></span>(exprs: <span class="type">Expression</span>*): <span class="type">DataFrame</span> = { ... }</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>需要注意的一点是，由于 Scala 编译器的一个 bug（<a href="https://issues.scala-lang.org/browse/SI-1459" target="_blank" rel="noopener">SI-1459</a>，<a href="https://issues.scala-lang.org/browse/SI-9013" target="_blank" rel="noopener">SI-9013</a>），抽象的变参方法是无法在 Java 中使用的。</p>
</li>
<li><p>重载变参方法时要小心，用另一个类型去重载变参方法会破坏源码的兼容性。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Database</span> </span>{</span><br><span class="line">  <span class="meta">@scala</span>.annotation.varargs</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove</span></span>(elems: <span class="type">String</span>*): <span class="type">Unit</span> = ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当调用无参的 remove 方法时会出问题。</span></span><br><span class="line">  <span class="meta">@scala</span>.annotation.varargs</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove</span></span>(elems: <span class="type">People</span>*): <span class="type">Unit</span> = ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove 方法有歧义，因此编译不过。</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">Database</span>().remove()</span><br></pre></td></tr></tbody></table></figure>
<p>一种解决方法是，在可变参数前显式地定义第一个参数：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Database</span> </span>{</span><br><span class="line">  <span class="meta">@scala</span>.annotation.varargs</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove</span></span>(elems: <span class="type">String</span>*): <span class="type">Unit</span> = ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下重载是 OK 的。</span></span><br><span class="line">  <span class="meta">@scala</span>.annotation.varargs</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove</span></span>(elem: <span class="type">People</span>, elems: <span class="type">People</span>*): <span class="type">Unit</span> = ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="Implicits-1"><a href="#Implicits-1" class="headerlink" title="Implicits"></a><a name="java-implicits">Implicits</a></h3><p>不要为类或方法使用 implicit，包括了不要使用 <code>ClassTag</code> 和 <code>TypeTag</code>。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaFriendlyAPI</span> </span>{</span><br><span class="line">  <span class="comment">// 以下定义对 Java 是不友好的，因为方法中包含了一个隐式参数（ClassTag）。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">convertTo</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](): <span class="type">T</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="伴生对象，静态方法与字段"><a href="#伴生对象，静态方法与字段" class="headerlink" title="伴生对象，静态方法与字段"></a><a name="java-companion-object">伴生对象，静态方法与字段</a></h3><p>当涉及到伴生对象和静态方法/字段时，有几件事情是需要注意的：</p>
<ul>
<li><p>伴生对象在 Java 中的使用是非常别扭的（伴生对象 <code>Foo</code> 会被定义为 <code>Foo$</code> 类内的一个类型为 <code>Foo$</code> 的静态字段 <code>MODULE$</code>）。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">等价于以下的</span> <span class="title">Java</span> <span class="title">代码</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Foo$</span> </span>{</span><br><span class="line">  <span class="type">Foo</span>$ <span class="type">MODULE</span>$ = <span class="comment">// 对象的实例化</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果非要使用伴生对象，可以在一个单独的类中创建一个 Java 静态字段。</p>
</li>
<li><p>不幸的是，没有办法在 Scala 中定义一个 JVM 静态字段。请创建一个 Java 文件来定义它。</p>
</li>
<li><p>伴生对象里的方法会被自动转成伴生类里的静态方法，除非方法名有冲突。确保静态方法正确生成的最好方式是用 Java 写一个测试文件，然后调用生成的静态方法。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method2</span></span>(): <span class="type">Unit</span> = { ... }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Foo</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method1</span></span>(): <span class="type">Unit</span> = { ... }  <span class="comment">// 静态方法 Foo.method1 会被创建（字节码）</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method2</span></span>(): <span class="type">Unit</span> = { ... }  <span class="comment">// 静态方法 Foo.method2 不会被创建</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// FooJavaTest.java (in test/scala/com/databricks/...)</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FooJavaTest</span> </span>{</span><br><span class="line">  public static void compileTest() {</span><br><span class="line">    <span class="type">Foo</span>.method1();  <span class="comment">// 正常编译</span></span><br><span class="line">    <span class="type">Foo</span>.method2();  <span class="comment">// 编译失败，因为 method2 并没有生成</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>样例对象（case object） MyClass 的类型并不是 MyClass。</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">Test</span>.<span class="title">java</span></span></span><br><span class="line"><span class="class"><span class="title">if</span> (<span class="params"><span class="type">MyClass</span>$.<span class="type">MODULE</span> instanceof <span class="type">MyClass</span></span>) </span>{</span><br><span class="line">  <span class="comment">// 上述条件始终为 false</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要实现正确的类型层级结构，请定义一个伴生类，然后用一个样例对象去继承它：</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MyClass</span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><a name="testing">测试</a></h2><h3 id="异常拦截"><a href="#异常拦截" class="headerlink" title="异常拦截"></a><a name="testing-intercepting">异常拦截</a></h3><p>当测试某个操作（比如用无效的参数调用一个函数）是否会抛出异常时，对于抛出的异常类型指定得越具体越好。你不应该简单地使用 <code>intercept[Exception]</code> 或 <code>intercept[Throwable]</code>（ScalaTest 语法），这能拦截任意异常，只能断言有异常抛出，而不能确定是什么异常。这样做在测试中能捕获到代码中的异常并且通过测试，然而却没真正检验你想验证的行为。</p>
  <figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要使用下面这种方式</span></span><br><span class="line">intercept[<span class="type">Exception</span>] {</span><br><span class="line">  thingThatThrowsException()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这才是推荐的做法</span></span><br><span class="line">intercept[<span class="type">MySpecificTypeOfException</span>] {</span><br><span class="line">  thingThatThrowsException()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果你无法指定代码会抛出的异常的具体类型，说明你这段代码可能写得不好，需要重构。这种情况下，你要么测试更底层的代码，要么改写代码令其抛出类型更加具体的异常。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a><a name="misc">其它</a></h2><h3 id="优先使用-nanoTime-而非-currentTimeMillis"><a href="#优先使用-nanoTime-而非-currentTimeMillis" class="headerlink" title="优先使用 nanoTime 而非 currentTimeMillis"></a><a name="misc_currentTimeMillis_vs_nanoTime">优先使用 nanoTime 而非 currentTimeMillis</a></h3><p>当要计算<em>持续时间</em>或者检查<em>超时</em>的时候，避免使用 <code>System.currentTimeMillis()</code>。请使用 <code>System.nanoTime()</code>，即使你对亚毫秒级的精度并不感兴趣。</p>
<p><code>System.currentTimeMillis()</code> 返回的是当前的时钟时间，并且会跟进系统时钟的改变。因此，负的时钟调整可能会导致超时而挂起很长一段时间（直到时钟时间赶上先前的值）。这种情况可能发生在网络已经中断一段时间，ntpd 走过了一步之后。最典型的例子是，在系统启动的过程中，DHCP 花费的时间要比平常的长。这可能会导致非常难以理解且难以重现的问题。而 <code>System.nanoTime()</code> 则可以保证是单调递增的，与时钟变化无关。</p>
<p>注意事项：</p>
<ul>
<li>永远不要序列化一个绝对的 <code>nanoTime()</code> 值或是把它传递给另一个系统。绝对的 <code>nanoTime()</code> 值是无意义的、与系统相关的，并且在系统重启时会重置。</li>
<li>绝对的 <code>nanoTime()</code> 值并不保证总是正数（但 <code>t2 - t1</code> 能确保总是产生正确的值）。</li>
<li><code>nanoTime()</code> 每 292 年就会重新计算起。所以，如果你的 Spark 任务需要花非常非常非常长的时间，你可能需要别的东西来处理了：）</li>
</ul>
<h3 id="优先使用-URI-而非-URL"><a href="#优先使用-URI-而非-URL" class="headerlink" title="优先使用 URI 而非 URL"></a><a name="misc_uri_url">优先使用 URI 而非 URL</a></h3><p>当存储服务的 URL 时，你应当使用 <code>URI</code> 来表示。</p>
<p><code>URL</code> 的<a href="http://docs.oracle.com/javase/7/docs/api/java/net/URL.html#equals(java.lang.Object" target="_blank" rel="noopener">相等性检查</a>)实际上执行了一次网络调用（这是阻塞的）来解析 IP 地址。<code>URI</code> 类在表示能力上是 <code>URL</code> 的超集，并且它执行的是字段的相等性检查。</p>
<h3 id="优先使用现存的经过良好测试的方法而非重新发明轮子"><a href="#优先使用现存的经过良好测试的方法而非重新发明轮子" class="headerlink" title="优先使用现存的经过良好测试的方法而非重新发明轮子"></a><a name="misc_well_tested_method">优先使用现存的经过良好测试的方法而非重新发明轮子</a></h3><p>当存在一个已经经过良好测试的方法，并且不会存在性能问题，那么优先使用这个方法。重新实现它可能会引入Bug，同时也需要花费时间来进行测试（也可能我们甚至忘记去测试这个方法！）。</p>
  <figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> beginNs = <span class="type">System</span>.nanoTime()</span><br><span class="line"><span class="comment">// Do something</span></span><br><span class="line"><span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">val</span> elapsedNs = <span class="type">System</span>.nanoTime() - beginNs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要使用下面这种方式。这种方法容易出错</span></span><br><span class="line"><span class="keyword">val</span> elapsedMs = elapsedNs / <span class="number">1000</span> / <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐方法：使用Java TimeUnit API</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.<span class="type">TimeUnit</span></span><br><span class="line"><span class="keyword">val</span> elapsedMs2 = <span class="type">TimeUnit</span>.<span class="type">NANOSECONDS</span>.toMillis(elapsedNs)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐方法：使用Scala Duration API</span></span><br><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"><span class="keyword">val</span> elapsedMs3 = elapsedNs.nanos.toMillis</span><br></pre></td></tr></tbody></table></figure>
<p>例外：</p>
<ul>
<li>使用现存的方法需要引入新的依赖。如果一个方法特别简单，比起引入一个新依赖，重新实现它通常更好。但是记得进行测试。</li>
<li>现存的方法没有针对我们的用法进行优化，性能达不到要求。但是首先做一下benchmark, 避免过早优化。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/scala/" rel="tag"># scala</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/26/Mac移除浏览器劫持AnySearch/" rel="prev" title="Mac移除浏览器劫持AnySearch">
      <i class="fa fa-chevron-left"></i> Mac移除浏览器劫持AnySearch
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#声明-Disclaimer"><span class="nav-number">1.</span> <span class="nav-text">声明 (Disclaimer)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">2.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目录"><span class="nav-number">3.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文档历史"><span class="nav-number">4.</span> <span class="nav-text">文档历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语法风格"><span class="nav-number">5.</span> <span class="nav-text">语法风格</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命名约定"><span class="nav-number">5.1.</span> <span class="nav-text">命名约定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量命名约定"><span class="nav-number">5.2.</span> <span class="nav-text">变量命名约定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一行长度"><span class="nav-number">5.3.</span> <span class="nav-text">一行长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-法则"><span class="nav-number">5.4.</span> <span class="nav-text">30 法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空格与缩进"><span class="nav-number">5.5.</span> <span class="nav-text">空格与缩进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空行"><span class="nav-number">5.6.</span> <span class="nav-text">空行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#括号"><span class="nav-number">5.7.</span> <span class="nav-text">括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大括号"><span class="nav-number">5.8.</span> <span class="nav-text">大括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#长整型字面量"><span class="nav-number">5.9.</span> <span class="nav-text">长整型字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文档风格"><span class="nav-number">5.10.</span> <span class="nav-text">文档风格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类内秩序"><span class="nav-number">5.11.</span> <span class="nav-text">类内秩序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Imports"><span class="nav-number">5.12.</span> <span class="nav-text">Imports</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式匹配"><span class="nav-number">5.13.</span> <span class="nav-text">模式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中缀方法"><span class="nav-number">5.14.</span> <span class="nav-text">中缀方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名方法"><span class="nav-number">5.15.</span> <span class="nav-text">匿名方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scala-语言特性"><span class="nav-number">6.</span> <span class="nav-text">Scala 语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#样例类与不可变性"><span class="nav-number">6.1.</span> <span class="nav-text">样例类与不可变性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply-方法"><span class="nav-number">6.2.</span> <span class="nav-text">apply 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#override-修饰符"><span class="nav-number">6.3.</span> <span class="nav-text">override 修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解构绑定"><span class="nav-number">6.4.</span> <span class="nav-text">解构绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按名称传参"><span class="nav-number">6.5.</span> <span class="nav-text">按名称传参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多参数列表"><span class="nav-number">6.6.</span> <span class="nav-text">多参数列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号方法（运算符重载）"><span class="nav-number">6.7.</span> <span class="nav-text">符号方法（运算符重载）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型推导"><span class="nav-number">6.8.</span> <span class="nav-text">类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Return-语句"><span class="nav-number">6.9.</span> <span class="nav-text">Return 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归及尾递归"><span class="nav-number">6.10.</span> <span class="nav-text">递归及尾递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implicits"><span class="nav-number">6.11.</span> <span class="nav-text">Implicits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号文本"><span class="nav-number">6.12.</span> <span class="nav-text">符号文本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理-Try-还是-try"><span class="nav-number">7.</span> <span class="nav-text">异常处理 (Try 还是 try)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Options"><span class="nav-number">7.1.</span> <span class="nav-text">Options</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单子链接"><span class="nav-number">7.2.</span> <span class="nav-text">单子链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发"><span class="nav-number">8.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scala-concurrent-Map"><span class="nav-number">8.1.</span> <span class="nav-text">Scala concurrent.Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显式同步-vs-并发集合"><span class="nav-number">8.2.</span> <span class="nav-text">显式同步 vs 并发集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显式同步-vs-原子变量-vs-volatile"><span class="nav-number">8.3.</span> <span class="nav-text">显式同步 vs 原子变量 vs @volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私有字段"><span class="nav-number">8.4.</span> <span class="nav-text">私有字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隔离"><span class="nav-number">8.5.</span> <span class="nav-text">隔离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能"><span class="nav-number">9.</span> <span class="nav-text">性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Microbenchmarks"><span class="nav-number">9.1.</span> <span class="nav-text">Microbenchmarks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Traversal-与-zipWithIndex"><span class="nav-number">9.2.</span> <span class="nav-text">Traversal 与 zipWithIndex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Option-与-null"><span class="nav-number">9.3.</span> <span class="nav-text">Option 与 null</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scala-集合库"><span class="nav-number">9.4.</span> <span class="nav-text">Scala 集合库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#private-this"><span class="nav-number">9.5.</span> <span class="nav-text">private[this]</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与-Java-的互操作性"><span class="nav-number">10.</span> <span class="nav-text">与 Java 的互操作性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scala-中缺失的-Java-特性"><span class="nav-number">10.1.</span> <span class="nav-text">Scala 中缺失的 Java 特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Traits-与抽象类"><span class="nav-number">10.2.</span> <span class="nav-text">Traits 与抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型别名"><span class="nav-number">10.3.</span> <span class="nav-text">类型别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认参数值"><span class="nav-number">10.4.</span> <span class="nav-text">默认参数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多参数列表-1"><span class="nav-number">10.5.</span> <span class="nav-text">多参数列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数"><span class="nav-number">10.6.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implicits-1"><span class="nav-number">10.7.</span> <span class="nav-text">Implicits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伴生对象，静态方法与字段"><span class="nav-number">10.8.</span> <span class="nav-text">伴生对象，静态方法与字段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试"><span class="nav-number">11.</span> <span class="nav-text">测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异常拦截"><span class="nav-number">11.1.</span> <span class="nav-text">异常拦截</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其它"><span class="nav-number">12.</span> <span class="nav-text">其它</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优先使用-nanoTime-而非-currentTimeMillis"><span class="nav-number">12.1.</span> <span class="nav-text">优先使用 nanoTime 而非 currentTimeMillis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先使用-URI-而非-URL"><span class="nav-number">12.2.</span> <span class="nav-text">优先使用 URI 而非 URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先使用现存的经过良好测试的方法而非重新发明轮子"><span class="nav-number">12.3.</span> <span class="nav-text">优先使用现存的经过良好测试的方法而非重新发明轮子</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Freehuber" src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Freehuber</p>
  <div class="site-description" itemprop="description">左手写诗，右手撸码</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/freehubs" title="GitHub → https://github.com/freehubs" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  © 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Freehuber</span>
</div>

        








      </div>
    </footer>
  </div>

  
  
  
  






  




  












  

  







<script src="/bundle.js"></script><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '47209006cdab2e987d9e',
      clientSecret: 'c7df73e28dcfcef507958f6cf2457857ac9776be',
      repo: 'freehubs.github.io',
      owner: 'freehubs',
      admin: ['freehubs'],
      id: '5eabfdedee9b40d9fd52f1dc314bf6c8',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></body></html>