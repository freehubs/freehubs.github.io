{"meta":{"title":"Freehubs","subtitle":null,"description":"左手写诗，右手撸码","author":"Freehuber","url":"https://freehubs.github.io"},"posts":[{"title":"Databricks-Scala 编程风格指南","slug":"Databricks-Scala-编程风格指南","date":"2020-05-13T15:14:08.000Z","updated":"2020-05-13T15:14:08.000Z","comments":true,"path":"2020/05/13/Databricks-Scala-编程风格指南/","link":"","permalink":"https://freehubs.github.io/2020/05/13/Databricks-Scala-编程风格指南/","excerpt":"声明 (Disclaimer)The Chinese version of the Databricks Scala Guide is contributed and maintained by community member Hawstein. We do not guarantee that it will always be kept up-to-date.\n本文档翻译自 Databricks Scala Guide，目前由 Hawstein 进行维护。由于是利用业余时间进行翻译并维护，因此该中文文档并不保证总是与原文档一样处于最新版本，不过我会尽可能及时地去更新它。\n前言Spark 有超过 1000 位贡献者，就我们所知，应该是目前大数据领域里最大的开源项目且是最活跃的 Scala 项目。这份指南是在我们指导，或是与 Spark 贡献者及 Databricks 工程团队一起工作时总结出来的。\n代码由作者 一次编写 ，然后由大量工程师 多次阅读并修改 。事实上，大部分的 bug 来源于后人对代码的修改，因此我们需要长期去优化我们的代码，提升代码的可读性和可维护性。达到这个目标最好的方式就是编写简单易懂的代码。\nScala 是一种强大到令人难以置信的多范式编程语言。我们总结出了以下指南，它可以很好地应用在一个高速发展的项目。当然，这个指南并非绝对，根据团队需求的不同，可以有不同的标准。\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.","text":"声明 (Disclaimer)The Chinese version of the Databricks Scala Guide is contributed and maintained by community member Hawstein. We do not guarantee that it will always be kept up-to-date. 本文档翻译自 Databricks Scala Guide，目前由 Hawstein 进行维护。由于是利用业余时间进行翻译并维护，因此该中文文档并不保证总是与原文档一样处于最新版本，不过我会尽可能及时地去更新它。 前言Spark 有超过 1000 位贡献者，就我们所知，应该是目前大数据领域里最大的开源项目且是最活跃的 Scala 项目。这份指南是在我们指导，或是与 Spark 贡献者及 Databricks 工程团队一起工作时总结出来的。 代码由作者 一次编写 ，然后由大量工程师 多次阅读并修改 。事实上，大部分的 bug 来源于后人对代码的修改，因此我们需要长期去优化我们的代码，提升代码的可读性和可维护性。达到这个目标最好的方式就是编写简单易懂的代码。 Scala 是一种强大到令人难以置信的多范式编程语言。我们总结出了以下指南，它可以很好地应用在一个高速发展的项目。当然，这个指南并非绝对，根据团队需求的不同，可以有不同的标准。 This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. 目录 文档历史 语法风格 命名约定 变量命名约定 一行长度 30 法则 空格与缩进 空行 括号 大括号 长整型字面量 文档风格 类内秩序 Imports 模式匹配 中缀方法 匿名方法 Scala 语言特性 样例类与不可变性 apply 方法 override 修饰符 解构绑定 按名称传参 多参数列表 符号方法 (运算符重载) 类型推导 Return 语句 递归及尾递归 Implicits 异常处理 (Try 还是 try) Options 单子链接 符号文本 并发 Scala concurrent.Map 显式同步 vs 并发集合 显式同步 vs 原子变量 vs @volatile 私有字段 隔离 性能 Microbenchmarks Traversal 与 zipWithIndex Option 与 null Scala 集合库 private[this] 与 Java 的互操作性 Scala 中缺失的 Java 特性 Traits 与抽象类 类型别名 默认参数值 多参数列表 可变参数 Implicits 伴生对象, 静态方法与字段 测试 异常拦截 其它 优先使用 nanoTime 而非 currentTimeMillis 优先使用 URI 而非 URL 优先使用现存的经过良好测试的方法而非重新发明轮子 文档历史 2015-03-16: 最初版本。 2015-05-25: 增加 override 修饰符 一节。 2015-08-23: 把一些规则的严重程度从「不要」降级到「避免」。 2015-11-17: 更新 apply 方法 一节：伴生对象中的 apply 方法应该返回其伴生类。 2015-11-17: 该指南被翻译成中文，由 Hawstein 进行维护，中文文档并不保证总是与原文档一样处于最新版本。 2015-12-14: 该指南被翻译成韩文, 韩文版本由 Hyukjin Kwon 进行翻译并且由 Yun Park, Kevin (Sangwoo) Kim, Hyunje Jo 和 Woochel Choi 进行校对。韩文版本并不保证总是与原文档一样处于最新版本。 2016-06-15: 增加 匿名方法 一节。 2016-06-21: 增加 变量命名约定 一节。 2016-12-24: 增加 样例类与不可变性 一节。 2017-02-23: 增加 测试 一节。 2017-04-18: 增加 优先使用现存的经过良好测试的方法而非重新发明轮子 一节。 2019-12-18: 增加 符号文本 一节。 语法风格命名约定我们主要遵循 Java 和 Scala 的标准命名约定。 类，trait, 对象应该遵循 Java 中类的命名约定，即 PascalCase 风格。 123class ClusterManagertrait Expression 包名应该遵循 Java 中包名的命名约定，即使用全小写的 ASCII 字母。 1package com.databricks.resourcemanager 方法/函数应当使用驼峰式风格命名。 常量命名使用全大写字母，并将它们放在伴生对象中。 123object Configuration &#123; val DEFAULT_PORT = 10000&#125; 从 Enumeration 类继承的枚举类或对象应遵循类或对象的相关约定，比如：命名应使用 PascalCase 风格。枚举值的命名则应采用大写字母的形式，并在单词之间使用下划线 _ 进行分隔。例如： 12345678910111213 private object ParseState extends Enumeration &#123; type ParseState = Value val PREFIX, TRIM_BEFORE_SIGN, SIGN, TRIM_BEFORE_VALUE, VALUE, VALUE_FRACTIONAL_PART, TRIM_BEFORE_UNIT, UNIT_BEGIN, UNIT_SUFFIX, UNIT_END = Value&#125; 注解也应遵循 Java 中的约定，即使用 PascalCase 风格。注意，这一点与 Scala 的官方指南不同。 1final class MyAnnotation extends StaticAnnotation 变量命名约定 变量命名应当遵循驼峰式命名方法，并且变量名应当是不言而喻的，即变量名可以直观地反应它的涵义。 12val serverPort = 1000val clientPort = 2000 可以在小段的局部代码中使用单字符的变量名，比如在小段的循环体中（例如 10 行以内的代码），“i” 常常被用作循环索引。然而，即使在小段的代码中，也不要使用 “l” （Larry 中的 l）作为标识符，因为它看起来和 “1”，“|”，“I” 很像，难以区分，容易搞错。 一行长度 一行长度的上限是 100 个字符。 唯一的例外是 import 语句和 URL (即便如此，也尽量将它们保持在 100 个字符以下)。 30 法则「如果一个元素包含的子元素超过 30 个，那么极有可能出现了严重的问题」 - Refactoring in Large Software Projects。 一般来说: 一个方法包含的代码行数不宜超过 30 行。 一个类包含的方法数量不宜超过 30 个。 空格与缩进 运算符前后保留一个空格，包括赋值运算符。 1def add(int1: Int, int2: Int): Int = int1 + int2 逗号后保留一个空格。 123Seq(\"a\", \"b\", \"c\") // 使用这种方式Seq(\"a\",\"b\",\"c\") // 不要忽略逗号后的空格 冒号后保留一个空格。 123456789101112// 使用这种方式def getConf(key: String, defaultValue: String): String = &#123; // some code&#125;// 冒号前不需要使用空格def calculateHeaderPortionInBytes(count: Int) : Int = &#123; // some code&#125;// 不要忽略冒号后的空格def multiply(int1:Int, int2:Int): Int = int1 * int2 一般情况下，使用两个空格的缩进。 123if (true) &#123; println(\"Wow!\")&#125; 对于方法声明，如果两行无法容纳下所有的参数，那么将每个参数单独放在一行，并使用 4 个空格进行缩进。返回类型可以与最后一个参数在同一行，也可以放在新的一行，使用两个空格缩进。 123456789101112131415161718def newAPIHadoopFile[K, V, F &lt;: NewInputFormat[K, V]]( path: String, fClass: Class[F], kClass: Class[K], vClass: Class[V], conf: Configuration = hadoopConfiguration): RDD[(K, V)] = &#123; // 方法体&#125;def newAPIHadoopFile[K, V, F &lt;: NewInputFormat[K, V]]( path: String, fClass: Class[F], kClass: Class[K], vClass: Class[V], conf: Configuration = hadoopConfiguration) : RDD[(K, V)] = &#123; // 方法体&#125; 如果两行无法容纳下类头（即 { 前面的部分），那么将每个类参数单独放在一行，并使用 4 个空格进行缩进；将 extends 关键字放在（最后一个参数的）下一行，并使用 2 个空格进行缩进。在类头定义结束后空一行，再开始类内函数或变量的定义。 123456789class Foo( val param1: String, // 对参数使用 4 个空格进行缩进 val param2: String, val param3: Array[Byte]) extends FooInterface // 这里使用 2 个空格进行缩进 with Logging &#123; def firstMethod(): Unit = &#123; ... &#125; // 上面空一行&#125; 对于方法和类的构造函数调用，如果两行无法容纳下所有的参数，那么将每个参数单独放在一行，并使用 2 个空格进行缩进。 1234567891011foo( someVeryLongFieldName, // 这里使用 2 个空格进行缩进 andAnotherVeryLongFieldName, \"this is a string\", 3.1415)new Bar( someVeryLongFieldName, // 这里使用 2 个空格进行缩进 andAnotherVeryLongFieldName, \"this is a string\", 3.1415) 不要使用垂直对齐。它使你的注意力放在代码的错误部分并增大了后人修改代码的难度。 123456789// 不要（对等于号）使用垂直对齐val plus = \"+\"val minus = \"-\"val multiply = \"*\"// 使用下面的写法val plus = \"+\"val minus = \"-\"val multiply = \"*\" 空行 一个空行可以出现在： 连续的类成员或初始化器（initializers）之间：字段，构造函数，方法，嵌套类，静态初始化器及实例初始化器。 例外：连续的两个字段之间的空行是可选的（前提是它们之间没有其它代码），这一类空行主要为这些字段做逻辑上的分组。 在方法体内，根据需要，使用空行来为语句创建逻辑上的分组。 在类的第一个成员之前或最后一个成员之后，空行都是可选的（既不鼓励也不阻止）。 使用一个或两个空行来分隔不同类或对象的定义。 不鼓励使用过多的空行。 括号 方法声明应该加括号（即使没有参数列表），除非它们是没有副作用（状态改变，IO 操作都认为是有副作用的）的访问器（accessor）。 1234567class Job &#123; // 错误：killJob 会改变状态，应该加上括号。 def killJob: Unit // 正确： def killJob(): Unit&#125; 函数调用应该与函数声明在形式上保持一致，也就是说，如果一个方法声明时带了括号，那调用时也要把括号带上。注意这不仅仅是语法层面的人为约定，当返回对象中定义了 apply 方法时，这一点还会影响正确性。 12345678910class Foo &#123; def apply(args: String*): Int&#125;class Bar &#123; def foo: Foo&#125;new Bar().foo // 这里返回一个 Foo 对象new Bar().foo() // 这里返回一个 Int 值！ 大括号即使条件语句或循环语句只有一行时，也请使用大括号。唯一的例外是，当你把 if/else 作为一个单行的三元操作符来使用并且没有副作用时，这时你可以不加大括号。 1234567891011121314151617181920212223// 正确：if (true) &#123; println(\"Wow!\")&#125;// 正确：if (true) statement1 else statement2// 正确：try &#123; foo()&#125; catch &#123; ...&#125;// 错误：if (true) println(\"Wow!\")// 错误：try foo() catch &#123; ...&#125; 长整型字面量长整型字面量使用大写的 L 作为后缀，不要使用小写，因为它和数字 1 长得很像，常常难以区分。 123val longValue = 5432L // 这样写val longValue = 5432l // 不要这样写 文档风格使用 Java Doc 风格，而非 Scala Doc 风格。 1234567891011/** This is a correct one-liner, short description. *//** * This is correct multi-line JavaDoc comment. And * this is my second line, and if I keep typing, this would be * my third line. *//** In Spark, we don't use the ScalaDoc style so this * is not correct. */ 类内秩序如果一个类很长，包含许多的方法，那么在逻辑上把它们分成不同的部分并加上注释头，以此组织它们。 1234567891011121314class DataFrame &#123; /////////////////////////////////////////////////////////////////////////// // DataFrame operations /////////////////////////////////////////////////////////////////////////// ... /////////////////////////////////////////////////////////////////////////// // RDD operations /////////////////////////////////////////////////////////////////////////// ...&#125; 当然，强烈不建议把一个类写得这么长，一般只有在构建某些公共 API 时才允许这么做。 Imports 导入时避免使用通配符, 除非你需要导入超过 6 个实体或者隐式方法。通配符导入会使代码在面对外部变化时不够健壮。 始终使用绝对路径来导入包 (如：scala.util.Random) ，而不是相对路径 (如：util.Random)。 此外，导入语句按照以下顺序排序： java.* 和 javax.* scala.* 第三方库 (org.*, com.*, 等) 项目中的类 (对于 Spark 项目，即 com.databricks.* 或 org.apache.spark) 在每一组导入语句内，按照字母序进行排序。 你可以使用 IntelliJ 的「import organizer」来自动处理，请使用以下配置： 12345678javajavax_______ blank line _______scala_______ blank line _______all other imports_______ blank line _______com.databricks // or org.apache.spark if you are working on spark 模式匹配 如果整个方法就是一个模式匹配表达式，可能的话，可以把 match 关键词与方法声明放在同一行，以此减少一级缩进。 123def test(msg: Message): Unit = msg match &#123; case ...&#125; 当以闭包形式调用一个函数时，如果只有一个 case 语句，那么把 case 语句与函数调用放在同一行。 123list.zipWithIndex.map &#123; case (elem, i) =&gt; // ...&#125; 如果有多个 case 语句，把它们缩进并且包起来。 1234list.map &#123; case a: Foo =&gt; ... case b: Bar =&gt; ...&#125; 如果唯一的目的就是想匹配某个对象的类型，那么不要展开所有的参数来做模式匹配，这样会使得重构变得更加困难，代码更容易出错。 12345678910111213141516171819202122case class Pokemon(name: String, weight: Int, hp: Int, attack: Int, defense: Int)case class Human(name: String, hp: Int)// 不要像下面那样做，因为// 1. 当 pokemon 加入一个新的字段，我们需要改变下面的模式匹配代码// 2. 非常容易发生误匹配，尤其是当所有字段的类型都一样的时候targets.foreach &#123; case target @ Pokemon(_, _, hp, _, defense) =&gt; val loss = sys.min(0, myAttack - defense) target.copy(hp = hp - loss) case target @ Human(_, hp) =&gt; target.copy(hp = hp - myAttack)&#125;// 像下面这样做就好多了:targets.foreach &#123; case target: Pokemon =&gt; val loss = sys.min(0, myAttack - target.defense) target.copy(hp = target.hp - loss) case target: Human =&gt; target.copy(hp = target.hp - myAttack)&#125; 中缀方法避免中缀表示法，除非是符号方法（即运算符重载）。 12345678910// 正确list.map(func)string.contains(\"foo\")// 错误list map (func)string contains \"foo\"// 重载的运算符应该以中缀形式调用arrayBuffer += elem 匿名方法对于匿名方法，避免使用过多的小括号和花括号。 1234567891011121314151617181920// 正确list.map &#123; item =&gt; ...&#125;// 正确list.map(item =&gt; ...)// 错误list.map(item =&gt; &#123; ...&#125;)// 错误list.map &#123; item =&gt; &#123; ...&#125;&#125;// 错误list.map(&#123; item =&gt; ... &#125;) Scala 语言特性样例类与不可变性样例类（case class）本质也是普通的类，编译器会自动地为它加上以下支持： 构造器参数的公有 getter 方法 拷贝构造函数 构造器参数的模式匹配 默认的 toString/hash/equals 实现 对于样例类来说，构造器参数不应设为可变的，可以使用拷贝构造函数达到同样的效果。使用可变的样例类容易出错，例如，哈希表中，对象根据旧的哈希值被放在错误的位置上。 123456789// 这是 OK 的case class Person(name: String, age: Int)// 这是不 OK 的case class Person(name: String, var age: Int)// 通过拷贝构造函数创建一个新的实例来改变其中的值val p1 = Person(\"Peter\", 15)val p2 = p1.copy(age = 16) apply 方法避免在类里定义 apply 方法。这些方法往往会使代码的可读性变差，尤其是对于不熟悉 Scala 的人。它也难以被 IDE（或 grep）所跟踪。在最坏的情况下，它还可能影响代码的正确性，正如你在括号一节中看到的。 然而，将 apply 方法作为工厂方法定义在伴生对象中是可以接受的。在这种情况下，apply 方法应该返回其伴生类的类型。 1234567object TreeNode &#123; // 下面这种定义是 OK 的 def apply(name: String): TreeNode = ... // 不要像下面那样定义，因为它没有返回其伴生类的类型：TreeNode def apply(name: String): String = ...&#125; override 修饰符无论是覆盖具体的方法还是实现抽象的方法，始终都为方法加上 override 修饰符。实现抽象方法时，不加 override 修饰符，Scala 编译器也不会报错。即便如此，我们也应该始终把 override 修饰符加上，以此显式地表示覆盖行为。以此避免由于方法签名不同（而你也难以发现）而导致没有覆盖到本应覆盖的方法。 12345678910111213141516trait Parent &#123; def hello(data: Map[String, String]): Unit = &#123; print(data) &#125;&#125;class Child extends Parent &#123; import scala.collection.Map // 下面的方法没有覆盖 Parent.hello, // 因为两个 Map 的类型是不同的。 // 如果我们加上 override 修饰符，编译器就会帮你找出问题并报错。 def hello(data: Map[String, String]): Unit = &#123; print(\"This is supposed to override the parent method, but it is actually not!\") &#125;&#125; 解构绑定解构绑定（有时也叫元组提取）是一种在一个表达式中为两个变量赋值的便捷方式。 1val (a, b) = (1, 2) 然而，请不要在构造函数中使用它们，尤其是当 a 和 b 需要被标记为 transient 的时候。Scala 编译器会产生一个额外的 Tuple2 字段，而它并不是暂态的（transient）。 1234class MyClass &#123; // 以下代码无法 work，因为编译器会产生一个非暂态的 Tuple2 指向 a 和 b @transient private val (a, b) = someFuncThatReturnsTuple2()&#125; 按名称传参避免使用按名传参. 显式地使用 () =&gt; T 。 背景：Scala 允许按名称来定义方法参数，例如：以下例子是可以成功执行的： 123456789101112def print(value: =&gt; Int): Unit = &#123; println(value) println(value + 1)&#125;var a = 0def inc(): Int = &#123; a += 1 a&#125;print(inc()) 在上面的代码中，inc() 以闭包的形式传递给 print 函数，并且在 print 函数中被执行了两次，而不是以数值 1 传入。按名传参的一个主要问题是在方法调用处，我们无法区分是按名传参还是按值传参。因此无法确切地知道这个表达式是否会被执行（更糟糕的是它可能会被执行多次）。对于带有副作用的表达式来说，这一点是非常危险的。 多参数列表避免使用多参数列表。它们使运算符重载变得复杂，并且会使不熟悉 Scala 的程序员感到困惑。例如： 12// 避免出现下面的写法！case class Person(name: String, age: Int)(secret: String) 一个值得注意的例外是，当在定义底层库时，可以使用第二个参数列表来存放隐式（implicit）参数。尽管如此，我们应该避免使用 implicits！ 符号方法（运算符重载）不要使用符号作为方法名，除非你是在定义算术运算的方法（如：+, -, *, /），否则在任何其它情况下，都不要使用。符号化的方法名让人难以理解方法的意图是什么，来看下面两个例子： 1234567// 符号化的方法名难以理解channel ! msgstream1 &gt;&gt;= stream2// 下面的方法意图则不言而喻channel.send(msg)stream1.join(stream2) 类型推导Scala 的类型推导，尤其是左侧类型推导以及闭包推导，可以使代码变得更加简洁。尽管如此，也有一些情况我们是需要显式地声明类型的： 公有方法应该显式地声明类型，编译器推导出来的类型往往会使你大吃一惊。 隐式方法应该显式地声明类型，否则在增量编译时，它会使 Scala 编译器崩溃。 如果变量或闭包的类型并非显而易见，请显式声明类型。一个不错的判断准则是，如果评审代码的人无法在 3 秒内确定相应实体的类型，那么你就应该显式地声明类型。 Return 语句闭包中避免使用 return。return 会被编译器转成 scala.runtime.NonLocalReturnControl 异常的 try/catch 语句，这可能会导致意外行为。请看下面的例子： 1234567def receive(rpc: WebSocketRPC): Option[Response] = &#123; tableFut.onComplete &#123; table =&gt; if (table.isFailure) &#123; return None // 不要这样做！ &#125; else &#123; ... &#125; &#125;&#125; .onComplete 方法接收一个匿名闭包并把它传递到一个不同的线程中。这个闭包最终会抛出一个 NonLocalReturnControl 异常，并在 一个不同的线程中被捕获，而这里执行的方法却没有任何影响。 然而，也有少数情况我们是推荐使用 return 的。 使用 return 来简化控制流，避免增加一级缩进。 123456def doSomething(obj: Any): Any = &#123; if (obj eq null) &#123; return null &#125; // do something ...&#125; 使用 return 来提前终止循环，这样就不用额外构造状态标志。 12345while (true) &#123; if (cond) &#123; return &#125;&#125; 递归及尾递归避免使用递归，除非问题可以非常自然地用递归来描述（比如，图和树的遍历）。 对于那些你意欲使之成为尾递归的方法，请加上 @tailrec 注解以确保编译器去检查它是否真的是尾递归（你会非常惊讶地看到，由于使用了闭包和函数变换，许多看似尾递归的代码事实并非尾递归）。 大多数的代码使用简单的循环和状态机会更容易推理，使用尾递归反而可能会使它更加繁琐且难以理解。例如，下面的例子中，命令式的代码比尾递归版本的代码要更加易读： 1234567891011121314151617181920212223// Tail recursive version.def max(data: Array[Int]): Int = &#123; @tailrec def max0(data: Array[Int], pos: Int, max: Int): Int = &#123; if (pos == data.length) &#123; max &#125; else &#123; max0(data, pos + 1, if (data(pos) &gt; max) data(pos) else max) &#125; &#125; max0(data, 0, Int.MinValue)&#125;// Explicit loop versiondef max(data: Array[Int]): Int = &#123; var max = Int.MinValue for (v &lt;- data) &#123; if (v &gt; max) &#123; max = v &#125; &#125; max&#125; Implicits避免使用 implicit，除非： 你在构建领域特定的语言（DSL） 你在隐式类型参数中使用它（如：ClassTag，TypeTag） 你在你自己的类中使用它（意指不要污染外部空间），以此减少类型转换的冗余度（如：Scala 闭包到 Java 闭包的转换）。 当使用 implicit 时，我们应该确保另一个工程师可以直接理解使用语义，而无需去阅读隐式定义本身。Implicit 有着非常复杂的解析规则，这会使代码变得极其难以理解。Twitter 的 Effective Scala 指南中写道：「如果你发现你在使用 implicit，始终停下来问一下你自己，是否可以在不使用 implicit 的条件下达到相同的效果」。 如果你必需使用它们（比如：丰富 DSL），那么不要重载隐式方法，即确保每个隐式方法有着不同的名字，这样使用者就可以选择性地导入它们。 1234567891011// 别这么做，这样使用者无法选择性地只导入其中一个方法。object ImplicitHolder &#123; def toRdd(seq: Seq[Int]): RDD[Int] = ... def toRdd(seq: Seq[Long]): RDD[Long] = ...&#125;// 应该将它们定义为不同的名字：object ImplicitHolder &#123; def intSeqToRdd(seq: Seq[Int]): RDD[Int] = ... def longSeqToRdd(seq: Seq[Long]): RDD[Long] = ...&#125; 符号文本避免使用符号文本。在 Scala 2.13 中，符号文本（如：&#39;column）已根据 关于弃用和删除符号文字的建议 弃用. Apache Spark 曾经利用符号文本来实现其 DSL，但是目前它已经开始移除这项弃用的特性。参见：SPARK-29392。 异常处理 (Try 还是 try) 不要捕获 Throwable 或 Exception 类型的异常。请使用 scala.util.control.NonFatal： 12345678try &#123; ...&#125; catch &#123; case NonFatal(e) =&gt; // 异常处理；注意 NonFatal 无法匹配 InterruptedException 类型的异常 case e: InterruptedException =&gt; // 处理 InterruptedException&#125; 这能保证我们不会去捕获 NonLocalReturnControl 异常（正如在Return 语句中所解释的）。 不要在 API 中使用 Try，即，不要在任何方法中返回 Try。对于异常执行，请显式地抛出异常，并使用 Java 风格的 try/catch 做异常处理。 背景资料：Scala 提供了单子（monadic）错误处理（通过 Try，Success 和 Failure），这样便于做链式处理。然而，根据我们的经验，发现使用它通常会带来更多的嵌套层级，使得代码难以阅读。此外，对于预期错误还是异常，在语义上常常是不明晰的。因此，我们不鼓励使用 Try 来做错误处理，尤其是以下情况： 一个人为的例子： 1234class UserService &#123; /** 在用户数据库中查找用户信息。 */ def get(userId: Int): Try[User]&#125; 以下的写法会更好： 123456789class UserService &#123; /** * 在用户数据库中查找用户信息。 * @return None 如果查找不到用户 * @throws DatabaseConnectionException 当连接数据库发生异常时 */ @throws(DatabaseConnectionException) def get(userId: Int): Option[User]&#125; 第二种写法非常明显地能让调用者知道需要处理哪些错误情况。 Options 如果一个值可能为空，那么请使用 Option。相对于 null，Option 显式地表明了一个 API 的返回值可能为空。 构造 Option 值时，请使用 Option 而非 Some，以防那个值为 null。 12345def myMethod1(input: String): Option[String] = Option(transform(input))// This is not as robust because transform can return null, and then// myMethod2 will return Some(null).def myMethod2(input: String): Option[String] = Some(transform(input)) 不要使用 None 来表示异常，有异常时请显式抛出。 不要在一个 Option 值上直接调用 get 方法，除非你百分百确定那个 Option 值不是 None。 单子链接单子链接是 Scala 的一个强大特性。Scala 中几乎一切都是单子（如：集合，Option，Future，Try 等），对它们的操作可以链接在一起。这是一个非常强大的概念，但你应该谨慎使用，尤其是： 避免链接（或嵌套）超过 3 个操作。 如果需要花超过 5 秒钟来理解其中的逻辑，那么你应该尽量去想想有没什么办法在不使用单子链接的条件下来达到相同的效果。一般来说，你需要注意的是：不要滥用 flatMap 和 fold。 链接应该在 flatMap 之后断开（因为类型发生了变化）。 通过给中间结果显式地赋予一个变量名，将链接断开变成一种更加过程化的风格，能让单子链接更加易于理解。来看下面的例子： 123456789101112131415161718192021222324class Person(val data: Map[String, String])val database = Map[String, Person]// 有时客户端会给 address 赋予一个 null 值，因此下面的代码用了 Option.apply 来处理这种情况// A monadic chaining approachdef getAddress(name: String): Option[String] = &#123; database.get(name).flatMap &#123; elem =&gt; elem.data.get(\"address\") .flatMap(Option.apply) // 处理 null 值 &#125;&#125;// 尽管代码会长一些，但以下方法可读性更高def getAddress(name: String): Option[String] = &#123; if (!database.contains(name)) &#123; return None &#125; database(name).data.get(\"address\") match &#123; case Some(null) =&gt; None // handle null value case Some(addr) =&gt; Option(addr) case None =&gt; None &#125;&#125; 并发Scala concurrent.Map优先考虑使用 java.util.concurrent.ConcurrentHashMap 而非 scala.collection.concurrent.Map。尤其是 scala.collection.concurrent.Map 中的 getOrElseUpdate 方法要慎用，它并非原子操作（这个问题在 Scala 2.11.16 中 fix 了：SI-7943）。由于我们做的所有项目都需要在 Scala 2.10 和 Scala 2.11 上使用，因此要避免使用 scala.collection.concurrent.Map。 显式同步 vs 并发集合有 3 种推荐的方法来安全地并发访问共享状态。不要混用它们，因为这会使程序变得难以推理，并且可能导致死锁。 java.util.concurrent.ConcurrentHashMap：当所有的状态都存储在一个 map 中，并且有高程度的竞争时使用。 1private[this] val map = new java.util.concurrent.ConcurrentHashMap[String, String] java.util.Collections.synchronizedMap：使用情景：当所有状态都存储在一个 map 中，并且预期不存在竞争情况，但你仍想确保代码在并发下是安全的。如果没有竞争出现，JVM 的 JIT 编译器能够通过偏置锁（biased locking）移除同步开销。 1private[this] val map = java.util.Collections.synchronizedMap(new java.util.HashMap[String, String]) 通过同步所有临界区进行显式同步，可用于监视多个变量。与 2 相似，JVM 的 JIT 编译器能够通过偏置锁（biased locking）移除同步开销。 123456789class Manager &#123; private[this] var count = 0 private[this] val map = new java.util.HashMap[String, String] def update(key: String, value: String): Unit = synchronized &#123; map.put(key, value) count += 1 &#125; def getCount: Int = synchronized &#123; count &#125;&#125; 注意，对于 case 1 和 case 2，不要让集合的视图或迭代器从保护区域逃逸。这可能会以一种不明显的方式发生，比如：返回了 Map.keySet 或 Map.values。如果需要传递集合的视图或值，生成一份数据拷贝再传递。 1234567val map = java.util.Collections.synchronizedMap(new java.util.HashMap[String, String])// 这是有问题的！def values: Iterable[String] = map.values// 应用使用下面的写法，把元素拷贝一份。def values: Iterable[String] = map.synchronized &#123; Seq(map.values: _*) &#125; 显式同步 vs 原子变量 vs @volatilejava.util.concurrent.atomic 包提供了对基本类型的无锁访问，比如：AtomicBoolean, AtomicInteger 和 AtomicReference。 始终优先考虑使用原子变量而非 @volatile，它们是相关功能的严格超集并且从代码上看更加明显。原子变量的底层实现使用了 @volatile。 优先考虑使用原子变量而非显式同步的情况：（1）一个对象的所有临界区更新都被限制在单个变量里并且预期会有竞争情况出现。原子变量是无锁的并且允许更为有效的竞争。（2）同步被明确地表示为 getAndSet 操作。例如： 123456789101112131415161718// good: 明确又有效地表达了下面的并发代码只执行一次val initialized = new AtomicBoolean(false)...if (!initialized.getAndSet(true)) &#123; ...&#125;// poor: 下面的同步就没那么明晰，而且会出现不必要的同步val initialized = false...var wasInitialized = falsesynchronized &#123; wasInitialized = initialized initialized = true&#125;if (!wasInitialized) &#123; ...&#125; 私有字段注意，private 字段仍然可以被相同类的其它实例所访问，所以仅仅通过 this.synchronized（或 synchronized）来保护它从技术上来说是不够的，不过你可以通过 private[this] 修饰私有字段来达到目的。 1234567891011// 以下代码仍然是不安全的。class Foo &#123; private var count: Int = 0 def inc(): Unit = synchronized &#123; count += 1 &#125;&#125;// 以下代码是安全的。class Foo &#123; private[this] var count: Int = 0 def inc(): Unit = synchronized &#123; count += 1 &#125;&#125; 隔离一般来说，并发和同步逻辑应该尽可能地被隔离和包含起来。这实际上意味着： 避免在 API 层面、面向用户的方法以及回调中暴露同步原语。 对于复杂模块，创建一个小的内部模块来包含并发原语。 性能对于你写的绝大多数代码，性能都不应该成为一个问题。然而，对于一些性能敏感的代码，以下有一些小建议： Microbenchmarks由于 Scala 编译器和 JVM JIT 编译器会对你的代码做许多神奇的事情，因此要写出一个好的微基准程序（microbenchmark）是极其困难的。更多的情况往往是你的微基准程序并没有测量你想要测量的东西。 如果你要写一个微基准程序，请使用 jmh。请确保你阅读了所有的样例，这样你才理解微基准程序中「死代码」移除、常量折叠以及循环展开的效果。 Traversal 与 zipWithIndex使用 while 循环而非 for 循环或函数变换（如：map、foreach），for 循环和函数变换非常慢（由于虚函数调用和装箱的缘故）。 123456789101112131415val arr = // array of ints// 偶数位置的数置零val newArr = list.zipWithIndex.map &#123; case (elem, i) =&gt; if (i % 2 == 0) 0 else elem&#125;// 这是上面代码的高性能版本val newArr = new Array[Int](arr.length)var i = 0val len = newArr.lengthwhile (i &lt; len) &#123; newArr(i) = if (i % 2 == 0) 0 else arr(i) i += 1&#125; Option 与 null对于性能有要求的代码，优先考虑使用 null 而不是 Option，以此避免虚函数调用以及装箱操作。用 Nullable 注解明确标示出可能为 null 的值。 1234class Foo &#123; @javax.annotation.Nullable private[this] var nullableField: Bar = _&#125; Scala 集合库对于性能有要求的代码，优先考虑使用 Java 集合库而非 Scala 集合库，因为一般来说，Scala 集合库要比 Java 的集合库慢。 private[this]对于性能有要求的代码，优先考虑使用 private[this] 而非 private。private[this] 生成一个字段而非生成一个访问方法。根据我们的经验，JVM JIT 编译器并不总是会内联 private 字段的访问方法，因此通过使用private[this] 来确保没有虚函数调用会更保险。 12345678910111213class MyClass &#123; private val field1 = ... private[this] val field2 = ... def perfSensitiveMethod(): Unit = &#123; var i = 0 while (i &lt; 1000000) &#123; field1 // This might invoke a virtual method call field2 // This is just a field access i += 1 &#125; &#125;&#125; 与 Java 的互操作性本节内容介绍的是构建 Java 兼容 API 的准则。如果你构建的组件并不需要与 Java 有交互，那么请无视这一节。这一节的内容主要是从我们开发 Spark 的 Java API 的经历中得出的。 Scala 中缺失的 Java 特性以下的 Java 特性在 Scala 中是没有的，如果你需要使用以下特性，请在 Java 中定义它们。然而，需要提醒一点的是，你无法为 Java 源文件生成 ScalaDoc。 静态字段 静态内部类 Java 枚举 注解 Traits 与抽象类对于允许从外部实现的接口，请记住以下几点： 包含了默认方法实现的 trait 是无法在 Java 中使用的，请使用抽象类来代替。 一般情况下，请避免使用 trait，除非你百分百确定这个接口即使在未来也不会有默认的方法实现。 123456789// 以下默认实现无法在 Java 中使用trait Listener &#123; def onTermination(): Unit = &#123; ... &#125;&#125;// 可以在 Java 中使用abstract class Listener &#123; def onTermination(): Unit = &#123; ... &#125;&#125; 类型别名不要使用类型别名，它们在字节码和 Java 中是不可见的。 默认参数值不要使用默认参数值，通过重载方法来代替。 123456// 打破了与 Java 的互操作性def sample(ratio: Double, withReplacement: Boolean = false): RDD[T] = &#123; ... &#125;// 以下方法是 work 的def sample(ratio: Double, withReplacement: Boolean): RDD[T] = &#123; ... &#125;def sample(ratio: Double): RDD[T] = sample(ratio, withReplacement = false) 多参数列表不要使用多参数列表。 可变参数 为可变参数方法添加 `@scala.annotation.varargs` 注解，以确保它能在 Java 中使用。Scala 编译器会生成两个方法，一个给 Scala 使用（字节码参数是一个 Seq），另一个给 Java 使用（字节码参数是一个数组）。 12@scala.annotation.varargsdef select(exprs: Expression*): DataFrame = &#123; ... &#125; 需要注意的一点是，由于 Scala 编译器的一个 bug（SI-1459，SI-9013），抽象的变参方法是无法在 Java 中使用的。 重载变参方法时要小心，用另一个类型去重载变参方法会破坏源码的兼容性。 1234567891011class Database &#123; @scala.annotation.varargs def remove(elems: String*): Unit = ... // 当调用无参的 remove 方法时会出问题。 @scala.annotation.varargs def remove(elems: People*): Unit = ...&#125;// remove 方法有歧义，因此编译不过。new Database().remove() 一种解决方法是，在可变参数前显式地定义第一个参数： 12345678class Database &#123; @scala.annotation.varargs def remove(elems: String*): Unit = ... // 以下重载是 OK 的。 @scala.annotation.varargs def remove(elem: People, elems: People*): Unit = ...&#125; Implicits不要为类或方法使用 implicit，包括了不要使用 ClassTag 和 TypeTag。 1234class JavaFriendlyAPI &#123; // 以下定义对 Java 是不友好的，因为方法中包含了一个隐式参数（ClassTag）。 def convertTo[T: ClassTag](): T&#125; 伴生对象，静态方法与字段当涉及到伴生对象和静态方法/字段时，有几件事情是需要注意的： 伴生对象在 Java 中的使用是非常别扭的（伴生对象 Foo 会被定义为 Foo$ 类内的一个类型为 Foo$ 的静态字段 MODULE$）。 123456object Foo// 等价于以下的 Java 代码public class Foo$ &#123; Foo$ MODULE$ = // 对象的实例化&#125; 如果非要使用伴生对象，可以在一个单独的类中创建一个 Java 静态字段。 不幸的是，没有办法在 Scala 中定义一个 JVM 静态字段。请创建一个 Java 文件来定义它。 伴生对象里的方法会被自动转成伴生类里的静态方法，除非方法名有冲突。确保静态方法正确生成的最好方式是用 Java 写一个测试文件，然后调用生成的静态方法。 12345678910111213141516class Foo &#123; def method2(): Unit = &#123; ... &#125;&#125;object Foo &#123; def method1(): Unit = &#123; ... &#125; // 静态方法 Foo.method1 会被创建（字节码） def method2(): Unit = &#123; ... &#125; // 静态方法 Foo.method2 不会被创建&#125;// FooJavaTest.java (in test/scala/com/databricks/...)public class FooJavaTest &#123; public static void compileTest() &#123; Foo.method1(); // 正常编译 Foo.method2(); // 编译失败，因为 method2 并没有生成 &#125;&#125; 样例对象（case object） MyClass 的类型并不是 MyClass。 123456case object MyClass// Test.javaif (MyClass$.MODULE instanceof MyClass) &#123; // 上述条件始终为 false&#125; 要实现正确的类型层级结构，请定义一个伴生类，然后用一个样例对象去继承它： 12class MyClasscase object MyClass extends MyClass 测试异常拦截当测试某个操作（比如用无效的参数调用一个函数）是否会抛出异常时，对于抛出的异常类型指定得越具体越好。你不应该简单地使用 intercept[Exception] 或 intercept[Throwable]（ScalaTest 语法），这能拦截任意异常，只能断言有异常抛出，而不能确定是什么异常。这样做在测试中能捕获到代码中的异常并且通过测试，然而却没真正检验你想验证的行为。 123456789// 不要使用下面这种方式intercept[Exception] &#123; thingThatThrowsException()&#125;// 这才是推荐的做法intercept[MySpecificTypeOfException] &#123; thingThatThrowsException()&#125; 如果你无法指定代码会抛出的异常的具体类型，说明你这段代码可能写得不好，需要重构。这种情况下，你要么测试更底层的代码，要么改写代码令其抛出类型更加具体的异常。 其它优先使用 nanoTime 而非 currentTimeMillis当要计算持续时间或者检查超时的时候，避免使用 System.currentTimeMillis()。请使用 System.nanoTime()，即使你对亚毫秒级的精度并不感兴趣。 System.currentTimeMillis() 返回的是当前的时钟时间，并且会跟进系统时钟的改变。因此，负的时钟调整可能会导致超时而挂起很长一段时间（直到时钟时间赶上先前的值）。这种情况可能发生在网络已经中断一段时间，ntpd 走过了一步之后。最典型的例子是，在系统启动的过程中，DHCP 花费的时间要比平常的长。这可能会导致非常难以理解且难以重现的问题。而 System.nanoTime() 则可以保证是单调递增的，与时钟变化无关。 注意事项： 永远不要序列化一个绝对的 nanoTime() 值或是把它传递给另一个系统。绝对的 nanoTime() 值是无意义的、与系统相关的，并且在系统重启时会重置。 绝对的 nanoTime() 值并不保证总是正数（但 t2 - t1 能确保总是产生正确的值）。 nanoTime() 每 292 年就会重新计算起。所以，如果你的 Spark 任务需要花非常非常非常长的时间，你可能需要别的东西来处理了：） 优先使用 URI 而非 URL当存储服务的 URL 时，你应当使用 URI 来表示。 URL 的相等性检查)实际上执行了一次网络调用（这是阻塞的）来解析 IP 地址。URI 类在表示能力上是 URL 的超集，并且它执行的是字段的相等性检查。 优先使用现存的经过良好测试的方法而非重新发明轮子当存在一个已经经过良好测试的方法，并且不会存在性能问题，那么优先使用这个方法。重新实现它可能会引入Bug，同时也需要花费时间来进行测试（也可能我们甚至忘记去测试这个方法！）。 123456789101112131415val beginNs = System.nanoTime()// Do somethingThread.sleep(1000)val elapsedNs = System.nanoTime() - beginNs// 不要使用下面这种方式。这种方法容易出错val elapsedMs = elapsedNs / 1000 / 1000// 推荐方法：使用Java TimeUnit APIimport java.util.concurrent.TimeUnitval elapsedMs2 = TimeUnit.NANOSECONDS.toMillis(elapsedNs)// 推荐方法：使用Scala Duration APIimport scala.concurrent.duration._val elapsedMs3 = elapsedNs.nanos.toMillis 例外： 使用现存的方法需要引入新的依赖。如果一个方法特别简单，比起引入一个新依赖，重新实现它通常更好。但是记得进行测试。 现存的方法没有针对我们的用法进行优化，性能达不到要求。但是首先做一下benchmark, 避免过早优化。","raw":null,"content":null,"categories":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/categories/scala/"}],"tags":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/tags/scala/"}]},{"title":"Mac移除浏览器劫持AnySearch","slug":"Mac移除浏览器劫持AnySearch","date":"2020-04-26T13:49:41.000Z","updated":"2020-04-26T13:49:41.000Z","comments":true,"path":"2020/04/26/Mac移除浏览器劫持AnySearch/","link":"","permalink":"https://freehubs.github.io/2020/04/26/Mac移除浏览器劫持AnySearch/","excerpt":"","text":"操作 删除infosearch相关的文件。 12cd ~/Library/ApplicationSupportfind ./ -iname \"infosearch*\"","raw":null,"content":null,"categories":[{"name":"mac","slug":"mac","permalink":"https://freehubs.github.io/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://freehubs.github.io/tags/mac/"}]},{"title":"SPARK-SQL内置函数之字符串函数","slug":"SPARK-SQL内置函数之字符串函数","date":"2020-03-24T17:18:52.000Z","updated":"2020-03-24T17:18:52.000Z","comments":true,"path":"2020/03/24/SPARK-SQL内置函数之字符串函数/","link":"","permalink":"https://freehubs.github.io/2020/03/24/SPARK-SQL内置函数之字符串函数/","excerpt":"concat对于字符串进行拼接1234concat(str1, str2, ..., strN) - Returns the concatenation of str1, str2, ..., strN.Examples:`&gt; SELECT concat('Spark', 'SQL');　　SparkSQL\nconcat_ws在拼接的字符串中间添加某种格式1234concat_ws(sep, [str | array(str)]+) - Returns the concatenation of the strings separated by `sep`.Examples:`&gt; SELECT concat_ws(' ', 'Spark', 'SQL');　　Spark SQL","text":"concat对于字符串进行拼接1234concat(str1, str2, ..., strN) - Returns the concatenation of str1, str2, ..., strN.Examples:`&gt; SELECT concat('Spark', 'SQL'); SparkSQL concat_ws在拼接的字符串中间添加某种格式1234concat_ws(sep, [str | array(str)]+) - Returns the concatenation of the strings separated by `sep`.Examples:`&gt; SELECT concat_ws(' ', 'Spark', 'SQL'); Spark SQL decode转码1234decode(bin, charset) - Decodes the first argument using the second argument character set.Examples: `&gt; SELECT decode(encode('abc', 'utf-8'), 'utf-8');abc encode设置编码格式1234encode(str, charset) - Encodes the first argument using the second argument character set.Examples: `&gt; SELECT encode('abc', 'utf-8');abc format_string/printf 格式化字符串1234format_string(strfmt, obj, ...) - Returns a formatted string from printf-style format strings.Examples:`&gt; SELECT format_string(\"Hello World %d %s\", 100, \"days\");Hello World 100 days initcap将每个单词的首字母变为大写，其他字母小写; lower全部转为小写，upper大写1234initcap(str) - Returns `str` with the first letter of each word in uppercase. All other letters are in lowercase. Words are delimited by white space.Examples:`&gt; SELECT initcap('sPark sql');Spark Sql length返回字符串的长度12Examples:`&gt; SELECT length('Spark SQL ');10 levenshtein编辑距离（将一个字符串变为另一个字符串的距离）1234levenshtein(str1, str2) - Returns the Levenshtein distance between the two given strings.Examples:`&gt; SELECT levenshtein('kitten', 'sitting');3 lpad返回固定长度的字符串，如果长度不够，用某种字符补全，rpad右补全1234lpad(str, len, pad) - Returns `str`, left-padded with `pad` to a length of `len`. If `str` is longer than `len`, the return value is shortened to `len` characters.Examples:`&gt; SELECT lpad('hi', 5, '??');???hi ltrim去除空格或去除开头的某些字符,rtrim右去除，trim两边同时去除12345678910ltrim(str) - Removes the leading space characters from `str`.ltrim(trimStr, str) - Removes the leading string contains the characters from the trim stringExamples:&gt; SELECT ltrim(' SparkSQL '); SparkSQL&gt; SELECT ltrim('Sp', 'SSparkSQLS'); arkSQLS regexp_extract 正则提取某些字符串，regexp_replace正则替换1234567Examples:`&gt; SELECT regexp_extract('100-200', '(\\d+)-(\\d+)', 1); 100Examples: `&gt; SELECT regexp_replace('100-200', '(\\d+)', 'num'); num-numExamples: `&gt; SELECT regexp_replace(regexp_replace(regexp_replace(\"json_arr\",\"\\\"\\\\[\",\"\\\\[\"),\"\\\\]\\\"\",\"\\\\]\"),\"\\\\\\\\\",\"\") repeat复制给的字符串n次12Examples: `&gt; SELECT repeat('123', 2); 123123 instr返回截取字符串的位置/locate1234567instr(str, substr) - Returns the (1-based) index of the first occurrence of `substr` in `str`.Examples:`&gt; SELECT instr('SparkSQL', 'SQL'); 6Examples:`&gt; SELECT locate('bar', 'foobarbar'); 4 space 在字符串前面加n个空格1234space(n) - Returns a string consisting of `n` spaces.Examples:`&gt; SELECT concat(space(2), '1'); 1 split以某些字符拆分字符串1234split(str, regex) - Splits `str` around occurrences that match `regex`.Examples:`&gt; SELECT split('oneAtwoBthreeC', '[ABC]'); ``[\"one\",\"two\",\"three\",\"\"] substr截取字符串，substring_indexExamples: 12345678&gt; SELECT substr('Spark SQL', 5); k SQL&gt; SELECT substr('Spark SQL', -3); SQL&gt; SELECT substr('Spark SQL', 5, 1); k&gt; SELECT substring_index('www.apache.org', '.', 2); www.apache translate 替换某些字符串为12Examples: `&gt; SELECT translate('AaBbCc', 'abc', '123'); A1B2C3 get_json_object1234get_json_object(json_txt, path) - Extracts a json object from `path`.Examples:`&gt; SELECT get_json_object('&#123;\"a\":\"b\"&#125;', '$.a'); b unhex1234unhex(expr) - Converts hexadecimal `expr` to binary.Examples:`&gt; SELECT decode(unhex('537061726B2053514C'), 'UTF-8'); Spark SQL to_jsonto_json(expr[, options]) - Returns a json string with a given struct value Examples: 1234567891011121314151617181920&gt; SELECT to_json(named_struct('a', 1, 'b', 2)); &#123;\"a\":1,\"b\":2&#125;&gt; SELECT to_json(named_struct('time', to_timestamp('2015-08-26', 'yyyy-MM-dd')), map('timestampFormat', 'dd/MM/yyyy')); &#123;\"time\":\"26/08/2015\"&#125;&gt; SELECT to_json(array(named_struct('a', 1, 'b', 2));[&#123;\"a\":1,\"b\":2&#125;]&gt; SELECT to_json(map('a', named_struct('b', 1))); &#123;\"a\":&#123;\"b\":1&#125;&#125;&gt; SELECT to_json(map(named_struct('a', 1),named_struct('b', 2))); &#123;\"[1]\":&#123;\"b\":2&#125;&#125;&gt; SELECT to_json(map('a', 1)); &#123;\"a\":1&#125;&gt; SELECT to_json(array((map('a', 1)))); [&#123;\"a\":1&#125;]","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"}]},{"title":"zeppelin文档","slug":"zeppelin文档","date":"2020-03-19T17:38:55.000Z","updated":"2020-03-19T17:38:55.000Z","comments":true,"path":"2020/03/19/zeppelin文档/","link":"","permalink":"https://freehubs.github.io/2020/03/19/zeppelin文档/","excerpt":"\n            简介\n          \n这里写一些zeppelin的简介。\n\n            安装问题\n          \nJar包冲突问题描述主要问题：Zeppelin中的Jar包与Spark中的Jar包版本不一致。\n解决方法将Zeppelin中的冲突Jar包删除，拷贝Spark中的对应Jar包。\n\nnetty\njackson\nlib （libfb303，libthrift。。）\n","text":"简介 这里写一些zeppelin的简介。 安装问题 Jar包冲突问题描述主要问题：Zeppelin中的Jar包与Spark中的Jar包版本不一致。 解决方法将Zeppelin中的冲突Jar包删除，拷贝Spark中的对应Jar包。 netty jackson lib （libfb303，libthrift。。） 插件 hive插件在 JDBC 插件中设置，默认的 JDBC 连接设置为Hive的连接信息即可。 spark插件","raw":null,"content":null,"categories":[{"name":"zeppelin","slug":"zeppelin","permalink":"https://freehubs.github.io/categories/zeppelin/"}],"tags":[{"name":"ambari","slug":"ambari","permalink":"https://freehubs.github.io/tags/ambari/"},{"name":"zeppelin","slug":"zeppelin","permalink":"https://freehubs.github.io/tags/zeppelin/"}]},{"title":"Hexo Next主题图标显示为方块的解决方法","slug":"Hexo-Next主题图标显示为方块的解决方法","date":"2020-03-19T09:58:46.000Z","updated":"2020-03-19T09:58:46.000Z","comments":true,"path":"2020/03/19/Hexo-Next主题图标显示为方块的解决方法/","link":"","permalink":"https://freehubs.github.io/2020/03/19/Hexo-Next主题图标显示为方块的解决方法/","excerpt":"\n            现象\n          \n所有的图标都无法正常展示，都显示为方块。\n","text":"现象 所有的图标都无法正常展示，都显示为方块。 解决方法 添加CDN加载路径。 在next主题的配置文件_config.yml中修改： 1234# Internal version: 4.7.0# fontawesome: //cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css# fontawesome: //cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.cssfontawesome: //stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css","raw":null,"content":null,"categories":[{"name":"blog","slug":"blog","permalink":"https://freehubs.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://freehubs.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://freehubs.github.io/tags/blog/"},{"name":"next","slug":"next","permalink":"https://freehubs.github.io/tags/next/"}]},{"title":"ranger-spark插件部署","slug":"ranger-spark插件部署","date":"2020-03-17T15:00:57.000Z","updated":"2020-03-17T15:00:57.000Z","comments":true,"path":"2020/03/17/ranger-spark插件部署/","link":"","permalink":"https://freehubs.github.io/2020/03/17/ranger-spark插件部署/","excerpt":"参考12https://github.com/yaooqinn/spark-authorizerhttp://dl.bintray.com/spark-packages/maven/yaooqinn/spark-authorizer\n部署Jar将下面的包添加到$SPARK_HOME/jar中，切记千万要注意ranger-jars版本，最好是按照下图中的版本：\n","text":"参考12https://github.com/yaooqinn/spark-authorizerhttp://dl.bintray.com/spark-packages/maven/yaooqinn/spark-authorizer 部署Jar将下面的包添加到$SPARK_HOME/jar中，切记千万要注意ranger-jars版本，最好是按照下图中的版本： 123456789101112131415161718192021eclipselink-2.5.2.jargson-2.2.4.jarhttpclient-4.5.1.jarhttpcore-4.4.4.jarhttpmime-4.5.2.jarjavax.persistence-2.1.0.jarjersey-bundle-1.4.jarjersey-client-2.22.2.jarjersey-common-2.22.2.jarjersey-container-servlet-2.22.2.jarjersey-container-servlet-core-2.22.2.jarjersey-guava-2.22.2.jarjersey-media-jaxb-2.22.2.jarjersey-server-2.22.2.jarmybatis-3.2.8.jarmysql-connector-java.jarnoggit-0.6.jarranger-hive-plugin-0.5.3.jarranger-plugins-audit-0.5.3.jarranger-plugins-common-0.5.3.jarranger-plugins-cred-0.5.3.jar 部署配置文件 将/etc/hive/2.6.5.0-292/0/conf.server中的ranger相关的配置文件拷贝到 SPARK_HOME/conf中,可以执行：find / -name xxx.xml 来找到； 1234ranger-hive-audit.xmlranger-hive-security.xmlranger-policymgr-ssl.xmlranger-security.xml 并在ambari界面：spark配置中心：hive-site.xml中添加以下配置： 12345678910111213141516171819&lt;property&gt; &lt;name&gt;hive.security.authorization.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hive.security.authorization.manager&lt;/name&gt; &lt;value&gt;org.apache.ranger.authorization.hive.authorizer.RangerHiveAuthorizerFactory&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hive.security.authenticator.manager&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hive.ql.security.SessionStateUserAuthenticator&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hive.conf.restricted.list&lt;/name&gt; &lt;value&gt;hive.security.authorization.enabled,hive.security.authorization.manager,hive.security.authenticator.manager&lt;/value&gt;&lt;/property&gt; spark-default.xml添加以下配置： 1spark.sql.extensions=org.apache.ranger.authorization.spark.authorizer.RangerSparkSQLExtension spark job中的配置需要在resource中添加： 123hive-site.xmlranger-hive-audit.xmlranger-hive-security.xml 需要在程序中指定配置： 12345SparkConf sparkConf = new SparkConf();sparkConf.set(\"spark.sql.extensions\", \"org.apache.ranger.authorization.spark.authorizer.RangerSparkSQLExtension\");//如果上面的resource中没有添加这些配置文件，则需要指定远程路径sparkConf.set(\"spark.yarn.dist.files\", \"hdfs://xxx/ranger-hive-audit.xml,hdfs://xxx/ranger-hive-security.xml\");","raw":null,"content":null,"categories":[{"name":"ambari","slug":"ambari","permalink":"https://freehubs.github.io/categories/ambari/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"},{"name":"ranger","slug":"ranger","permalink":"https://freehubs.github.io/tags/ranger/"}]},{"title":"ambari-ranger安装","slug":"ambari-ranger安装","date":"2020-03-17T14:46:17.000Z","updated":"2020-03-17T14:46:17.000Z","comments":true,"path":"2020/03/17/ambari-ranger安装/","link":"","permalink":"https://freehubs.github.io/2020/03/17/ambari-ranger安装/","excerpt":"安装按照ambari的操作一直点需要注意的是：选择ranger admin和ranger user服务的时候，需要安装在同一个节点，并且需要安装在ranger元数据的节点上。\n先创建ranger的数据库不要用utf8，会报错，用root用户：\n1234create database ranger CHARACTER SET = latin1; CREATE USER 'ranger'@'%'IDENTIFIED BY 'Ranger-2019';GRANT ALL PRIVILEGES ON *.* TO 'ranger'@'%';FLUSH PRIVILEGES;","text":"安装按照ambari的操作一直点需要注意的是：选择ranger admin和ranger user服务的时候，需要安装在同一个节点，并且需要安装在ranger元数据的节点上。 先创建ranger的数据库不要用utf8，会报错，用root用户： 1234create database ranger CHARACTER SET = latin1; CREATE USER 'ranger'@'%'IDENTIFIED BY 'Ranger-2019';GRANT ALL PRIVILEGES ON *.* TO 'ranger'@'%';FLUSH PRIVILEGES; 在启动ranger-admin服务前在mysql中开启如下设置：1SET GLOBAL log_bin_trust_function_creators = 1 可以在启动之后，关闭该设置： 1SET GLOBAL log_bin_trust_function_creators = 0 首先查看权限：1SELECT Host,User,Grant_priv,Super_priv FROM mysql.user; 打开没有开启的权限： 123UPDATE mysql.user SET Grant_priv='Y', Super_priv='Y' WHERE User='root';FLUSH PRIVILEGES; 修改缓存路径：ranger.plugin.hive.policy.cache.dir 问题处理[E] 007-updateBlankPolicyName.sql import failed!在启动ranger-admin服务前在mysql中开启如下设置： 1SET GLOBAL log_bin_trust_function_creators = 1 可以在启动之后，关闭该设置： 1SET GLOBAL log_bin_trust_function_creators = 0 [E] Granting privileges to ‘ranger’ failed on ‘ranger’首先查看权限： 1SELECT Host,User,Grant_priv,Super_priv FROM mysql.user; 打开没有开启的权限： 123UPDATE mysql.user SET Grant_priv='Y', Super_priv='Y' WHERE User='root';FLUSH PRIVILEGES;","raw":null,"content":null,"categories":[{"name":"ambari","slug":"ambari","permalink":"https://freehubs.github.io/categories/ambari/"}],"tags":[{"name":"ambari","slug":"ambari","permalink":"https://freehubs.github.io/tags/ambari/"},{"name":"ranger","slug":"ranger","permalink":"https://freehubs.github.io/tags/ranger/"}]},{"title":"scala代码格式化配置","slug":"scala代码格式化配置","date":"2020-03-16T23:12:24.000Z","updated":"2020-03-16T23:12:24.000Z","comments":true,"path":"2020/03/16/scala代码格式化配置/","link":"","permalink":"https://freehubs.github.io/2020/03/16/scala代码格式化配置/","excerpt":"","text":"IDEA配置 X-01 在IDEA中配置code formatter 为scalafmt X-02 编辑scalafmt.conf在项目的根目录下，新建.scalafmt.conf 文件，将格式化的相关配置写入文件中。比如： 12align = more // For pretty alignment.maxColumn = 130 // For my wide 30&quot; display. 更多配置见：https://scalameta.org/scalafmt/docs/configuration.html","raw":null,"content":null,"categories":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/categories/scala/"}],"tags":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/tags/scala/"}]},{"title":"scala代码规范","slug":"scala代码规范","date":"2020-03-04T18:11:01.000Z","updated":"2020-03-04T18:11:01.000Z","comments":true,"path":"2020/03/04/scala代码规范/","link":"","permalink":"https://freehubs.github.io/2020/03/04/scala代码规范/","excerpt":"\n            序言\n          \nScala是Twitter使用的主要应用编程语言之一。很多我们的基础架构都是用scala写的，我们也有一些大的库支持我们使用。虽然非常有效, Scala也是一门大的语言,经验教会我们在实践中要非常小心。 它有什么陷阱？哪些特性我们应该拥抱，哪些应该避开？我们什么时候采用“纯函数式风格”，什么时候应该避免？换句话说：哪些是我们发现的，可以高效地使用这门语言的地方？本指南试图把我们的经验提炼成短文，提供一系列最佳实践。我们使用scala主要创建一些大容量分布式系统服务——我们的建议也偏向于此——但这里的大多建议也应该自然的适用其他系统。这不是定律，但不当的使用应该被调整。","text":"序言 Scala是Twitter使用的主要应用编程语言之一。很多我们的基础架构都是用scala写的，我们也有一些大的库支持我们使用。虽然非常有效, Scala也是一门大的语言,经验教会我们在实践中要非常小心。 它有什么陷阱？哪些特性我们应该拥抱，哪些应该避开？我们什么时候采用“纯函数式风格”，什么时候应该避免？换句话说：哪些是我们发现的，可以高效地使用这门语言的地方？本指南试图把我们的经验提炼成短文，提供一系列最佳实践。我们使用scala主要创建一些大容量分布式系统服务——我们的建议也偏向于此——但这里的大多建议也应该自然的适用其他系统。这不是定律，但不当的使用应该被调整。 Scala提供很多工具使表达式可以很简洁。敲的少读的就少，读的少就能更快的读，因此简洁增强了代码的清晰。然而简洁也是一把钝器(blunt tool)也可能起到相反的效果：在考虑正确性之后，也要为读者着想。 首先，用Scala编程，你不是在写Java，Haskell或Python；Scala程序不像这其中的任何一种。为了高效的使用语言，你必须用其术语表达你的问题。 强制把Java程序转成Scala程序是无用的，因为大多数情况下它会不如原来的。 这不是对Scala的一篇介绍，我们假定读者熟悉这门语言。这儿有些学习Scala的资源： 这是一篇“活的”文档，我们会更新它,以反映我们当前的最佳实践，但核心的思想不太可能会变： 永远重视可读性；写泛化的代码但不要牺牲清晰度； 利用简单的语言特性的威力，但避免晦涩难懂（尤其是类型系统）。最重要的，总要意识到你所做的取舍。一门成熟的(sophisticated)语言需要复杂的实现，复杂性又产生了复杂性：之于推理，之于语义，之于特性之间的交互，以及与你合作者之间的理解。因此复杂性是为成熟所交的税——你必须确保效用超过它的成本。 玩的愉快。 格式化代码格式化的规范并不重要，只要它们实用。它的定义形式没有先天的好与坏，几乎每个人都有自己的偏好。然而，对于一贯地采用同一格式化规则的总会增加可读性。已经熟悉某种特定风格的读者不必非要去掌握另一套当地习惯，或译解另一个角落里的语言语法。 这对Scala来说也特别重要，因为它的语法高度的重叠。一个例子是方法调用：方法调用可以用“.”后边跟圆括号，或不使用“.”，后边用空格加不带圆括号(针对空元或一元方法)方式调用。此外，不同风格的方法调用揭露了它们在语法上不同的分歧(ambiguities)。当然一致的应用慎重的选择一组格式化规则，对人和机器来说都会消除大量的歧义。 我们依着Scala style guide 增加了以下规则： 空格用两个空格缩进。避免每行长度超过100列。在两个方法、类、对象定义之间使用一个空白行。 命名对作用域较短的变量使用短名字： is,js 和k`s等可出现在循环中。 对作用域较长的变量使用长名字： 外部APIs应该用长的，不需加以说明便可理解的名字。例如：Future.collect 而非 Future.all 使用通用的缩写，避开隐秘难懂的缩写： 例如每个人都知道 ok,err, defn等缩写的意思，而sfri是不常用的。 不要在不同用途时重用同样的名字： 使用val(注：Scala中的不可变类型) 避免用 `声明保留字变量： 用typ替代 type 用主动语态(active)来命名有副作用的操作： user.activate()而非 user.setActive() 对有返回值的方法使用具有描述性的名字： src.isDefined 而非src.defined getters不采用前缀get： 用get是多余的: site.count而非site.getCount 不必重复已经被package或object封装过的名字： 使用： 123object User &#123; def get(id: Int): Option[User]&#125; 而非： 123object User &#123; def getUser(id: Int): Option[User]&#125; 相比 get 方法 getUser 方法中的User是多余的，并不能提供额外的信息。 Imports对引入行按字母顺序排序： 这样机方便了视觉上的检查，也简化了自动操作。 当从一个包中引入多个时，用花括号： 1import com.twitter.concurrent.&#123;Broker, Offer&#125; 当引入超过6个时使用通配符： e.g.: import com.twitter.concurrent._ 不要轻率的使用: 一些包导入了太多的名字 当引入集合的时候，通过用import scala.collections.immutable(不可变集合)或scala.collections.mutable(可变集合)来限定名称 可变和不可变集合有相同的名字。限定名称让读者很明确知道使用的是哪个变量(e.g. “immutable.Map”) (译注，通常也会默认immutable，而在使用mutable时显示引入) 不要使用来自其它包的相对引用： 避免 12import com.twitterimport concurrent 而应该用清晰的： 1import com.twitter.concurrent (译注，实际上上面的import不能编译通过，第二个import应该为：import twitter.concurrent 即import一个包实际是定义了这个包的别名。) 将import放在文件的头部： 读者可以在一个地方参考所有的引用。 花括号花括号用于创建复合表达式，复合表达式的返回值是最后一个表达式。避免对简单的表达式采用花括号；写成： 1def square(x: Int) = x*x 而不是： 123def square(x: Int) = &#123; x * x &#125; 尽管第二种方式用在区分方法体的语句构成很诱人。第一种选择更加简洁，易读。避免语句上的繁文缛节，除非需要阐明。 模式匹配尽可能直接在函数定义的地方使用模式匹配。例如，下面的写法 match应该被折叠起来(collapse) 123456list map &#123; item =&gt; item match &#123; case Some(x) =&gt; x case None =&gt; default &#125; &#125; 用下面的写法替代： 1234list map &#123; case Some(x) =&gt; x case None =&gt; default &#125; 它很清晰的表达了 list中的元素都被映射，间接的方式让人不容易明白。 注释使用ScalaDoc提供API文档。用下面的风格： 1234/** * ServiceBuilder builds services * ... */ 而不是非标准的ScalaDoc风格： 123/** ServiceBuilder builds services * ... */ 不要诉诸于ASCII码艺术或其他可视化修饰。用文档记录APIs但不要添加不必要的注释。如果你发现你自己添加注释解释你的代码行为，先问问自己是否可以调整代码结构，从而可以明显地可以看出它做了什么。相对于“it works, obviously” 更偏向于“obviously it works” 类型和泛型类型系统的首要目的是检测程序错误。类型系统有效的提供了一个静态检测的有限形式，允许我们代码中明确某种类型的变量并且编译器可以验证。类型系统当然也提供了其他好处，但错误检测是他存在的理由(Raison d’Être) 我们使用类型系统应当反映这一目标，但我们必须考虑到读者（译注：读你代码的人）：明智地使用类型可以增加清晰度，而过份聪明只会迷乱。 Scala的强大类型系统是学术探索和实践共同来源(例如Type level programming in Scala) 。但这是一个迷人的学术话题，这些技术很少在应用和正式产品代码中使用。它们应该被避免。 返回类型注解(annotation)尽管Scala允许返回类型是可以省略的，加上它们提供了很好的文档：这对public方法特别重要。而当一个方法不需要对外暴露，并且它的返回值类型是显而易见的时候，则可以直接省略。 在使用混入(mixin)实例化对象时这一点尤其重要，Scala编译器为这些对象创造了单类。例如： 1234trait Service def make() = new Service &#123; def getId = 123 &#125; 上面的make不需要定义返回类型为Service；编译器会创建一个加工过的类型: Object with Service{def getId:Int}(译注:with是Scala里的mixin的语法)。若用一个显式的注释： 1def make(): Service = new Service&#123;&#125; 现在作者则不必改变make方法的公开类型而随意的混入(mix in) 更多的特质(traits)，使向后兼容很容易实现。 变型变型(Variance)发生在泛型与子类型化(subtyping)结合的时候。与容器类型的子类型化有关，它们定义了对所包含的类型如何子类型化。因为Scala有声明点变型(declaration site variance)注释（annotation），公共库的作者——特别是集合——必须有丰富的注释器。这些注释对共享代码的可用性很重要，但滥用也会很危险。 不可变(invariants)是Scala类型系统中高级部分，但也是必须的一面，因为它有助于子类型化的应用，应该广泛(并且正确)地使用。 不可变(Immutable)集合应该是协变的**(covariant)。接受容器化类型得方法应该适当地降级(downgrade)集合： 123trait Collection[+T] &#123; def add[U &gt;: T](other: U): Collection[U] &#125; 可变(mutable)集合应该是不可变的**(invariant). 协变对于可变集合是典型无效的。考虑： 123trait HashSet[+T] &#123; def add[U &gt;: T](item: U) &#125; 和下面的类型层级： 123trait Mammaltrait Dog extends Mammaltrait Cat extends Mammal 如果我现在有一个狗(dog)的 HashSet： 1val dogs: HashSetDog 把它作为一个哺乳动物的Set，增加一只猫(cat) 12val mammals: HashSetMammal = dogsmammals.add(new Cat&#123;&#125;) 这将不再是一个只存储狗(dog)的HashSet！ 类型别名类型别名应当在其提供了便捷的命名或阐明意图时使用，但对于自解释（不言自明）的类型不要使用类型别名。比如 () =&gt; Int 比下面定义的别名IntMarker更清晰 12type IntMaker = () =&gt; IntIntMaker 但，下面的别名: 12345class ConcurrentPool[K, V] &#123; type Queue = ConcurrentLinkedQueue[V] type Map = ConcurrentHashMap[K, Queue] ... &#125; 是有用的，因为它表达了目的并更加简短。 当使用类型别名的时候不要使用子类型化(subtyping) trait SocketFactory extends (SocketAddress =&gt; Socket) SocketFactory 是一个生产Socket的方法。使用一个类型别名更好： type SocketFactory = SocketAddress =&gt; Socket 我们现在可以对 SocketFactory类型的值 提供函数字面量(function literals) ,也可以使用函数组合： 1234val addrToInet: SocketAddress =&gt; Longval inetToSocket: Long =&gt; Socket val factory: SocketFactory = addrToInet andThen inetToSocket 类型别名通过用 package object 将名字绑定在顶层: 1234package com.twitterpackage object net &#123; type SocketFactory = (SocketAddress) =&gt; Socket&#125; 注意类型别名不是新类型——他们等价于在语法上用别名代替了原类型。 隐式转换隐式转换是类型系统里一个强大的功能，但应当谨慎地使用。它们有复杂的解决规则， 使得通过简单的词法检查领会实际发生了什么很困难。在下面的场景使用隐式转换是OK的： 扩展或增加一个Scala风格的集合 适配或扩展一个对象(pimp my library模式）（译注参见：http://www.artima.com/weblogs/viewpost.jsp?thread=179766) 通过提供约束证据来加强类型安全。 提供了类型的证据 (typeclassing，haskell中的概念，指定义一组函数，其实现因所给的数据类型不同而不同) 用于Manifests (注：Manifest[T]包含类型T的运行时信息) 如果你发现自己在用隐式转换，总要问问自己是否不使用这种方式也可以达到目的。 不要使用隐式转换对两个相似的数据类型做自动转换(例如，把list转换为stream);显示地做更好，因为不同类型有不同的语意，读者应该意识到这些含义。 译注： 1）一些单词的意义不同，但翻译为中文时可能用的相似的词语，比如mutable， Immutable 这两个翻译为可变和不可变，它们是指数据的可变与不可变。 variance, invariant 也翻译为 可变和不可变，（variance也翻译为“变型”），它们是指类型的可变与不可变。variance指支持协变或逆变的类型，invariant则相反。 集合Scala有一个非常通用，丰富，强大，可组合的集合库；集合是高阶的(high level)并暴露了一大套操作方法。很多集合的处理和转换可以被表达的简洁又可读，但不审慎地用它们的功能也会导致相反的结果。每个Scala程序员应该阅读 集合设计文档；通过它可以很好地洞察集合库，并了解设计动机。 总使用最简单的集合来满足你的需求 集合的使用优先使用不可变集合。不可变集合适用于大多数情况，让程序易于理解和推断，因为它们是引用透明的( referentially transparent )因此缺省也是线程安全的。 使用可变集合时，明确地引用可变集合的命名空间。不要用使用import scala.collection.mutable._ 然后引用 Set ，应该用下面的方式替代： 12import scala.collections.mutableval set = mutable.Set() 这样就很明确在使用一个可变集合。 使用集合类型缺省的构造函数。每当你需要一个有序的序列(不需要链表语义)，用 Seq() 等诸如此类的方法构造： 123val seq = Seq(1, 2, 3)val set = Set(1, 2, 3)val map = Map(1 -&gt; \"one\", 2 -&gt; \"two\", 3 -&gt; \"three\") 这种风格从语意上分离了集合与它的实现，让集合库使用更适当的类型：你需要Map，而不是必须一个红黑树(Red-Black Tree，注：红黑树TreeMap是Map的实现者) 此外，默认的构造函数通常使用专有的表达式，例如：Map() 将使用有3个成员的对象(专用的Map3类)来映射3个keys。 上面的推论是：在你自己的方法和构造函数里，适当地接受最宽泛的集合类型。通常可以归结为Iterable, Seq, Set, 或 Map中的一个。如果你的方法需要一个 sequence，使用 Seq[T]，而不是List[T] 风格函数式编程鼓励使用流水线转换将一个不可变的集合塑造为想要的结果。这常常会有非常简明的方案，但也容易迷糊读者——很难领悟作者的意图，或跟踪所有隐含的中间结果。例如，我们想要从一组语言中汇集不同的程序语言的投票，按照得票的顺序显示(语言，票数)： 12345678val votes = Seq((\"scala\", 1), (\"java\", 4), (\"scala\", 10), (\"scala\", 1), (\"python\", 10))val orderedVotes = votes .groupBy(.1) .map &#123; case (which, counts) =&gt; (which, counts.foldLeft(0)(_ + .2)) &#125;.toSeq .sortBy(.2) .reverse 上面的代码简洁并且正确，但几乎每个读者都不能理解作者的原本意图。一个策略是声明中间结果和参数： 12345678val votesByLang = votes groupBy &#123; case (lang, ) =&gt; lang &#125;val sumByLang = votesByLang map &#123; case (lang, counts) =&gt; val countsOnly = counts map &#123; case (, count) =&gt; count &#125; (lang, countsOnly.sum) &#125;val orderedVotes = sumByLang.toSeq .sortBy &#123; case (_, count) =&gt; count &#125; .reverse 代码也同样简洁，但更清晰的表达了转换的发生(通过命名中间值)，和正在操作的数据的结构(通过命名参数)。如果你担心这种风格污染了命名空间，用大括号{}来将表达式分组: 1234val orderedVotes = &#123; val votesByLang = ... ... &#125; 性能高阶集合库（通常也伴随高阶构造）使推理性能更加困难：你越偏离直接指示计算机——即命令式风格——就越难准确预测一段代码的性能影响。然而推理正确性通常很容易；可读性也是加强的。在Java运行时使用Scala使得情况更加复杂，Scala对你隐藏了装箱(boxing)/拆箱(unboxing)操作，可能引发严重的性能或内存空间问题。 在关注于低层次的细节之前，确保你使用的集合适合你。 确保你的数据结构没有不期望的渐进复杂度。各种Scala集合的复杂性描述在这儿。 性能优化的第一条原则是理解你的应用为什么这么慢。不要使用空数据操作。在执行前分析[1]你的应用。关注的第一点是热循环(hot loops) 和大型的数据结构。过度关注优化通常是浪费精力。记住Knuth(高德纳)的格言：“过早优化是万恶之源”。 如果是需要更高性能或者空间效率的场景，通常更适合使用低级的集合。对大序列使用数组替代列表(List) (不可变Vector提供了一个指称透明的转换到数组的接口) ，并考虑使用buffers替代直接序列的构造来提高性能。 Java集合使用 scala.collection.JavaConverters 与Java集合交互。它有一系列的隐式转换，添加了asJava和asScala的转换方法。使用它们这些方法确保转换是显式的，有助于阅读： 1234import scala.collection.JavaConverters._ val list: java.util.List[Int] = Seq(1,2,3,4).asJavaval buffer: scala.collection.mutable.Buffer[Int] = list.asScala 并发现代服务是高度并发的—— 服务器通常是在10–100秒内并列上千个同时的操作——处理隐含的复杂性是创作健壮系统软件的中心主题。 线程提供了一种表达并发的方式：它们给你独立的，堆共享的(heap-sharing)由操作系统调度的执行上下文。然而，在Java里线程的创建是昂贵的，是一种必须托管的资源，通常借助于线程池。这对程序员创造了额外的复杂，也造成高度的耦合：很难从所使用的基础资源中分离应用逻辑。 当创建高度分散(fan-out)的服务时这种复杂度尤其明显： 每个输入请求导致一大批对另一层系统的请求。在这些系统中，线程池必须被托管以便根据每一层请求的比例来平衡：一个线程池的管理不善会导致另一个线程池也出现问题。 一个健壮系统必须考虑超时和取消，两者都需要引入更多“控制”线程，使问题更加复杂。注意若线程很廉价这些问题也将会被削弱：不再需要一个线程池，超时的线程将被丢弃，不再需要额外的资源管理。 因此，资源管理危害了模块化。 Future使用Future管理并发。它们将并发操作从资源管理里解耦出来：例如，Finagle（译注：twitter的一个RFC框架）以有效的方式在少量线程上实现并发操作的复用。Scala有一个轻量级的闭包字面语法(literal syntax)，所以Futures引入了很少的语法开销，它们成为很多程序员的第二本能。 Futures允许程序员用一种可扩充的，有处理失败原则的声明风格，来表达并发计算。这些特性使我们相信它们尤其适合在函数式编程中用，这也是鼓励使用的风格。 更愿意转换（transforming）future而非自己创造。Future的转换(transformations)确保失败会传播，可以通过信号取消，对于程序员来说不必考虑Java内存模型的含义。甚至一个仔细的程序员会写出下面的代码，顺序地发出10次RPC请求而后打印结果： 123456789101112131415161718val p = new Promise[List[Result]]var results: List[Result] = Nildef collect() &#123; doRpc() onSuccess &#123; result =&gt; results = result :: results if (results.length &lt; 10) collect() else p.setValue(results) &#125; onFailure &#123; t =&gt; p.setException(t) &#125; &#125; collect() p onSuccess &#123; results =&gt; printf(\"Got results %s\\n\", results.mkString(\", \")) &#125; 程序员不得不确保RPC失败是可传播的，代码散布在控制流程中；糟糕的是，代码是错误的！ 没有声明results是volatile，我们不能确保results每次迭代会保持前一次值。Java内存模型是一个狡猾的野兽，幸好我们可以通过用声明式风格(declarative style)避开这些陷阱： 1234567891011def collect(results: List[Result] = Nil): Future[List[Result]] = doRpc() flatMap &#123; result =&gt; if (results.length &lt; 9) collect(result :: results) else result :: results &#125; collect() onSuccess &#123; results =&gt; printf(\"Got results %s\\n\", results.mkString(\", \")) &#125; 我们用flatMap顺序化操作，把我们处理中的结果预追加(prepend)到list中。这是一个通用的函数式编程习语的Futures译本。这是正确的，不仅需要的样板代码(boilerplate)可以减少，易出错的可能性也会减少，并且读起来更好。 Future组合子(combinators)**的使用。当操作多个futures时，Future.select，Future.join和Future.collect应该被组合编写出通用模式。 集合并发集合的主题充满着意见、微妙(subtleties)、教条、恐惧/不确定/怀疑(FUD)。在大多实际场景都不存在问题：总是先用最简单,最无聊，最标准的集合解决问题。 在你知道不能使用synchronized前不要去用一个并发集合：JVM有着老练的手段来使得同步开销更小，所以它的效率能让你惊讶。 如果一个不可变(immutable)集合可行，就尽可能用不可变集合——它们是指称透明的(referentially transparent)，所以在并发上下文推断它们是简单的。不可变集合的改变通常用更新引用到当前值(一个var单元或一个AtomicReference)。必须小心正确地应用：原子型的(atomics)必须重试(retried)，变量(var类型的)必须声明为volatile以保证它们发布(published)到它们的线程。 可变的并发集合有着复杂的语义，并利用Java内存模型的微妙的一面，所以在你使用前确定你理解它的含义——尤其对于发布更新(新的公开方法)。同步的集合同样写起来更好：像getOrElseUpdate操作不能够被并发集合正确的实现，创建复合(composite)集合尤其容易出错。 控制结构函数式风格的程序倾向于需要更少的传统的控制结构，并且使用声明式风格写的程序读起来更好。这通常意味着打破你的逻辑，拆分到若干个小的方法或函数，用匹配表达式(match expression)把他们粘在一起。函数式程序也倾向于更多面向表达式(expression-oriented)：条件分支是同一类型的值计算，for（..) yield 表达式，以及递归都是司空见惯的。 递归用递归术语来表达你的问题常常会使问题简化，如果应用了尾递归优化(可以通过@tailrec注释检测)，编译器甚至会将你的代码转换为正常的循环。对比一个标准的命令式版本的堆排序(fix-down): 1234567891011121314def fixDown(heap: ArrayT], m: Int, n: Int): Unit = &#123; var k: Int = m while (n &gt;= 2k) &#123; var j = 2k if (j &lt; n &amp;&amp; heap(j) &lt; heap(j + 1)) j += 1 if (heap(k) &gt;= heap(j)) return else &#123; swap(heap, k, j) k = j &#125; &#125; &#125; 每次进入while循环，我们工作在前一次迭代时污染过的状态。每个变量的值是那一分支所进入函数，当找到正确的位置时会在循环中返回。 (敏锐的读者会在Dijkstra的“Go To声明是有害的”一文找到相似的观点) 考虑尾递归的实现[2]: 12345678910@tailrec final def fixDown(heap: Array[T], i: Int, j: Int) &#123; if (j &lt; i2) return val m = if (j == i2 || heap(2i) &lt; heap(2i+1)) 2i else 2i + 1 if (heap(m) &lt; heap(i)) &#123; swap(heap, i, m) fixDown(heap, m, j) &#125; &#125; 每次迭代都是一个明确定义的历史清白的变量，并且没有引用单元：到处都是不变的(invariants)。更容易实现，也容易阅读。也没有性能方面的惩罚：因为方法是尾递归的，编译器会转换为标准的命令式的循环。 返回(Return)并不是说命令式结构没有价值。在很多例子中它们很适合于提前终止计算而非对每个可能终止的点存在一个条件分支：的确在上面的fixDown函数，如果我们已经在堆的结尾，一个return用于提前终止。 Returns可以用于切断分支和建立不变量(establish invariants)。这减少了嵌套，并且容易推断后续的代码的正确性，从而帮助了读者。这尤其适用于卫语句(guard clauses)： 12345678910def compare(a: AnyRef, b: AnyRef): Int = &#123; if (a eq b) return 0 val d = System.identityHashCode(a) compare System.identityHashCode(b) if (d != 0) return d // slow path.. &#125; 使用return增加了可读性 123456def suffix(i: Int) = &#123; if (i == 1) return \"st\" else if (i == 2) return \"nd\" else if (i == 3) return \"rd\" else return \"th\" &#125; 上面是针对命令式语言的，在Scala中鼓励省略return 12345def suffix(i: Int) = if (i == 1) \"st\" else if (i == 2) \"nd\" else if (i == 3) \"rd\" else \"th\" 但使用模式匹配更好： 123456def suffix(i: Int) = i match &#123; case 1 =&gt; \"st\" case 2 =&gt; \"nd\" case 3 =&gt; \"rd\" case _ =&gt; \"th\" &#125; 注意，return会有隐性开销：当在闭包内部使用时。 123456seq foreach &#123; elem =&gt; if (elem.isLast) return // process... &#125; 在字节码层实现为一个异常的捕获/声明(catching/throwing)对，用在频繁的执行的代码中，会有性能影响。 for循环和for推导for对循环和聚集提供了简洁和自然的表达。 它在扁平化(flattening)很多序列时特别有用。for语法通过分配和派发闭包隐藏了底层的机制。这会导致意外的开销和语义；例如： 123for (item &lt;- container) &#123; if (item != 2) return &#125; 如果容器延迟计算(delays computation)会引起运行时错误，使返回不在本地上下文 (making the return nonlocal) 因为这些原因，常常更可取的是直接调用foreach, flatMap, map和filter —— 但在其意义清楚的时候使用for。 要求require和断言(assert)要求(require)和断言(assert)都起到可执行文档的作用。两者都在类型系统不能表达所要求的不变量(invariants)的场景里有用。 assert用于代码假设的不变量(invariants) （内部或外部的） 例如：(译注，不变量 invariant 是指类型不可变，即不支持协变或逆变的类型变量) 12val stream = getClass.getResourceAsStream(\"someclassdata\")assert(stream != null) 相反，require用于表达API契约： 1234def fib(n: Int) = &#123; require(n &gt; 0) ... &#125; 函数式编程面向值（value-oriented ）编程有很多优势，特别是用在与函数式编程结构相结合。这种风格强调值的转换（译注：由一个不变的值生成另一个不变的值）而非状态的改变，生成的代码是指称透明的(referentially transparent)，提供了更强的不变型(invariants)，因此容易实现。Case类(也被翻译为样本类)，模式匹配，解构绑定(destructuring bindings)，类型推断，轻量级的闭包和方法创建语法都是这一类的工具。 Case类模拟代数数据类型Case类可实现代数数据类型(ADT)编码：它们对大量的数据结构进行建模时有用，用强不变类型(invariants)提供了简洁的代码。尤其在结合模式匹配情况下。模式匹配实现了全面解析提供更强大的静态保护。 (译注：ADTs是Algebraic Data Type代数数据类型的缩写，关于这个概念见我的另一篇博客) 下面是用case类模拟代数数据类型的模式 123sealed trait Tree[T]case class NodeT extends Tree[T]case class LeafT extends Tree[T] 类型 Tree[T] 有两个构造函器：Node和Leaf。定义类型为sealed(封闭类)允许编译器进行彻底的分析(这是针对模式匹配的，参考Programming in Scala)因为构造器将不能从外部源文件中添加。 与模式匹配一同，这个建模使得代码简洁并且显然是正确的(obviously correct) 1234def findMinT &lt;: Ordered[T] = tree match &#123; case Node(left, right) =&gt; Seq(findMin(left), findMin(right)).min case Leaf(value) =&gt; value &#125; 尽管一些递归结构，如树的组成是典型的ADTs(代数数据类型)应用，它们的用处领域更大。 disjoint,unions特别容易的用ADTs建模；这些频繁发生在状态机上(state machines)。 OptionsOption类型是一个容器，空(None)或满(Some(value))二选一。它提供了使用null的另一种安全选择，应该尽可能的替代null。它是一个集合(最多只有一个元素)并用集合操所修饰，尽量用Option。 用 123var username: OptionString] = None ... username = Some(\"foobar\") 代替 123var username: String = null ... username = \"foobar\" 因为前者更安全：Option类型静态地强制username必须对空(emptyness)做检测。 对一个Option值做条件判断应该用foreach 12if (opt.isDefined) operate(opt.get) 上面的代码应该用下面的方式替代： 12opt foreach &#123; value =&gt; operate(value)&#125; 风格可能看起来有些古怪，但更安全，更简洁。如果两种情况都有(Option的None或Some)，用模式匹配 1234opt match &#123; case Some(value) =&gt; operate(value) case None =&gt; defaultAction() &#125; 但如果缺少的是缺省值，用getOrElse方法： operate(opt getOrElse defaultValue) 不要过度使用Option： 如果有一个明确的缺省值——一个Null对象——直接用Null而不必用Option Option还有一个方便的构造器用于包装空值(nullable value) Option(getClass.getResourceAsStream(&quot;foo&quot;)) 得到一个 Option[InputStream] 假定空值(None)时getResourceAsStream会返回null。 模式匹配模式匹配(x match { …) 在良好的Scala代码中无处不在：用于合并条件执行、解构(destructuring) 、在构造中造型。使用好模式匹配可以增加程序的明晰度和安全性。 使用模式匹配实现类型转换： 123obj match &#123; case str: String =&gt; ... case addr: SocketAddress =&gt; ... 模式匹配在和解构(destructuring)联合使用时效果最好（例如你要匹配case类）；下面的写法 1234animal match &#123; case dog: Dog =&gt; \"dog (%s)\".format(dog.breed) case _ =&gt; animal.species &#125; 应该被替代为： 1234animal match &#123; case Dog(breed) =&gt; \"dog (%s)\".format(breed) case other =&gt; other.species &#125; 写自定义的抽取器 (extractor)时必须有双重构造器(译注：成对出现的apply方法与unapply方法)，否则可能是不适合的。 当默认的方法更有意义时，对条件执行不要用模式匹配。集合库的方法通常返回Options，避免： 1234val x = list match &#123; case head :: _ =&gt; head case Nil =&gt; default &#125; 因为 val x = list.headOption getOrElse default 更短并且更能表达目的。 偏函数Scala提供了定义PartialFunction的语法简写： 123val pf: PartialFunctionInt, String] = &#123; case i if i%2 == 0 =&gt; \"even\" &#125; 它们也可能和 orElse 组合: 1234val tf: (Int =&gt; String) = pf orElse &#123; case _ =&gt; \"odd\"&#125; tf(1) == \"odd\" tf(2) == \"even\" 偏函数出现在很多场景，并以PartialFunction有效地编码 ，例如 方法参数： 12345678910trait Publisher[T] &#123; def subscribe(f: PartialFunction[T, Unit])&#125; val publisher: Publisher[Int] = ..publisher.subscribe &#123; case i if isPrime(i) =&gt; println(\"found prime\", i) case i if i%2 == 0 =&gt; count += 2 /* ignore the rest */&#125; 或在返回一个Option的情况下： 12// Attempt to classify the the throwable for logging. type Classifier = Throwable =&gt; Optionjava.util.logging.Level 可以更好的用PartialFunction表达 type Classifier = PartialFunctionThrowable, java.util.Logging.Level 因为它提供了更好的可组合性： 1234val classifier1: Classifierval classifier2: Classifier val classifier = classifier1 orElse classifier2 orElse &#123; _ =&gt; java.util.Logging.Level.FINEST &#125; 解构绑定解构绑定与模式匹配有关。它们用了相同的机制，但解构绑定可应用在当匹配只有一种选项的时候 (以免你接受异常的可能)。解构绑定特别适用于元组(tuple)和样本类(case class). 12345val tuple = ('a', 1)val (char, digit) = tuple val tweet = Tweet(\"just tweeting\", Time.now)val Tweet(text, timestamp) = tweet 惰性赋值[当使用lazy修饰一个val成员时，其赋值情况是在需要时才赋值的(by need)，因为Scala中成员与方法是等价的（除了privatethis]成员） lazy val field = computation() 相当于下面的简写: 12345var theField = Nonedef field = if (theField.isDefined) _theField.get else &#123; _theField = Some(computation()) _theField.get &#125; 也就是说，它在需要时计算结果并会记住结果，在要达到这种目的时使用lazy成员；但当语意上需要惰性赋值时(by semantics)，要避免使用惰性赋值，这种情况下，最好显式赋值因为它使得成本模型是明确的，并且副作用被严格的控制。 Lazy成员是线程安全的。 传名调用方法参数可以指定为传名参数 (by-name) 意味着参数不是绑定到一个值，而是一个可能需要反复进行的计算。这一特性需要小心使用； 期待传值(by-value)语法的调用者会感到惊讶。这一特性的动机是构造语法自然的 DSLs——使新的控制结构可以看起来更像本地语言特征。 只在下面的控制结构中使用传名调用, 调用者明显传递的是一段代码块(block)而非一个确定的计算结果。传名参数必须放在参数列表的最后一位。当使用传名调用时，确保方法名称让调用者明显感知到方法参数是传名参数。 当你想要一个值被计算多次，特别是这个计算会引起副作用时，使用显式函数： class SSLConnector(mkEngine: () =&gt; SSLEngine) 这样意图很明确，调用者不会感到惊奇。 flatMap[flatMap——结合了map 和 flatten —— 的使用要特别小心，它有着难以琢磨的威力和强大的实用性。类似它的兄弟 map，它也是经常在非传统的集合中使用的，例如 Future , Option。它的行为由它的（函数）签名揭示；对于一些容器 ContainerA] flatMap[B](f: A =&gt; Container[B]): Container[B] flatMap对集合中的每个元素调用了 函数 f 产生一个新的集合，将它们全部 flatten 后放入结果中。例如，获取两个字符的字符串的所有排列，相同的字符不能出现两次 1234567val chars = 'a' to 'z' val perms = chars flatMap &#123; a =&gt; chars flatMap &#123; b =&gt; if (a != b) Seq(\"%c%c\".format(a, b)) else Seq() &#125; &#125; 等价于下面这段更简洁的 for-comprehension （基本就是针对上面的语法糖） 12345val perms = for &#123; a &lt;- chars b &lt;- chars if a != b &#125; yield \"%c%c\".format(a, b) flatMap在处理Options常常很有用—— 它将多个options链合并为一个， 123456789val host: Option[String] = .. val port: Option[Int] = .. val addr: Option[InetSocketAddress] = host flatMap &#123; h =&gt; port map &#123; p =&gt; new InetSocketAddress(h, p) &#125; &#125; 也可以使用更简洁的for来实现： 1234val addr: OptionInetSocketAddress] = for &#123; h &lt;- host p &lt;- port &#125; yield new InetSocketAddress(h, p) 对flatMap在在Futures中的使用futures一节中有讨论。 面向对象的编程Scala的博大很大程度上在于它的对象系统。Scala中所有的值都是对象，就这一意义而言Scala是门纯粹的语言；基本类型和组合类型没有区别。Scala也提供了mixin的特性允许更多正交地、细粒度地构造一些在编译时受益于静态类型检测的可被灵活组装的模块。 mixin系统的背后动机之一是消除传统的依赖注入。这种“组件风格(component style)”编程的高潮是是the cake pattern. 依赖注入在我们的使用中，我们发现Scala本身删除了很多经典(构造函数)依赖注入的语法开销，我们更愿意就这样用: 它更清晰，依赖仍然植根于（构造）类型，而类构造语法是如此微不足道而变得轻而易举。有些无聊，简单，但有效。对模块化编程时使用依赖注入，特别是，组合优于继承—这使得程序更加模块化和可测试的。当遇到需要继承的情况，问问自己：在语言缺乏对继承支持的情况下如何构造程序？答案可能是令人信服的。 依赖注入典型的使用到 trait （译注：可以理解为和Java中Interface相似） 123456789trait TweetStream &#123; def subscribe(f: Tweet =&gt; Unit) &#125; class HosebirdStream extends TweetStream ... class FileStream extends TweetStream .. class TweetCounter(stream: TweetStream) &#123; stream.subscribe &#123; tweet =&gt; count += 1 &#125; &#125; 这是常见的注入工厂 — 用于产生其他对象的对象。在这些例子中，更青睐用简单的函数而非专有的工厂类型。 1234class FilteredTweetCounter(mkStream: Filter =&gt; TweetStream) &#123; mkStream(PublicTweets).subscribe &#123; tweet =&gt; publicCount += 1 &#125; mkStream(DMs).subscribe &#123; tweet =&gt; dmCount += 1 &#125; &#125; Trait依赖注入不妨碍使用公共接口，或在trait中实现公共代码。恰恰相反—正是因为以下原因而高度鼓励使用trait：一个具体的类可以实现多接口(traits)，公共的代码可以通过这些类复用。 保持traits简短并且是正交的：不要把分离的功能混在一个trait里，考虑将最小的相关的意图放在一起。例如，想象一下你要做一些IO的操作： 1234trait IOer &#123; def write(bytes: Array[Byte]) def read(n: Int): Array[Byte] &#125; 分离两个行为： 123456trait Reader &#123; def read(n: Int): Array[Byte] &#125; trait Writer &#123; def write(bytes: Array[Byte]) &#125; 可以将它们以混入(mix)的方式实现一个IOer : new Reader with Writer…接口最小化促使更好的正交性和更清晰的模块化。 可见性Scala有很丰富的可见性修饰。使用这些可见性修饰很重要，因为它们定义了哪些构成公开API。公开APIs应该限制，这样用户不会无意中依赖实现细节并限制了作者修改它们的能力: 它们对于好的模块化设计是至关重要的。一般来说，扩展公开APIs比收缩公开的APIs容易的多。差劲的注释（annotation）也能危害到你代码向后的二进制兼容性。（译注：comments和annotation都可翻译成注释，但意义不同。annotation在Java和Scala有特定的含义） private[this]一个类的成员标记为私有的， 1private val x: Int = ... [它对这个类的所有实例来说都是可见的（但对其子类不可见）。大多情况，你想要的是 privatethis] 。 1private[this] val: Int = .. [这个修饰限制了它只对当前特定的实例可见。Scala编译器会把privatethis]翻译为一个简单的字段访问(因为访问仅限于静态定义的类)，这样有时有助于性能优化。 单例类型在Scala中创建单例类型是很常见的，例如： 123def foo() = new Foo with Bar with Baz &#123; ... &#125; 在这种情况下，可以通过声明返回类型来限制可见性： 123def foo(): Foo with Bar = new Foo with Bar with Baz &#123; ... &#125; foo()方法的调用者会看到以返回实例(Foo with Bar)的受限视图。 结构类型不要在正常情况下使用结构类型。结构类型有着便利且强大的特性，但不幸的是在JVM上的实现不是很高效。 然而——由于实现的怪癖——它提对执行反射(reflection)供了很好的简写形式。 12val obj: AnyRefobj.asInstanceOf&#123;def close()&#125;].close() 垃圾回收我们对生产中花了很多时间来调整垃圾回收。垃圾回收的关注点与Java大致相似，尽管一些惯用的Scala代码比起惯用的Java代码会容易产生更多(短暂的)垃圾——函数式风格的副产品。Hotspot的分代垃圾收集通常使这不成问题，因为短暂的(short-lived)垃圾在大多情形下会被有效的释放掉。 在谈GC调优话题前，先看看这个Attila的报告，它阐述了我们在GC方面的一些经验。 Scala固有的问题，你能够缓解GC的方法是产生更少的垃圾；但不要在没有数据的情况下行动。除非你做了某些明显的恶化，使用各种Java的profiling工具——我们拥有的包括heapster和gcprof。 Java 兼容性当我们写的Scala代码被Java调用时，我们要确保从Java来用仍然习惯。这常常不需要额外的努力——class和纯的trait等价于Java的中的对应类型 —— 但有时需要提供独立的Java API。一种感受你的库中的Java API好的方式是用Java写单元测试(只是为了兼容性);这也确保了你的库中的Java视图保持稳定，在这一点上不会随着时间因Scala编译器的波动而影响。 包含部分实现的Trait不能直接被Java使用： 改为 extends 一个抽象类 12345678// 不能直接被java使用 trait Animal &#123; def eat(other: Animal) def eatMany(animals: SeqAnimal) = animals foreach(eat(_)) &#125; // 改为这样: abstract class JavaAnimal extends Animal Twitter标准库Twitter最重要的标准库是 Util 和 Finagle。Util 可以理解为Scala和Java的标准库扩展，提供了标准库中没有的功能或已有功能的更合适的实现。Finagle 是我们的RPC系统，核心分布式系统组件。 FutureFutures已经在并发一节中简单讨论过。它是调异步处理的中心机制，渗透在我们代码库中，也是Finagle的核心。Futures允许组合并发事件，简化了高并发操作。也是JVM上异步并发的一种高效的实现。 Twitter的future是异步的，所以基本上任何操作(阻塞操作)——基本上任何可以suspend它的线程的执行；网络IO和磁盘IO是就是例子——必须由系统处理，它为结果提供future。Finagle为网络IO提供了这样一种系统。 Futures清晰简单：它们持有一个尚未完成运算结果的 promise 。它们是一个简单的容器——一个占位符。一次计算当然可能会失败，这种状况必须被编码：一个Future可以是三种状态之一： pending, failed, completed。 闲话: 组合(composition)让我们重新审视我们所说的组合：将简单的组件合成一个更复杂的。函数组合的一个权威的例子：给定函数 f 和 g，组合函数 (g∘f)(x) = g(f(x)) ——结果先对 x使用f函数，然后在使用g函数——用Scala来写： 123456val f = (i: Int) =&gt; i.toStringval g = (s: String) =&gt; s+s+sval h = g compose f // : Int =&gt; String scala&gt; h(123)res0: java.lang.String = 123123123 复合函数h，是个新的函数，由之前定义的f和g函数合成。 Futures是一种集合类型——它是个包含0或1个元素的容器——你可以发现他们有标准的集合方法（eg：map, filter, foreach）。因为Future的值是延迟的，结果应用这些方法中的任何一种必然也延迟；在 12val result: Future[Int]val resultStr: Future[String] = result map &#123; i =&gt; i.toString &#125; 函数 { i =&gt; i.toString } 不会被调用，直到int值可用；转换集合的resultStr在可用之前也一直是待定状态。 List可以被扁平化(flattened)： 12val listOfList: List[List[Int]] = .. val list: List[Int] = listOfList.flatten 这对future也是有意义的： 12val futureOfFuture: Future[Future[Int]] = .. val future: Future[Int] = futureOfFuture.flatten [因为future是延迟的，flatten的实现——立即返回——不得不返回一个等待外部future (Future[Future[Int]]) 完成的future (FutureFuture[Int]]).如果外部future失败，内部flattened future也将失败。 [Future (类似List) 也定义了flatMap；FutureA] 定义方法flatMap的签名 flatMapB: Future[B] 如同组合 map 和 flatten，我们可以这样实现： 12345def flatMapB: Future[B] = &#123; val mapped: Future[Future[B]] = this map f val flattened: Future[B] = mapped.flatten flattened &#125; 这是一种有威力的组合！使用flatMap我们可以定义一个 Future 作为两个Future序列的结果。第二个future 的计算基于第一个的结果。想象我们需要2次RPC调用来验证一个用户身份，我们可以用下面的方式组合操作： 12345def getUser(id: Int): Future[User] def authenticate(user: User): Future[Boolean] def isIdAuthed(id: Int): Future[Boolean] = getUser(id) flatMap &#123; user =&gt; authenticate(user) &#125; 这种组合类型的一个额外的好处是错误处理是内置的：如果getUser(..)或authenticate(..)失败，future 从 isAuthred(..)返回时将会失败。这里我们没有额外的错误处理的代码。 风格Future回调方法(respond, onSuccess, onFailure, ensure) 返回一个新的Future，并链接到调用者。这个Future被保证只有在它调用者完成后才完成，使用模式如下： 123456acquireResource() future onSuccess &#123; value =&gt; computeSomething(value) &#125; ensure &#123; freeResource() &#125; freeResource() 被保证只有在 computeSomething之后才执行，这样就模拟了try-finally 模式。 使用 onSuccess替代 foreach —— 它与 onFailure 方法对称，命名的意图更明确，并且也允许 chaining。 永远避免直接创建Promise实例： 几乎每一个任务都可以通过使用预定义的组合子完成。这些组合子确保错误和取消是可传播的, 通常鼓励的数据流风格的编程，不再需要同步和volatility声明。 用尾递归风格编写的代码不再导致堆栈空间泄漏，并使得以数据流风格高效的实现循环成为可能： 12345678case class Node(parent: Option[Node], ...) def getNode(id: Int): Future[Node] = ... def getHierarchy(id: Int, nodes: List[Node] = Nil): Future[Node] = getNode(id) flatMap &#123; case n@Node(Some(parent), ..) =&gt; getHierarchy(parent, n :: nodes) case n =&gt; Future.value((n :: nodes).reverse) &#125; Future定义很多有用的方法： 使用 Future.value() 和 Future.exception() 来创建未满意(pre-satisfied) 的future。Future.collect(), Future.join() 和 Future.select() 提供了组合子将多个future合成一个(例如：scatter-gather操作的gather部分)。 CancellationFuture实现了一种弱形式的取消。调用Future#cancel 不会直接终止运算，而是发送某个级别的可被任何处理查询的触发信号，最终满足这个future。Cancellation信号流向相反的方向：一个由消费者设置的cancellation信号，会传播到它的生产者。生产者使用 Promise的onCancellation来监听信号并执行相应的动作。 这意味这cancellation语意上依赖生产者，没有默认的实现。cancellation只是一个提示。 LocalUtil的Local提供了一个位于特定的future派发树(dispatch tree)的引用单元(cell)。设定一个local的值，使这个值可以用于被同一个线程的Future 延迟的任何计算。有一些类似于thread locals(注：Java中的线程机制），不同的是它们的范围不是一个Java线程，而是一个 future 线程树。在 123456789101112trait User &#123; def name: String def incrCost(points: Int) &#125; val user = new Local[User] ... user() = currentUser rpc() ensure &#123; user().incrCost(10) &#125; 在 ensure块中的 user() 将在回调被添加的时候引用 user local的值。 就thread locals来说，我们的Locals非常的方便，但要尽量避免使用：除非确信通过显式传递数据时问题不能被充分的解决，哪怕解决起来有些繁重。 Locals有效的被核心库使用在非常常见的问题上——线程通过RPC跟踪，传播监视器，为future的回调创建stack traces——任何其他解决方法都使得用户负担过度。Locals在几乎任何其他情况下都不适合。 Offer/Broker并发系统由于需要协调访问数据和资源而变得复杂。Actor提出一种简化的策略：每一个actor是一个顺序的进程(process),保持自己的状态和资源,数据通过消息的方式与其它actor共享。 共享数据需要actor之间通信。 Offer/Broker 建立于Actor之上，以这三种重要的方式表现：1，通信通道(Brokers)是first class——即发送消息需要通过Brokers，而非直接到actor。2, Offer/Broker 是一种同步机制：通信会话是同步的。 这意味我们可以用 Broker做为协调机制：当进程a发送一条信息给进程b；a和b都要对系统状态达成一致。3, 最后，通信可以选择性地执行：一个进程可以提出几个不同的通信，其中的一个将被获取。 为了以一种通用的方式支持选择性通信（以及其他组合），我们需要将通信的描述和执行解耦。这正是Offer做的——它是一个持久数据用于描述一次通信；为了执行这个通信（offer执行），我们通过它的sync()方法同步 123trait Offer[T] &#123; def sync(): Future[T] &#125; 返回 Future[T] 当通信被获取的时候生成交换值。 Broker通过offer协调值的交换——它是通信的通道： 1234trait Broker[T] &#123; def send(msg: T): Offer[Unit] val recv: Offer[T] &#125; 所以，当创建两个offer 123val b: Broker[Int]val sendOf = b.send(1)val recvOf = b.recv sendOf和recvOf都同步 12345// In process 1: sendOf.sync() // In process 2: recvOf.sync() 两个offer都获取并且值1被交换。 通过将多个offer和Offer.choose绑定来执行可选择通信。 1def chooseT: Offer[T] 上面的代码生成一个新的offer，当同步时获取一个特定的ofs——第一个可用的。当多个都立即可用时，随机获取一个。 Offer对象有些一次性的Offers用于与来自Broker的Offer构建。 1Offer.timeout(duration): Offer[Unit] offer在给定时间后激活。Offer.never将用于不会有效，Offer.const(value)在给定值后立即有效。这些操作由选择性通信来组合是非常有用的。例如，在一个send操作中使用超时： 1234Offer.choose( Offer.timeout(10.seconds), broker.send(\"my value\") ).sync() 人们可能会比较 Offer/Broker 与SynchronousQueue，他们有细微但非常重要的区别。Offer可以被组合，而queue不能。例如，考虑一组queues，描述为 Brokers: 123val q0 = new Broker[Int]val q1 = new Broker[Int]val q2 = new Broker[Int] 现在让我们为读取创建一个合并的queue 1val anyq: Offer[Int] = Offer.choose(q0.recv, q1.recv, q2.recv) anyq是一个将从第一个可用的queue中读取的offer。注意 anyq 仍是同步的——我们仍然拥有底层队列的语义。这类组合是不可能用queue实现的。 例子：一个简单的连接池连接池在网络应用中很常见，并且它们的实现常常需要技巧——例如，在从池中获取一个连接的时候，通常需要超时机制，因为不同的客户端有不同的延迟需求。池的简单原则：维护一个连接队列，满足那些进入的等待者。使用传统的同步原语，这通常需要两个队列(queues)：一个用于等待者(当没有连接可用时)，一个用于连接(当没有等待者时)。 使用 Offer/Brokers ，可以表达得非常自然： 12345678910111213141516171819class Pool(conns: Seq[Conn]) &#123; private[this] val waiters = new Broker[Conn] private[this] val returnConn = new Broker[Conn] val get: Offer[Conn] = waiters.recv def put(c: Conn) &#123; returnConn ! c &#125; private[this] def loop(connq: Queue[Conn]) &#123; Offer.choose( if (connq.isEmpty) Offer.never else &#123; val (head, rest) = connq.dequeue waiters.send(head) &#123; _ =&gt; loop(rest) &#125; &#125;, returnConn.recv &#123; c =&gt; loop(connq enqueue c) &#125; ).sync() &#125; loop(Queue.empty ++ conns) &#125; loop总是提供一个归还的连接，但只有queue非空的时候才会send。 使用持久化队列(persistent queue)更进一步简化逻辑。与连接池的接口也是通过Offer实现，所以调用者如果愿意设置timeout，他们可以通过利用组合子(combinators)来做： 1234val conn: Future[Option[Conn]] = Offer.choose( pool.get &#123; conn =&gt; Some(conn) &#125;, Offer.timeout(1.second) &#123; _ =&gt; None &#125; ).sync() 实现timeout不需要额外的记账(bookkeeping)；这是因为Offer的语义：如果Offer.timeout被选择，不会再有offer从池中获得——连接池和它的调用者在各自waiter的broker上不必同时同意接受和发送。 埃拉托色尼筛子(Sieve of Eratosthenes 译注：一种用于筛选素数的算法)把并发程序构造为一组顺序的同步通信进程，通常很有用——有时程序被大大地简化了。Offer和Broker提供了一组工具来让它简单并一致。确实，它们的应用超越了我们可能认为是经典并发性问题——并发编程(有Offer/Broker的辅助)是一种有用的构建工具，正如子例程(subroutines)，类，和模块都是——来自CSP（译注：Communicating sequential processes的缩写，即通信顺序进程）的重要思想。 这里有一个埃拉托色尼筛子可以构造为一个针对一个整数流(stream of integers)的连续的应用过滤器 。首先，我们需要一个整数的源(source of integers)： 123456def integers(from: Int): Offer[Int] = &#123; val b = new Broker[Int] def gen(n: Int): Unit = b.send(n).sync() ensure gen(n + 1) gen(from) b.recv &#125; integers(n) 方法简单地提供了从n开始的所有连续的整数。然后我们需要一个过滤器： 1234567891011121314def filter(in: Offer[Int], prime: Int): Offer[Int] = &#123; val b = new Broker[Int] def loop() &#123; in.sync() onSuccess &#123; i =&gt; if (i % prime != 0) b.send(i).sync() ensure loop() else loop() &#125; &#125; loop() b.recv &#125; filter(in, p) 方法返回的offer删除了in中的所有质数(prime)的倍数。最终我们定义了我们的筛子（sieve）： 123456789def sieve = &#123; val b = new Broker[Int] def loop(of: Offer[Int]) &#123; for (prime &lt;- of.sync(); _ &lt;- b.send(prime).sync()) loop(filter(of, prime)) &#125; loop(integers(2)) b.recv &#125; loop() 工作很简单：从of中读取下一个质数，然后对of应用过滤器排除这个质数。loop不断的递归，持续的质数被过滤，于是我们得到了筛选结果。我们现在打印前10000个质数： 1234val primes = sieve 0 until 10000 foreach &#123; _ =&gt; println(primes.sync()()) &#125; 除了构造简单，组件正交，这种做法也给你一种流式筛子(streaming sieve)：你不需要事先计算出你感兴趣的质数集合，从而进一步提高了模块化。 致谢本课程由Twitter公司Scala社区贡献——我希望我是个忠实的记录者。 Blake Matheny, Nick Kallen, Steve Gury, 和Raghavendra Prabhu提供了很多有用的指导和许多优秀的建议。","raw":null,"content":null,"categories":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/categories/scala/"}],"tags":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/tags/scala/"}]},{"title":"数据仓库分层设计","slug":"数据仓库分层设计","date":"2020-02-26T00:23:00.000Z","updated":"2020-02-26T00:23:00.000Z","comments":true,"path":"2020/02/26/数据仓库分层设计/","link":"","permalink":"https://freehubs.github.io/2020/02/26/数据仓库分层设计/","excerpt":"\n            数仓概述\n          \n数据仓库的建设是一个过程，而不是一个项目。在这个过程中我们需要形成自己的规范，以方便管理和维护。在数据仓库的建设过程中，不仅会面临着公司业务迅速发展，业务系统迭代变更，需要对业务系统数据进行相应的整合，形成公司完整的统一数据视图；而且基于数据仓库的应用也是多样化的，比如支撑自己企业的数据可视化平台、即席查询、对策略提供数据支持等。","text":"数仓概述 数据仓库的建设是一个过程，而不是一个项目。在这个过程中我们需要形成自己的规范，以方便管理和维护。在数据仓库的建设过程中，不仅会面临着公司业务迅速发展，业务系统迭代变更，需要对业务系统数据进行相应的整合，形成公司完整的统一数据视图；而且基于数据仓库的应用也是多样化的，比如支撑自己企业的数据可视化平台、即席查询、对策略提供数据支持等。 数仓模型 模型层定义 模型层次 英文全称 中文名 层次定义 ODL Operational Data Layer 操作数据层 该层级主要功能是存储从源系统直接获得的数据（数据从数据结构、数据之间的逻辑关系上都与源系统基本保持一致） IDL Integrated Data Layer 集成数据层 该层的主要功能是基于主题域的划分，面向业务主题、以数据为驱动设计模型，并且基于3NF建模，完成数据整合，提供统一的基础数据来源。 CDL Component Data Layer 元件数据层 面向分析主题的、统一的数据访问层，所有的基础数据、业务规则和业务实体的基础指标库以及多维模型都在这里统一计算口径、统一建模，大量基础指标库以及多维模型在该层实现。该层级以分析需求为驱动进行模型设计，实现跨业务主题域数据的关联计算或者轻度汇总计算，因此会有大数据量的多表关联汇总计算。 MDL Mart Data Layer 数据集市层 该层次主要功能是加工多维度冗余的宽表（解决复杂的查询）、多维分析的汇总表。 ADL Application Data Layer 应用数据层 该层级的主要功能是满足业务方的需求；在该层级实现报表（海豚、星空、邮件报表）、自助取数等需求。 DIM Dimension Data Layer 维度层 该层主要存储简单、静态、代码类的维表，包括从OLTP层抽取转换维表、根据业务或分析需求构建的维表以及仓库技术维表如日期维表等。 REF 数据接口层 该层级独立于其他层级之外，其来源可以是任意层级，主要存放的是在与其他组对接的时候提供给对方的数据 模型思想ODL模型数据层次ODL（操作数据层），该层级主要临时存储从多种数据源（包括在线业务系统和点击流日志）抽取的业务数据。 数据特点1.数据集结构及数据集间关系都和数据源基本保持一致2.临时存储，数据存储一到两周即可删除或备份至廉价设备3.数据集多为增量抽取，产生大量的Delta数据集 数据处理1.数据集增量获取、分发2.数据集轻度清洗，如字符集转换、脏数据过滤、第一类维值标准化处理等3.点击流数据处理，完成日志获取、字符串处理、URL解析等 数据抽取主要是增量抽取为主、有部分业务表涉及全量抽取；增量抽取通过storm消费binlog日志方式来获得源数据库中变化的数据，解析源数据库日志，准实时的生成增量数据；全量抽取将数据源中的表或视图的数据从数据库中抽取出来，抽取时间较长，效率低。 数据存储ODL层设计上分为两个层次，第一个层次存储近一段时间的增量数据（贴源），一般是通过订阅Binlog日志生成带event type和event time等字段的日分区delta表；第二个层次存储全量数据信息，通过append delta表生成全量数据； IDL模型数据层次IDL（集成数据层），该层级按照业务主题组织数据，完成对ODL层数据的清洗和集成，为CDL层提供数据结构统一、业务语义标准的基础数据。 数据特点1.明细数据，按照业务主题分类，以业务为驱动设计表结构和表间关系2.数据集成，基于3NF设计模型，并在语义层达到统一和标准3.数据带有仓库层的日期和状态标签，可追溯其生命周期中的所有变化状态 数据处理1.对ODL数据进行集成整合，数据项进行重定义和清洗，完成业务数据的归一化处理2.梳理第一类维表来源，即从源业务系统抽取的代码表，并完成缓慢变化维处理3.使用ODL层的Delta（增、删、改）数据、全量数据更新当前表和历史表，数据存储上采用拉链和快照方式存储 数据更新策略1.全量快照：每天存储一份最新的数据，来源数据为全量数据，数据量较小（默认小于10W），且需要保留历史变化轨迹2.拉链表：通过开闭链时间维护最新数据3.增量表：增量插入当天分区，例如：日志表4.全量覆盖：删除目标表全部数据，再插入当前数据；来源数据为全量数据，且无需保留历史轨迹，只使用最新状态数据 CDL模型数据层次CDL（元件数据层），该层级按照分析主题组织数据，跨IDL层的业务主题，集成与该分析主题相关的所有数据，为ADL层的分析模型提供共享的、可复用的元件数据。 数据特点1.数据模型相对稳定，无衍生指标，轻度汇总2.多维模型：分析对象的状态（静态、描述）数据和相关事实表或维表关联形成以冗余宽表为中心的雪花或星型模型3.基础指标库：分析对象的行为（主动、被动）数据汇总而成的一系列基础指标库 数据处理1.分析对象和相关事实表或维表进行多表关联计算生成多维模型2.对分析对象的行为数据进行汇总计算生成基础指标库3.梳理两类维表来源，一是分析需求，二是仓库技术4.对多维模型或基础指标数据进行轻度汇总，产生基础的、通用的汇总模型 数据种类1.多维模型数据（Multidimensional Data）：采用维度建模方式建立的数据模型数据。2.基础指标库数据(Stable Indicator Data)：基于某个分析实体的一系列基础指标集合。3.常用通用的JOIN数据（Common Join Data）：从IDL层上来的一些实体对象，可能需要经常JOIN在一起使用，在此可以预先处理一些常用通用的JOIN逻辑。 数据刷新保留每日数据的应用状态，存储采用每日数据快照的方式 MDL模型数据层次MDL（数据集市层），该层次主要功能是加工多维度冗余的宽表（解决复杂的查询）、多角度分析的汇总表。 数据特点1.数据模型相对稳定，有衍生指标2.宽表模型：基础指标群、多维模型数据和相关事实表或维表关联形成通用或定制的冗余宽表3.多角度汇总：从多个角度分析的汇总模型 数据处理1.多维模型数据和相关事实表或维表进行多表关联计算生成宽表模型2.对多维模型或基础指标数据进行汇总，产生个性的、通用的汇总模型 ADL模型数据层次ADL（应用数据层），该层级按照项目和应用组织数据，以CDL层的半成品元件数据为基础，规划多样化、个性化的衍生指标体系、分析模型和数据应用。 数据特点1.数据模型不稳定，随着分析算法和应用的变更随时变化或下线2.数据高度汇总，可做交叉分析、上卷、下钻、切片、切块、旋转等多维分析操作3.更高级的数据分析或挖掘应用，衍生出信息类、知识类数据 数据处理1.根据不同的数据应用处理数据，所有的指标或者汇总都依赖于具体的业务分析主题和分析人员的定义，并直接交付信息给使用者2.数据处理和信息交付方式多样，如报表、仪表盘、即席查询、多维分析、实时数据应用、数据挖掘应用等 DIM模型DIM层主要包括三类即简单、静态、代码类维表，存储仓库层归纳梳理的所有维表信息1).从业务源系统抽取转化的维表，每日保留全量快照；2).根据业务分析需求构建的维表，每日保留全量快照；3).仓库技术常用维表，只保留当前信息；","raw":null,"content":null,"categories":[{"name":"warehouse","slug":"warehouse","permalink":"https://freehubs.github.io/categories/warehouse/"}],"tags":[{"name":"warehouse","slug":"warehouse","permalink":"https://freehubs.github.io/tags/warehouse/"}]},{"title":"lc-青蛙跳台阶","slug":"lc-青蛙跳台阶","date":"2020-02-24T23:44:03.000Z","updated":"2020-02-24T23:44:03.000Z","comments":true,"path":"2020/02/24/lc-青蛙跳台阶/","link":"","permalink":"https://freehubs.github.io/2020/02/24/lc-青蛙跳台阶/","excerpt":"\n            题目：青蛙跳台阶\n          \n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n1234567891011示例 1：输入：n = 2输出：2示例 2：输入：n = 7输出：21提示：0 &lt;= n &lt;= 100","text":"题目：青蛙跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 1234567891011示例 1：输入：n = 2输出：2示例 2：输入：n = 7输出：21提示：0 &lt;= n &lt;= 100 思路 考虑最后一个台阶n，有两种方式达到n，一是从n-2跳过去，一是从n-1跳过去。 因此： f(n) = f(n-1) + f(n-2) 条件：n&gt;1 其中: f(0) = f(1) = 1 代码 1234567891011121314object Solution &#123; def numWays(n: Int): Int = &#123; if(n&lt;2) return 1 else&#123; var (a,b,sum)=(1,1,0) for(i &lt;- 2 to n)&#123; sum = (a+b)%1000000007 a = b b = sum &#125; sum &#125; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://freehubs.github.io/categories/leetcode/"}],"tags":[{"name":"algo","slug":"algo","permalink":"https://freehubs.github.io/tags/algo/"},{"name":"leetcode","slug":"leetcode","permalink":"https://freehubs.github.io/tags/leetcode/"}]},{"title":"Scala可变容器类","slug":"Scala可变容器类","date":"2020-02-24T16:00:12.000Z","updated":"2020-02-24T16:00:12.000Z","comments":true,"path":"2020/02/24/Scala可变容器类/","link":"","permalink":"https://freehubs.github.io/2020/02/24/Scala可变容器类/","excerpt":"\n            Array Buffers\n          \n一个ArrayBuffer缓冲包含数组和数组的大小。对数组缓冲的大多数操作，其速度与数组本身无异。因为这些操作直接访问、修改底层数组。另外，数组缓冲可以进行高效的尾插数据。追加操作均摊下来只需常量时间。因此，数组缓冲可以高效的建立一个有大量数据的容器，无论是否总有数据追加到尾部。\n12345678scala&gt; val buf = scala.collection.mutable.ArrayBuffer.empty[Int]buf: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()scala&gt; buf += 1res32: buf.type = ArrayBuffer(1)scala&gt; buf += 10res33: buf.type = ArrayBuffer(1, 10)scala&gt; buf.toArrayres34: Array[Int] = Array(1, 10)","text":"Array Buffers 一个ArrayBuffer缓冲包含数组和数组的大小。对数组缓冲的大多数操作，其速度与数组本身无异。因为这些操作直接访问、修改底层数组。另外，数组缓冲可以进行高效的尾插数据。追加操作均摊下来只需常量时间。因此，数组缓冲可以高效的建立一个有大量数据的容器，无论是否总有数据追加到尾部。 12345678scala&gt; val buf = scala.collection.mutable.ArrayBuffer.empty[Int]buf: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()scala&gt; buf += 1res32: buf.type = ArrayBuffer(1)scala&gt; buf += 10res33: buf.type = ArrayBuffer(1, 10)scala&gt; buf.toArrayres34: Array[Int] = Array(1, 10) List Buffers ListBuffer 类似于数组缓冲。区别在于前者内部实现是链表， 而非数组。如果你想把构造完的缓冲转换为列表，那就用列表缓冲，别用数组缓冲。 12345678scala&gt; val buf = scala.collection.mutable.ListBuffer.empty[Int]buf: scala.collection.mutable.ListBuffer[Int] = ListBuffer()scala&gt; buf += 1res35: buf.type = ListBuffer(1)scala&gt; buf += 10res36: buf.type = ListBuffer(1, 10)scala&gt; buf.toListres37: List[Int] = List(1, 10) StringBuilders 数组缓冲用来构建数组，列表缓冲用来创建列表。类似地，StringBuilder 用来构造字符串。作为常用的类，字符串构造器已导入到默认的命名空间。直接用 new StringBuilder就可创建字符串构造器 ，像这样： 12345678scala&gt; val buf = new StringBuilderbuf: StringBuilder =scala&gt; buf += 'a'res38: buf.type = ascala&gt; buf ++= \"bcdef\"res39: buf.type = abcdefscala&gt; buf.toStringres41: String = abcdef 链表 链表是可变序列，它由一个个使用next指针进行链接的节点构成。它们的支持类是LinkedList。在大多数的编程语言中，null可以表示一个空链表，但是在Scalable集合中不是这样。因为就算是空的序列，也必须支持所有的序列方法。尤其是 LinkedList.empty.isEmpty 必须返回true，而不是抛出一个 NullPointerException 。空链表用一种特殊的方式编译： 它们的 next 字段指向它自身。链表像他们的不可变对象一样，是最佳的顺序遍历序列。此外，链表可以很容易去插入一个元素或链接到另一个链表。 双向链表 双向链表和单向链表相似，只不过它们除了具有 next字段外，还有一个可变字段 prev用来指向当前节点的上一个元素 。这个多出的链接的好处主要在于可以快速的移除元素。双向链表的支持类是DoubleLinkedList. 可变列表 MutableList 由一个单向链表和一个指向该链表终端空节点的指针构成。因为避免了贯穿整个列表去遍历搜索它的终端节点，这就使得列表压缩了操作所用的时间。MutableList 目前是Scala中mutable.LinearSeq 的标准实现。 队列 Scala除了提供了不可变队列之外，还提供了可变队列。你可以像使用一个不可变队列一样地使用一个可变队列，但你需要使用+= 和++=操作符进行添加的方式来替代排队方法。 当然，在一个可变队列中，出队方法将只移除头元素并返回该队列。这里是一个例子： 123456789101112scala&gt; val queue = new scala.collection.mutable.Queue[String]queue: scala.collection.mutable.Queue[String] = Queue()scala&gt; queue += \"a\"res10: queue.type = Queue(a)scala&gt; queue ++= List(\"b\", \"c\")res11: queue.type = Queue(a, b, c)scala&gt; queueres12: scala.collection.mutable.Queue[String] = Queue(a, b, c)scala&gt; queue.dequeueres13: String = ascala&gt; queueres14: scala.collection.mutable.Queue[String] = Queue(b, c) 数组序列 Array Sequences 是具有固定大小的可变序列。在它的内部，用一个 Array[Object]来存储元素。在Scala 中，ArraySeq 是它的实现类。 如果你想拥有 Array 的性能特点，又想建立一个泛型序列实例，但是你又不知道其元素的类型，在运行阶段也无法提供一个ClassTag ，那么你通常可以使用 ArraySeq 。这些问题在arrays一节中有详细的说明。 堆栈 你已经在前面看过了不可变栈。还有一个可变栈，支持类是mutable.Stack。它的工作方式与不可变栈相同，只是适当的做了修改。 123456789101112131415161718scala&gt; val stack = new scala.collection.mutable.Stack[Int] stack: scala.collection.mutable.Stack[Int] = Stack()scala&gt; stack.push(1)res0: stack.type = Stack(1)scala&gt; stackres1: scala.collection.mutable.Stack[Int] = Stack(1)scala&gt; stack.push(2)res0: stack.type = Stack(1, 2)scala&gt; stackres3: scala.collection.mutable.Stack[Int] = Stack(1, 2)scala&gt; stack.topres8: Int = 2scala&gt; stackres9: scala.collection.mutable.Stack[Int] = Stack(1, 2)scala&gt; stack.pop res10: Int = 2scala&gt; stack res11: scala.collection.mutable.Stack[Int] = Stack(1) 数组堆栈 ArrayStack 是另一种可变栈的实现，用一个可根据需要改变大小的数组做为支持。它提供了快速索引，使其通常在大多数的操作中会比普通的可变堆栈更高效一点。 哈希表 Hash Table 用一个底层数组来存储元素，每个数据项在数组中的存储位置由这个数据项的Hash Code 来决定。添加一个元素到Hash Table不用花费多少时间，只要数组中不存在与其含有相同Hash Code的另一个元素。因此，只要Hash Table能够根据一种良好的hash codes分配机制来存放对象，Hash Table的速度会非常快。所以在Scala中默认的可变map和set都是基于Hash Table的。你也可以直接用mutable.HashSet 和 mutable.HashMap 来访问它们。 Hash Set 和 Map 的使用和其他的Set和Map是一样的。这里有一些简单的例子： 12345678910scala&gt; val map = scala.collection.mutable.HashMap.empty[Int,String]map: scala.collection.mutable.HashMap[Int,String] = Map()scala&gt; map += (1 -&gt; \"make a web site\")res42: map.type = Map(1 -&gt; make a web site)scala&gt; map += (3 -&gt; \"profit!\")res43: map.type = Map(1 -&gt; make a web site, 3 -&gt; profit!)scala&gt; map(1)res44: String = make a web sitescala&gt; map contains 2res46: Boolean = false Hash Table的迭代并不是按特定的顺序进行的。它是按任何可能的顺序，依次处理底层数组的数据。为了保证迭代的次序，可以使用一个Linked Hash Map 或 Set 来做为替代。Linked Hash Map 或 Set 像标准的Hash Map 或 Set一样，只不过它包含了一个Linked List,其中的元素按添加的顺序排列。在这种容器中的迭代都是具有相同的顺序，就是按照元素最初被添加的顺序进行迭代。 Weak Hash Maps Weak Hash Map 是一种特殊的Hash Map，垃圾回收器会忽略从Map到存储在其内部的Key值的链接。这也就是说，当一个key不再被引用的时候，这个键和对应的值会从map中消失。Weak Hash Map 可以用来处理缓存，比如当一个方法被同一个键值重新调用时，你想重用这个大开销的方法返回值。如果Key值和方法返回值存储在一个常规的Hash Map里，Map会无限制的扩展，Key值也永远不会被垃圾回收器回收。用Weak Hash Map会避免这个问题。一旦有一个Key对象不再被引用，那它的实体会从Weak Hash Map中删除。在Scala中，WeakHashMap类是Weak Hash Map的实现类，封装了底层的Java实现类java.util.WeakHashMap。 Concurrent Maps Concurrent Map可以同时被多个线程访问。除了Map的通用方法，它提供了下列的原子方法： Concurrent Map类中的方法： WHAT IT IS WHAT IT DOES m putIfAbsent(k, v) 添加 键/值 绑定 k -&gt; m ，如果k在m中没有被定义过 m remove (k, v) 如果当前 k 映射于 v，删除k对应的实体。 m replace (k, old, new) 如果k先前绑定的是old，则把键k 关联的值替换为new。 m replace (k, v) 如果k先前绑定的是其他值，则把键k对应的值替换为v ConcurrentMap体现了Scala容器库的特性。目前，它的实现类只有Java的java.util.concurrent.ConcurrentMap, 它可以用standard Java/Scala collection conversions(标准的java/Scala容器转换器)来自动转换成一个Scala map。 Mutable Bitsets 一个类型为mutable.BitSet的可变bit集合和不可变的bit集合很相似，它只是做了适当的修改。Mutable bit sets在更新的操作上比不可变bit set 效率稍高，因为它不必复制没有发生变化的 Long值。 12345678scala&gt; val bits = scala.collection.mutable.BitSet.emptybits: scala.collection.mutable.BitSet = BitSet()scala&gt; bits += 1res49: bits.type = BitSet(1)scala&gt; bits += 3res50: bits.type = BitSet(1, 3)scala&gt; bitsres51: scala.collection.mutable.BitSet = BitSet(1, 3)","raw":null,"content":null,"categories":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/categories/scala/"}],"tags":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/tags/scala/"}]},{"title":"Scala 算法实现","slug":"Scala-算法实现","date":"2020-02-22T23:25:51.000Z","updated":"2020-02-23T23:25:51.000Z","comments":true,"path":"2020/02/22/Scala-算法实现/","link":"","permalink":"https://freehubs.github.io/2020/02/22/Scala-算法实现/","excerpt":"\n            冒泡排序-n2\n          \n原理通过相邻元素比较交换的方式，将最大的元素依次移动到列表中未排好序部分的尾部，重复操作，直到列表中未排好序的部分为空，从而使整个列表有序","text":"冒泡排序-n2 原理通过相邻元素比较交换的方式，将最大的元素依次移动到列表中未排好序部分的尾部，重复操作，直到列表中未排好序的部分为空，从而使整个列表有序 scala实现思路通过相邻元素比较交换的方式，将最大的元素依次移动到列表中未排好序部分的尾部，重复操作，直到列表中未排好序的部分为空，从而使整个列表有序 新建一冒泡函数bubble(unSorteds: List[A]): A，实现一趟冒泡功能，即从输入列表中冒泡出一个最大元素A 给bubble函数添加两个参数remains: List[A], accOrdereds: List[A],添加后函数如下：bubble(unSorteds: List[A],remains: List[A], accOrdereds: List[A]): A 其中remains用于记录每次冒泡后去掉冒出去的元素后剩余元素列表， accOrdereds用于累积每趟冒泡冒出来的元素，然后将返回值A改为List[A],即返回累积排好序的列表。 函数bubble使用“模式匹配”匹配为排序的列表，分两种情况 列表中至少有两种元素的情况 列表中只剩余一个元素 这种情况下，当剩余元素列表remains为空时，说明整个排序完成。否则继续递归bubble 具体实现循环123456789101112131415161718/** 冒泡排序 时间复杂度 n2 */ import scala.collection.mutable.ListBuffer def bubbleSortV1(list: ListBuffer[Int]): ListBuffer[Int] = list match &#123; case null =&gt; null case _ =&gt; var tmp = 0 val length = list.length for (i &lt;- 0 until length) &#123; for (j &lt;- i until length) &#123; if (list(i) &gt; list(j)) &#123; tmp = list(i) list(i) = list(j) list(j) = tmp &#125; &#125; &#125; list &#125; 尾递归123456/** * @param unSorteds 每一趟冒泡时待排序列表 * @param remains 已遍历且未冒出的元素列表 * @param accOrdereds 已冒出的元素组成的有序列表(是累积的) * @return 每一趟冒泡后排好序的列表 */ 123456789101112131415161718def bubbleSortV3(list: List[Int]): List[Int] = &#123; import scala.annotation.tailrec @tailrec def bubble(unBubbles: List[Int], remains: List[Int], bubbled: List[Int]): List[Int] = unBubbles match &#123; case head :: Nil =&gt; if (remains.isEmpty) head :: bubbled else bubble(remains, Nil, head :: bubbled) case head1 :: head2 :: tail =&gt; if (head1 &gt; head2) &#123; bubble(head1 :: tail, head2 :: remains, bubbled) &#125; else &#123; bubble(head2 :: tail, head1 :: remains, bubbled) &#125; &#125; list match &#123; case Nil =&gt; Nil case _ =&gt; bubble(list, Nil, Nil) &#125;&#125; 快速排序-nlogn 原理使用分治思想，将数列用选好的基准点划分为两个子序列（也就是将比基准点小的元素放左边，比基准点大的元素放右边），递归对子序列使用此方法进行此操作，递归到最底部时，数列的大小是零或一，也就是已排好序。 实现思路利用scala的模式匹配对序列进行匹配，分两种情况： 序列为空：为空时返回一个空的List() 序列由head和tail组成，head不为空： 这时候以head为基准点将序列划分为left和right两个子序列，然后然后对left和right进行同样操作并将结果quickSort(left)和quickSort(right)与基准元素head连接起来，如此递归操作，直到所有子序列都为空，便已排好序。 代码123456def quickSort(list: List[Int]): List[Int] = list match &#123; case Nil =&gt; List() case head :: tail =&gt; val (left, right) = tail.partition(_ &lt; head) quickSort(left) ::: List(head) ::: quickSort(right)&#125; 插入排序-n2 原理通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入，直到将所有未排序数据都插入到已排序序列中，排序便完成 scala实现思路 新建一个insert函数实现将一个元素插入到已排序序列的功能，函数签名如下 def insert(a: A, accOrdereds: List[A]): List[A]，其中accOrdereds为已经排序序列，且是累积的，即每次insert时传入的都是当前最新的已排序序列。此函数实现思路也是使用模式匹配来实现。 这种情况下 新建一sort函数，函数签名如下： def sort(unSorteds: List[A], accOrdereds: List[A]): List[A] 其中unSorteds是以模式匹配的方式匹配头和尾，将头元素使用insert函数插入到累积的已排序的序列。然后再使用sort进行下一轮插入。如此递归执行，直到为排序序列unSorteds为空，返回累积已经排好序的序列 注意 scala中List的头(head)是List中第一个元素，List的尾(tail)是去掉头元素(head)后的List scala代码实现尾递归实现12345678910111213def insertSortV2(list: List[Int]): List[Int] = &#123; def sort(unSortedList: List[Int], sortedList: List[Int]): List[Int] = unSortedList match &#123; case Nil =&gt; sortedList case head :: tail =&gt; sort(tail, insert(head, sortedList)) &#125; sort(list, Nil)&#125;def insert(data: Int, sortedList: List[Int]): List[Int] = sortedList match &#123; case head :: tail if data &gt; head =&gt; head :: insert(data, tail) case _ =&gt; data :: sortedList&#125; 循环实现1234567891011121314def insertSort(list: List[Int]): List[Int] = list match &#123; case Nil =&gt; List() case _ =&gt; var orderedList = List[Int]() for (data &lt;- list) &#123; orderedList = insert(data, orderedList) &#125; orderedList&#125;def insert(data: Int, sortedList: List[Int]): List[Int] = sortedList match &#123; case head :: tail if data &gt; head =&gt; head :: insert(data, tail) case _ =&gt; data :: sortedList&#125; 归并排序-nlogn 原理使用分治思想，将序列划分为若干个只有一个元素的子序列，重复进行merge排序操作，将子序列两两合并，直到最后只剩下一个子序列，这个子序列就是已排好的序列 scala实现思路 创建一个merge函数用于合并两个排好序的子序列 def merge(as: List[A], bs: List[A]): List[A] 实现方式通过内建一个loop函数，实现对两个序列的遍历和排序，loop函数签名如下： def loop(cs: List[A], ds: List[A], accSorteds: List[A]): List[A] cs和ds是两个已排序序列，accSorteds是累积排序序列，cs和ds合并过程中产生的新的有序列序列 新建一个划分序列并将划分序列合并排序的函数： splitIn2AndSort(as: List[A]): List[A] scala代码实现12345678910111213141516171819202122232425262728293031323334353637def mergeSort(list: List[Int]): List[Int] = &#123; def merge(list1: List[Int], list2: List[Int]): List[Int] = &#123; @scala.annotation.tailrec def loop(aList: List[Int], bList: List[Int], mergedList: List[Int]): List[Int] = (aList, bList) match &#123; case (Nil, Nil) =&gt; mergedList case (Nil, bHead :: bTail) =&gt; loop(Nil, bTail, bHead :: mergedList) case (aHead :: aTail, Nil) =&gt; loop(aTail, Nil, aHead :: mergedList) case (aHead :: aTail, bHead :: bTail) =&gt; if (aHead &gt; bHead) loop(aList, bTail, bHead :: mergedList) else loop(aTail, bList, aHead :: mergedList) &#125; loop(list1, list2, Nil).reverse &#125; def sort(lists: (List[Int], List[Int])): List[Int] = lists match &#123; case (Nil, Nil) =&gt; Nil case (head :: Nil, Nil) =&gt; head :: Nil case (Nil, head :: Nil) =&gt; head :: Nil case (aList, bList) =&gt; merge(sort(splitListIn2(aList)), sort(splitListIn2(bList))) &#125; def splitListIn2(list: List[Int]): (List[Int], List[Int]) = list match &#123; case Nil =&gt; (Nil, Nil) case _ =&gt; val mid = list.length / 2 list.splitAt(mid) // (list.slice(0, mid), list.slice(mid, list.length)) &#125; sort(splitListIn2(list))&#125; 选择排序-n2 思路从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。 代码1234567891011121314def selectSort(list: List[Int]): List[Int] = &#123; @scala.annotation.tailrec def select(list: List[Int], remains: List[Int], sorted: List[Int]): List[Int] = list match &#123; case head :: Nil =&gt; if (remains.nonEmpty) select(remains, Nil, head :: sorted) else head :: sorted case h1 :: h2 :: tail =&gt; if (h1 &gt; h2) select(h1 :: tail, h2 :: remains, sorted) else select(h2 :: tail, h1 :: remains, sorted) &#125; select(list, Nil, Nil)&#125;","raw":null,"content":null,"categories":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/categories/scala/"}],"tags":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/tags/scala/"},{"name":"algo","slug":"algo","permalink":"https://freehubs.github.io/tags/algo/"},{"name":"offer","slug":"offer","permalink":"https://freehubs.github.io/tags/offer/"}]},{"title":"hexo next 设置gitalk评论系统","slug":"hexo-next-设置gitalk评论系统","date":"2020-02-22T13:03:53.000Z","updated":"2020-02-22T13:03:53.000Z","comments":true,"path":"2020/02/22/hexo-next-设置gitalk评论系统/","link":"","permalink":"https://freehubs.github.io/2020/02/22/hexo-next-设置gitalk评论系统/","excerpt":"\n\n            简介\n          \n\n如何申请gitalk应用\n\n在next主题中设置\n\n初始化\n","text":"简介 如何申请gitalk应用 在next主题中设置 初始化 申请gitalk应用 在Github中申请gitalk应用：https://github.com/settings/applications/new 注册时候，会返回client_id,client_secret等信息，之后会用到。 Next主题中设置 打开Next主题的配置文件_config.yml ，找到gitalk 配置： 1234567891011121314# Gitalk# For more information: https://gitalk.github.io, https://github.com/gitalk/gitalkgitalk: enable: true github_id: github_user_name # GitHub repo owner repo: github_user_name.github.io # Repository name to store issues client_id: # GitHub Application Client ID client_secret: # GitHub Application Client Secret admin_user: github_user_name # GitHub repo owner and collaborators, only these guys can initialize gitHub issues distraction_free_mode: true # Facebook-like distraction free mode # Gitalk's display language depends on user's browser or system environment # If you want everyone visiting your site to see a uniform language, you can set a force language value # Available values: en | es-ES | fr | ru | zh-CN | zh-TW language: zh-CN (默认是根据系统环境适配语言) 初始化 启用gitalk之后，接下来做初始化。注意，找一篇标题不长的文章，下拉到最后按照提示进行Github关联即可。如果标题过长，会初始化失败。","raw":null,"content":null,"categories":[{"name":"blog","slug":"blog","permalink":"https://freehubs.github.io/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://freehubs.github.io/tags/blog/"},{"name":"gitalk","slug":"gitalk","permalink":"https://freehubs.github.io/tags/gitalk/"}]},{"title":"hexo new 自动打开编辑器","slug":"hexo-new-自动打开编辑器","date":"2020-02-22T02:17:06.000Z","updated":"2020-02-22T02:17:06.000Z","comments":true,"path":"2020/02/22/hexo-new-自动打开编辑器/","link":"","permalink":"https://freehubs.github.io/2020/02/22/hexo-new-自动打开编辑器/","excerpt":"\n            简介\n          \n使用hexo new新建文档的时候，自动打开文档编辑器编辑新建的文档。","text":"简介 使用hexo new新建文档的时候，自动打开文档编辑器编辑新建的文档。 部署 在hexo根目录下新建scripts文件夹，并新建event.js文件，编辑： 1234var exec = require('child_process').exec;hexo.on('new', function(data)&#123; exec('open -a \"文档编辑器的绝对路径.app\" ' + data.path);&#125;); 编辑模版 在hexo根目录下的scaffolds文件夹内，新建或者编辑post.md: 123456789101112---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;updated: &#123;&#123; date &#125;&#125;tags:- categories:- ---blabla... 使用 新建文档时，执行hexo new &quot;this is new file title&quot;即可。","raw":null,"content":null,"categories":[{"name":"blog","slug":"blog","permalink":"https://freehubs.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://freehubs.github.io/tags/hexo/"}]},{"title":"八种解决 Spark 数据倾斜的方法","slug":"八种解决Spark数据倾斜的方法","date":"2020-02-21T22:25:51.000Z","updated":"2020-02-21T22:25:51.000Z","comments":true,"path":"2020/02/21/八种解决Spark数据倾斜的方法/","link":"","permalink":"https://freehubs.github.io/2020/02/21/八种解决Spark数据倾斜的方法/","excerpt":"\n            转自「过往记忆微信公众号」。\n          \n什么是数据倾斜对 Spark/Hadoop 这样的分布式大数据系统来讲，数据量大并不可怕，可怕的是数据倾斜。\n对于分布式系统而言，理想情况下，随着系统规模（节点数量）的增加，应用整体耗时线性下降。如果一台机器处理一批大量数据需要120分钟，当机器数量增加到3台时，理想的耗时为120 / 3 = 40分钟。但是，想做到分布式情况下每台机器执行时间是单机时的1 / N，就必须保证每台机器的任务量相等。不幸的是，很多时候，任务的分配是不均匀的，甚至不均匀到大部分任务被分配到个别机器上，其它大部分机器所分配的任务量只占总得的小部分。比如一台机器负责处理 80% 的任务，另外两台机器各处理 10% 的任务。\n『不患多而患不均』，这是分布式环境下最大的问题。意味着计算能力不是线性扩展的，而是存在短板效应: 一个 Stage 所耗费的时间，是由最慢的那个 Task 决定。\n由于同一个 Stage 内的所有 task 执行相同的计算，在排除不同计算节点计算能力差异的前提下，不同 task 之间耗时的差异主要由该 task 所处理的数据量决定。所以，要想发挥分布式系统并行计算的优势，就必须解决数据倾斜问题。","text":"转自「过往记忆微信公众号」。 什么是数据倾斜对 Spark/Hadoop 这样的分布式大数据系统来讲，数据量大并不可怕，可怕的是数据倾斜。 对于分布式系统而言，理想情况下，随着系统规模（节点数量）的增加，应用整体耗时线性下降。如果一台机器处理一批大量数据需要120分钟，当机器数量增加到3台时，理想的耗时为120 / 3 = 40分钟。但是，想做到分布式情况下每台机器执行时间是单机时的1 / N，就必须保证每台机器的任务量相等。不幸的是，很多时候，任务的分配是不均匀的，甚至不均匀到大部分任务被分配到个别机器上，其它大部分机器所分配的任务量只占总得的小部分。比如一台机器负责处理 80% 的任务，另外两台机器各处理 10% 的任务。 『不患多而患不均』，这是分布式环境下最大的问题。意味着计算能力不是线性扩展的，而是存在短板效应: 一个 Stage 所耗费的时间，是由最慢的那个 Task 决定。 由于同一个 Stage 内的所有 task 执行相同的计算，在排除不同计算节点计算能力差异的前提下，不同 task 之间耗时的差异主要由该 task 所处理的数据量决定。所以，要想发挥分布式系统并行计算的优势，就必须解决数据倾斜问题。 数据倾斜的危害当出现数据倾斜时，小量任务耗时远高于其它任务，从而使得整体耗时过大，未能充分发挥分布式系统的并行计算优势。 另外，当发生数据倾斜时，部分任务处理的数据量过大，可能造成内存不足使得任务失败，并进而引进整个应用失败。 数据倾斜的现象当发现如下现象时，十有八九是发生数据倾斜了: 绝大多数 task 执行得都非常快，但个别 task 执行极慢，整体任务卡在某个阶段不能结束。 原本能够正常执行的 Spark 作业，某天突然报出 OOM（内存溢出）异常，观察异常栈，是我们写的业务代码造成的。这种情况比较少见。 TIPS 在 Spark streaming 程序中，数据倾斜更容易出现，特别是在程序中包含一些类似 sql 的 join、group 这种操作的时候。因为 Spark Streaming 程序在运行的时候，我们一般不会分配特别多的内存，因此一旦在这个过程中出现一些数据倾斜，就十分容易造成 OOM。 数据倾斜的原因在进行 shuffle 的时候，必须将各个节点上相同的 key 拉取到某个节点上的一个 task 来进行处理，比如按照 key 进行聚合或 join 等操作。此时如果某个 key 对应的数据量特别大的话，就会发生数据倾斜。比如大部分 key 对应10条数据，但是个别 key 却对应了100万条数据，那么大部分 task 可能就只会分配到10条数据，然后1秒钟就运行完了；但是个别 task 可能分配到了100万数据，要运行一两个小时。 因此出现数据倾斜的时候，Spark 作业看起来会运行得非常缓慢，甚至可能因为某个 task 处理的数据量过大导致内存溢出。 问题发现与定位通过 Spark Web UI通过 Spark Web UI 来查看当前运行的 stage 各个 task 分配的数据量（Shuffle Read Size/Records），从而进一步确定是不是 task 分配的数据不均匀导致了数据倾斜。 知道数据倾斜发生在哪一个 stage 之后，接着我们就需要根据 stage 划分原理，推算出来发生倾斜的那个 stage 对应代码中的哪一部分，这部分代码中肯定会有一个 shuffle 类算子。可以通过 countByKey 查看各个 key 的分布。 TIPS 数据倾斜只会发生在 shuffle 过程中。这里给大家罗列一些常用的并且可能会触发 shuffle 操作的算子: distinct、groupByKey、reduceByKey、aggregateByKey、join、cogroup、repartition 等。出现数据倾斜时，可能就是你的代码中使用了这些算子中的某一个所导致的。 通过 key 统计也可以通过抽样统计 key 的出现次数验证。 由于数据量巨大，可以采用抽样的方式，对数据进行抽样，统计出现的次数，根据出现次数大小排序取出前几个: 12345df.select(\"key\").sample(false, 0.1) // 数据采样 .(k =&gt; (k, 1)).reduceBykey(_ + _) // 统计 key 出现的次数 .map(k =&gt; (k._2, k._1)).sortByKey(false) // 根据 key 出现次数进行排序 .take(10) // 取前 10 个。 如果发现多数数据分布都较为平均，而个别数据比其他数据大上若干个数量级，则说明发生了数据倾斜。 如何缓解数据倾斜基本思路 业务逻辑: 我们从业务逻辑的层面上来优化数据倾斜，比如要统计不同城市的订单情况，那么我们单独对这一线城市来做 count，最后和其它城市做整合。 程序实现: 比如说在 Hive 中，经常遇到 count（distinct）操作，这样会导致最终只有一个 reduce，我们可以先 group 再在外面包一层 count，就可以了；在 Spark 中使用 reduceByKey 替代 groupByKey 等。 参数调优: Hadoop 和 Spark 都自带了很多的参数和机制来调节数据倾斜，合理利用它们就能解决大部分问题。 思路1. 过滤异常数据如果导致数据倾斜的 key 是异常数据，那么简单的过滤掉就可以了。 首先要对 key 进行分析，判断是哪些 key 造成数据倾斜。具体方法上面已经介绍过了，这里不赘述。 然后对这些 key 对应的记录进行分析: 空值或者异常值之类的，大多是这个原因引起 无效数据，大量重复的测试数据或是对结果影响不大的有效数据 有效数据，业务导致的正常数据分布 解决方案 对于第 1，2 种情况，直接对数据进行过滤即可。 第3种情况则需要特殊的处理，具体我们下面详细介绍。 思路2. 提高 shuffle 并行度Spark 在做 Shuffle 时，默认使用 HashPartitioner（非 Hash Shuffle）对数据进行分区。如果并行度设置的不合适，可能造成大量不相同的 Key 对应的数据被分配到了同一个 Task 上，造成该 Task 所处理的数据远大于其它 Task，从而造成数据倾斜。 如果调整 Shuffle 时的并行度，使得原本被分配到同一 Task 的不同 Key 发配到不同 Task 上处理，则可降低原 Task 所需处理的数据量，从而缓解数据倾斜问题造成的短板效应。 （1）操作流程 RDD 操作 可在需要 Shuffle 的操作算子上直接设置并行度或者使用 spark.default.parallelism 设置。如果是 Spark SQL，还可通过 SET spark.sql.shuffle.partitions=[num_tasks] 设置并行度。默认参数由不同的 Cluster Manager 控制。 dataFrame 和 sparkSql 可以设置 spark.sql.shuffle.partitions=[num_tasks] 参数控制 shuffle 的并发度，默认为200。 （2）适用场景 大量不同的 Key 被分配到了相同的 Task 造成该 Task 数据量过大。 （3）解决方案 调整并行度。一般是增大并行度，但有时如减小并行度也可达到效果。 （4）优势 实现简单，只需要参数调优。可用最小的代价解决问题。一般如果出现数据倾斜，都可以通过这种方法先试验几次，如果问题未解决，再尝试其它方法。 （5）劣势 适用场景少，只是让每个 task 执行更少的不同的key。无法解决个别key特别大的情况造成的倾斜，如果某些 key 的大小非常大，即使一个 task 单独执行它，也会受到数据倾斜的困扰。并且该方法一般只能缓解数据倾斜，没有彻底消除问题。从实践经验来看，其效果一般。 TIPS 可以把数据倾斜类比为 hash 冲突。提高并行度就类似于 提高 hash 表的大小。 思路3. 自定义 Partitioner（1）原理 使用自定义的 Partitioner（默认为 HashPartitioner），将原本被分配到同一个 Task 的不同 Key 分配到不同 Task。 例如，我们在 groupByKey 算子上，使用自定义的 Partitioner: 1234567891011121314151617.groupByKey(new Partitioner() &#123; @Override public int numPartitions() &#123; return 12; &#125; @Override public int getPartition(Object key) &#123; int id = Integer.parseInt(key.toString()); if(id &gt;= 9500000 &amp;&amp; id &lt;= 9500084 &amp;&amp; ((id - 9500000) % 12) == 0) &#123; return (id - 9500000) / 12; &#125; else &#123; return id % 12; &#125; &#125;&#125;) TIPS 这个做法相当于自定义 hash 表的 哈希函数。 （2）适用场景 大量不同的 Key 被分配到了相同的 Task 造成该 Task 数据量过大。 （3）解决方案 使用自定义的 Partitioner 实现类代替默认的 HashPartitioner，尽量将所有不同的 Key 均匀分配到不同的 Task 中。 （4）优势 不影响原有的并行度设计。如果改变并行度，后续 Stage 的并行度也会默认改变，可能会影响后续 Stage。 （5）劣势 适用场景有限，只能将不同 Key 分散开，对于同一 Key 对应数据集非常大的场景不适用。效果与调整并行度类似，只能缓解数据倾斜而不能完全消除数据倾斜。而且需要根据数据特点自定义专用的 Partitioner，不够灵活。 思路4. Reduce 端 Join 转化为 Map 端 Join通过 Spark 的 Broadcast 机制，将 Reduce 端 Join 转化为 Map 端 Join，这意味着 Spark 现在不需要跨节点做 shuffle 而是直接通过本地文件进行 join，从而完全消除 Shuffle 带来的数据倾斜。 12from pyspark.sql.functions import broadcastresult = broadcast(A).join(B, [\"join_col\"], \"left\") 其中 A 是比较小的 dataframe 并且能够整个存放在 executor 内存中。 （1）适用场景 参与Join的一边数据集足够小，可被加载进 Driver 并通过 Broadcast 方法广播到各个 Executor 中。 （2）解决方案 在 Java/Scala 代码中将小数据集数据拉取到 Driver，然后通过 Broadcast 方案将小数据集的数据广播到各 Executor。或者在使用 SQL 前，将 Broadcast 的阈值调整得足够大，从而使 Broadcast 生效。进而将 Reduce Join 替换为 Map Join。 （3）优势 避免了 Shuffle，彻底消除了数据倾斜产生的条件，可极大提升性能。 （4）劣势 因为是先将小数据通过 Broadcase 发送到每个 executor 上，所以需要参与 Join 的一方数据集足够小，并且主要适用于 Join 的场景，不适合聚合的场景，适用条件有限。 NOTES 使用Spark SQL时需要通过 SET spark.sql.autoBroadcastJoinThreshold=104857600 将 Broadcast 的阈值设置得足够大，才会生效。 思路5. 拆分 join 再 union思路很简单，就是将一个 join 拆分成 倾斜数据集 Join 和 非倾斜数据集 Join，最后进行 union: 对包含少数几个数据量过大的 key 的那个 RDD (假设是 leftRDD)，通过 sample 算子采样出一份样本来，然后统计一下每个 key 的数量，计算出来数据量最大的是哪几个 key。具体方法上面已经介绍过了，这里不赘述。 然后将这 k 个 key 对应的数据从 leftRDD 中单独过滤出来，并给每个 key 都打上 1~n 以内的随机数作为前缀，形成一个单独的 leftSkewRDD；而不会导致倾斜的大部分 key 形成另外一个 leftUnSkewRDD。 接着将需要 join 的另一个 rightRDD，也过滤出来那几个倾斜 key 并通过 flatMap 操作将该数据集中每条数据均转换为 n 条数据（这 n 条数据都按顺序附加一个 0~n 的前缀），形成单独的 rightSkewRDD；不会导致倾斜的大部分 key 也形成另外一个 rightUnSkewRDD。 现在将 leftSkewRDD 与 膨胀 n 倍的 rightSkewRDD 进行 join，且在 Join 过程中将随机前缀去掉，得到倾斜数据集的 Join 结果 skewedJoinRDD。注意到此时我们已经成功将原先相同的 key 打散成 n 份，分散到多个 task 中去进行 join 了。 对 leftUnSkewRDD 与 rightUnRDD 进行Join，得到 Join 结果 unskewedJoinRDD。 通过 union 算子将 skewedJoinRDD 与 unskewedJoinRDD 进行合并，从而得到完整的 Join 结果集。 TIPS rightRDD 与倾斜 Key 对应的部分数据，需要与随机前缀集 (1~n) 作笛卡尔乘积 (即将数据量扩大 n 倍），从而保证无论数据倾斜侧倾斜 Key 如何加前缀，都能与之正常 Join。 skewRDD 的 join 并行度可以设置为 n * k (k 为 topSkewkey 的个数)。 由于倾斜Key与非倾斜Key的操作完全独立，可并行进行。 （1）适用场景 两张表都比较大，无法使用 Map 端 Join。其中一个 RDD 有少数几个 Key 的数据量过大，另外一个 RDD 的 Key 分布较为均匀。 （2）解决方案 将有数据倾斜的 RDD 中倾斜 Key 对应的数据集单独抽取出来加上随机前缀，另外一个 RDD 每条数据分别与随机前缀结合形成新的RDD（相当于将其数据增到到原来的N倍，N即为随机前缀的总个数），然后将二者Join并去掉前缀。然后将不包含倾斜Key的剩余数据进行Join。最后将两次Join的结果集通过union合并，即可得到全部Join结果。 （3）优势 相对于 Map 则 Join，更能适应大数据集的 Join。如果资源充足，倾斜部分数据集与非倾斜部分数据集可并行进行，效率提升明显。且只针对倾斜部分的数据做数据扩展，增加的资源消耗有限。 （4）劣势 如果倾斜 Key 非常多，则另一侧数据膨胀非常大，此方案不适用。而且此时对倾斜 Key 与非倾斜 Key 分开处理，需要扫描数据集两遍，增加了开销。 思路6. 大表 key 加盐，小表扩大 N 倍 jion如果出现数据倾斜的 Key 比较多，上一种方法将这些大量的倾斜 Key 分拆出来，意义不大。此时更适合直接对存在数据倾斜的数据集全部加上随机前缀，然后对另外一个不存在严重数据倾斜的数据集整体与随机前缀集作笛卡尔乘积（即将数据量扩大N倍）。 其实就是上一个方法的特例或者简化。少了拆分，也就没有 union。 （1）适用场景 一个数据集存在的倾斜 Key 比较多，另外一个数据集数据分布比较均匀。 （2）优势 对大部分场景都适用，效果不错。 （3）劣势 需要将一个数据集整体扩大 N 倍，会增加资源消耗。 思路7. map 端先局部聚合在 map 端加个 combiner 函数进行局部聚合。加上 combiner 相当于提前进行 reduce ,就会把一个 mapper 中的相同 key 进行聚合，减少 shuffle 过程中数据量 以及 reduce 端的计算量。这种方法可以有效的缓解数据倾斜问题，但是如果导致数据倾斜的 key 大量分布在不同的 mapper 的时候，这种方法就不是很有效了。 TIPS 使用 reduceByKey 而不是 groupByKey。 思路8. 加盐局部聚合 + 去盐全局聚合这个方案的核心实现思路就是进行两阶段聚合。第一次是局部聚合，先给每个 key 都打上一个 1~n 的随机数，比如 3 以内的随机数，此时原先一样的 key 就变成不一样的了，比如 (hello, 1) (hello, 1) (hello, 1) (hello, 1) (hello, 1)，就会变成 (1_hello, 1) (3_hello, 1) (2_hello, 1) (1_hello, 1) (2_hello, 1)。接着对打上随机数后的数据，执行 reduceByKey 等聚合操作，进行局部聚合，那么局部聚合结果，就会变成了 (1_hello, 2) (2_hello, 2) (3_hello, 1)。然后将各个 key 的前缀给去掉，就会变成 (hello, 2) (hello, 2) (hello, 1)，再次进行全局聚合操作，就可以得到最终结果了，比如 (hello, 5)。 123456789def antiSkew(): RDD[(String, Int)] = &#123; val SPLIT = \"-\" val prefix = new Random().nextInt(10) pairs.map(t =&gt; ( prefix + SPLIT + t._1, 1)) .reduceByKey((v1, v2) =&gt; v1 + v2) .map(t =&gt; (t._1.split(SPLIT)(1), t2._2)) .reduceByKey((v1, v2) =&gt; v1 + v2)&#125; 不过进行两次 mapreduce，性能稍微比一次的差些。 Hadoop 中的数据倾斜Hadoop 中直接贴近用户使用的是 Mapreduce 程序和 Hive 程序，虽说 Hive 最后也是用 MR 来执行（至少目前 Hive 内存计算并不普及），但是毕竟写的内容逻辑区别很大，一个是程序，一个是Sql，因此这里稍作区分。 Hadoop 中的数据倾斜主要表现在 ruduce 阶段卡在99.99%，一直99.99%不能结束。 这里如果详细的看日志或者和监控界面的话会发现: 有一个多几个 reduce 卡住 各种 container报错 OOM 读写的数据量极大，至少远远超过其它正常的 reduce 伴随着数据倾斜，会出现任务被 kill 等各种诡异的表现。 经验: Hive的数据倾斜，一般都发生在 Sql 中 Group 和 On 上，而且和数据逻辑绑定比较深。 优化方法 这里列出来一些方法和思路，具体的参数和用法在官网看就行了。 map join 方式 count distinct 的操作，先转成 group，再 count 参数调优 set hive.map.aggr=true set hive.groupby.skewindata=true left semi jion 的使用 设置 map 端输出、中间结果压缩。（不完全是解决数据倾斜的问题，但是减少了 IO 读写和网络传输，能提高很多效率） 说明 hive.map.aggr=true: 在map中会做部分聚集操作，效率更高但需要更多的内存。 hive.groupby.skewindata=true: 数据倾斜时负载均衡，当选项设定为true，生成的查询计划会有两个MRJob。第一个MRJob 中，Map的输出结果集合会随机分布到Reduce中，每个Reduce做部分聚合操作，并输出结果，这样处理的结果是相同的GroupBy Key有可能被分发到不同的Reduce中，从而达到负载均衡的目的；第二个MRJob再根据预处理的数据结果按照GroupBy Key分布到Reduce中（这个过程可以保证相同的GroupBy Key被分布到同一个Reduce中），最后完成最终的聚合操作。 参考文章 Spark性能优化之道——解决Spark数据倾斜（Data Skew）的N种姿势 漫谈千亿级数据优化实践：数据倾斜（纯干货） 解决spark中遇到的数据倾斜问题","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/categories/spark/"}],"tags":[{"name":"hive","slug":"hive","permalink":"https://freehubs.github.io/tags/hive/"},{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"},{"name":"offer","slug":"offer","permalink":"https://freehubs.github.io/tags/offer/"}]},{"title":"Error:scalac:Stackoverflow","slug":"Error:scalac:Stackoverflow","date":"2020-02-21T19:25:51.000Z","updated":"2020-02-21T19:25:51.000Z","comments":true,"path":"2020/02/21/Error:scalac:Stackoverflow/","link":"","permalink":"https://freehubs.github.io/2020/02/21/Error:scalac:Stackoverflow/","excerpt":"","text":"Error:scalac: Error: org.jetbrains.jps.incremental.scala.remote.ServerExceptionjava.lang.StackOverflowError 描述IDEA执行Scala程序时，报错： 12345678910111213Error:scalac: Error: org.jetbrains.jps.incremental.scala.remote.ServerExceptionjava.lang.StackOverflowError at scala.tools.nsc.typechecker.Typers$Typer.typedSelectOrSuperCall$1(Typers.scala:4833) at scala.tools.nsc.typechecker.Typers$Typer.typedInAnyMode$1(Typers.scala:5371) at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5387) at scala.tools.nsc.typechecker.Typers$Typer.runTyper$1(Typers.scala:5423) at scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedInternal(Typers.scala:5450) at scala.tools.nsc.typechecker.Typers$Typer.body$2(Typers.scala:5397) at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5401) at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$102.apply(Typers.scala:4559) at scala.tools.nsc.typechecker.Typers$Typer$$anonfun$102.apply(Typers.scala:4559) at scala.tools.nsc.typechecker.Typers$Typer.silent(Typers.scala:680) ... 解决方式在IDEA关于的Scala的配置中，设置JVM参数。 最大堆内存：4096 JVM：-server -Xss256m 重启IDEA","raw":null,"content":null,"categories":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/categories/scala/"}],"tags":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/tags/scala/"},{"name":"idea","slug":"idea","permalink":"https://freehubs.github.io/tags/idea/"},{"name":"error","slug":"error","permalink":"https://freehubs.github.io/tags/error/"}]},{"title":"spark写文件优化","slug":"spark写文件优化","date":"2020-02-20T23:25:51.000Z","updated":"2020-03-11T16:25:51.000Z","comments":true,"path":"2020/02/20/spark写文件优化/","link":"","permalink":"https://freehubs.github.io/2020/02/20/spark写文件优化/","excerpt":"\n简介\ninsertInto 写入表\nsave(path) 写为文件\nrdd.saveAsHadoopFile 写为文件\n","text":"简介 insertInto 写入表 save(path) 写为文件 rdd.saveAsHadoopFile 写为文件 优化 众所周知，hadoop写入文件有两种算法，算法一和算法二。分别介绍下算法一和算法二的区别以及使用场景。建议将算法设置为V2. 算法一hadoop 3.0 以下版本默认采用该算法。该段转载自：过往记忆 设置参数为： 1mapreduce.fileoutputcommitter.algorithm.version = 1 此种算法写入文件的过程为： 先写入临时目录 将临时目录中的数据移动到对应的task中 将task中的数据移动到最终的输出目录 算法二设置参数为： 1mapreduce.fileoutputcommitter.algorithm.version = 2 此种算法写入文件的过程为： 先写入临时目录 将临时目录中的数据移动到对应的task中 将临时目录中的数据直接移动到最终的输出目录 设置conf/spark-defaults.conf全局设置 1spark.hadoop.mapreduce.fileoutputcommitter.algorithm.version 2 程序：spark.confJob级别 1spark.conf.set(\"mapreduce.fileoutputcommitter.algorithm.version\", \"2\") 程序：DataSet.writeJob级别 1dataset.write.option(\"mapreduce.fileoutputcommitter.algorithm.version\", \"2\") insertInto 直接将dataframe写入hive表中。 样例1df.write.mode(\"append\").insertInto(\"tbl_name\") 问题 如果设置的shuffle数量太多，会造成小文件的问题 如果设置的shuffle数量太少，会造成写入性能慢的问题 最佳实践 设置合适的shuffle数量进行写入 写入之后再合并小文件 save文件 将dataframe先写入文件中，在将hive表与文件关联起来。 样例12345// 1. 写为文件，将文件保存在表的目录下df.write.partitionBy(\"org_id\", \"log_date\").mode(\"append\").option(\"compression\", \"snappy\").format(\"orc\").save(resPath)// 2. 刷新表的元数据信息spark.sql(\"msck repair table odl.test\").show() 问题 如果设置的shuffle数量太多，会造成小文件的问题 如果设置的shuffle数量太少，会造成写入性能慢的问题 saveAsHadoopFile 按照自定义分区标准，将rdd写为文件，再load到hive表中。 样例12345678910111213141516171819202122232425262728293031323334353637383940414243import org.apache.hadoop.io.&#123;LongWritable, Text&#125;import org.apache.hadoop.mapred.TextInputFormatimport org.apache.hadoop.mapred.lib.MultipleTextOutputFormatimport org.apache.spark.HashPartitioner /** * Spark多文件输出(MultipleTextOutputFormat) * 覆写 MultipleTextOutputFormat方法 */ class RDDMultipleTextOutputFormat extends MultipleTextOutputFormat[Any, Any] &#123; //管理key值，作为文件名，有/ 则为目录 override def generateFileNameForKeyValue(key: Any, value: Any, name: String): String = &#123; key.asInstanceOf[String] + \"/\" + name &#125; //管理value值，是否将key写入文件 override def generateActualKey(key: Any, value: Any): AnyRef = null &#125; /** * 保存为文件 */ def writeHadoopFile(spark: SparkSession, path: String, resPath: String, partitions: Int): Unit = &#123; val srcDf = spark.read.option(\"header\", \"true\").csv(path) srcDf.rdd.map(row =&gt; &#123; val org_id = row.getAs(\"org_id\").asInstanceOf[String] val log_date = CommonUtil.dateFormat(row.getAs(\"log_date\").asInstanceOf[String], \"yyyy\") var partitionName = \"\" if (org_id != null) &#123; partitionName = partitionName + \"org_id=\" + org_id + \"/\" if (log_date != null) &#123; partitionName = partitionName + \"log_date=\" + log_date + \"/\" &#125; &#125; (partitionName, row.mkString(\"\\t\")) &#125;).partitionBy(new HashPartitioner(partitions)) .saveAsHadoopFile(resPath, classOf[String], classOf[String], classOf[RDDMultipleTextOutputFormat]) &#125; // 执行load文件操作 spark.sql(\"LOAD DATA [LOCAL] INPATH 'filepath' [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1=val1, partcol2=val2 ...)]\").show() 问题 本地执行没有问题，但在集群上运行时会出现文件已存在的问题，暂未解决。","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"},{"name":"优化","slug":"优化","permalink":"https://freehubs.github.io/tags/优化/"}]},{"title":"Scala三种退出循环的方式","slug":"Scala三种退出循环的方式","date":"2020-02-13T23:13:00.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2020/02/13/Scala三种退出循环的方式/","link":"","permalink":"https://freehubs.github.io/2020/02/13/Scala三种退出循环的方式/","excerpt":"\n\n            基于Boolean类型的控制变量使用嵌套函数以及return使用Breaks类的break方法\n          ","text":"基于Boolean类型的控制变量使用嵌套函数以及return使用Breaks类的break方法 基于Boolean类型的控制变量分别针对while循环和for循环进行举例。 While循环1234567891011121314/** * 基于boolean类型的控制变量 * While循环 */def fun1While: Unit = &#123; var start = 0 var flag = true while (flag) &#123; if (start == 5) flag = false //继续执行后面的 println(start) start += 1 &#125;&#125; For循环123456789101112/** * 基于boolean类型的控制变量 * For循环，加了高级守卫 */def fun1For: Unit = &#123; var flag = true for (i &lt;- 0 to 10 if flag) &#123; if (i == 5) flag = false //继续执行后面的 println(i) &#125;&#125; 使用嵌套函数以及return1234567891011121314def fun2: Unit = &#123; var start = 0 def innerFun: Unit = &#123; for (i &lt;- 0 to 10) &#123; //立即返回 if (i == 5) return start += 1 &#125; &#125; innerFun println(start)&#125; 使用Breaks类的break方法1234567891011import scala.util.control.Breaks._def fun3: Unit = &#123; breakable&#123; for(i &lt;- 0 to 10)&#123; //立即返回 if(i == 5) break() println(i) &#125; &#125; &#125;","raw":null,"content":null,"categories":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/categories/scala/"}],"tags":[{"name":"scala","slug":"scala","permalink":"https://freehubs.github.io/tags/scala/"}]},{"title":"hexo+GitHub+Action自动化部署","slug":"hexo+Github+Action自动化部署","date":"2020-02-13T10:44:00.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2020/02/13/hexo+Github+Action自动化部署/","link":"","permalink":"https://freehubs.github.io/2020/02/13/hexo+Github+Action自动化部署/","excerpt":"\n\n            使用GitHub Actions操作进行Hexo托管在GitHub上面的博客自动化部署。\n          ","text":"使用GitHub Actions操作进行Hexo托管在GitHub上面的博客自动化部署。 GitHub ActionsGithub的自动化测试/部署工作流。 配置流程使用Github Actions进行自动化部署，需要进行以下几步骤： 1.获取ssh密钥本地电脑生成ssh密钥（公、私）。 1ssh-keygen -t rsa -b 4096 -f ~/.ssh/github-actions-deploy 私钥： 1~/.ssh/github-actions-deploy/xxx 公钥： 1~/.ssh/github-actions-deploy/xxx.pub 2.配置GitHub在Github的个人设置里面，设置SSH公钥。命名随意。 3.配置仓库在需要持续化集成的仓库设置里面，设置SSH私钥，命名ACTION_DEPLOY_KEY.（脚本中会用到） 4.配置工作流脚本进入需要配置的仓库，进入Actions里面，新建workflow文件。 脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142name: Deploy Blogon: [push] # 当有新push时运行jobs: build: # 一项叫做build的任务 runs-on: ubuntu-latest # 在最新版的Ubuntu系统下运行 steps: - name: Checkout # 将仓库内master分支的内容下载到工作目录 uses: actions/checkout@v1 # 脚本来自 https://github.com/actions/checkout - name: Use Node.js 10.x # 配置Node环境 uses: actions/setup-node@v1 # 配置脚本来自 https://github.com/actions/setup-node with: node-version: \"10.x\" - name: Setup Hexo env env: ACTION_DEPLOY_KEY: $&#123;&#123; secrets.ACTION_DEPLOY_KEY &#125;&#125; run: | # set up private key for deploy mkdir -p ~/.ssh/ echo \"$ACTION_DEPLOY_KEY\" | tr -d '\\r' &gt; ~/.ssh/id_rsa # 配置秘钥 chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts # set git infomation git config --global user.name 'github-user-name' # 换成你自己的邮箱和名字 git config --global user.email 'github-email@xxx.com' # install dependencies npm i -g hexo-cli # 安装hexo npm i - name: install plugin run: | npm install hexo-deployer-git --save npm install hexo-generator-search --save npm install hexo-generator-feed --save - name: Deploy run: | hexo g -d 5.Hexo配置 上面是根据SSH来实现，在Hexo的配置文件_config.yml 中需要进行相关的配置。 需要选择SSH模式！ 1234deploy: type: git repo: 上面拷贝的信息(git@github.com:xxx) branch: master 其他选择之前是基于AppVeyor进行的持续集成：AppVeyor持续集成配置","raw":null,"content":null,"categories":[{"name":"blog","slug":"blog","permalink":"https://freehubs.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://freehubs.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://freehubs.github.io/tags/blog/"}]},{"title":"剑指offer","slug":"剑指offer","date":"2020-02-09T12:26:00.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2020/02/09/剑指offer/","link":"","permalink":"https://freehubs.github.io/2020/02/09/剑指offer/","excerpt":"","text":"参考链接CS-Notes","raw":null,"content":null,"categories":[{"name":"offer","slug":"offer","permalink":"https://freehubs.github.io/categories/offer/"}],"tags":[{"name":"offer","slug":"offer","permalink":"https://freehubs.github.io/tags/offer/"}]},{"title":"hexo和next内置标签","slug":"hexo和next内置标签","date":"2020-02-06T12:26:00.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2020/02/06/hexo和next内置标签/","link":"","permalink":"https://freehubs.github.io/2020/02/06/hexo和next内置标签/","excerpt":"","text":"Note标签使用 12345678&#123;% note class_name %&#125; blabla &#123;% endnote %&#125;class_name: - default - primary - success - info - warning - danger 效果演示 default primary success info warning danger Tabs标签使用 123456789&#123;% tabs unique_name,default_index %&#125;&lt;!-- tab [tag_name] --&gt;这是tab1&lt;!-- endtab --&gt;&lt;!-- tab [tag_name] --&gt;这是tab2&lt;!-- endtab --&gt;...&#123;% endtabs %&#125; 效果演示 1234567891011&#123;% tabs code,1 %&#125;&lt;!-- tab java --&gt;java code&lt;!-- endtab --&gt;&lt;!-- tab scala --&gt;scala code&lt;!-- endtab --&gt;&lt;!-- tab python --&gt;python code&lt;!-- endtab --&gt;&#123;% endtabs %&#125; javascalapython12345public class Hello&#123; //&#125;12345object Hello&#123; //&#125;undefined Block QuotePerfect for adding quotes to your post, with optional author, source and title information. Alias: quote 123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; ExamplesNo arguments. Plain blockquote. 123&#123;% blockquote %&#125;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.&#123;% endblockquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. Quote from a book 123&#123;% blockquote David Levithan, Wide Awake %&#125;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&#123;% endblockquote %&#125; Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake Quote from Twitter 123&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;NEW: DevDocs now comes with syntax highlighting. http://devdocs.io&#123;% endblockquote %&#125; NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 Quote from an article on the web 123&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;Every interaction is both precious and an opportunity to delight.&#123;% endblockquote %&#125; Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing Code BlockUseful feature for adding code snippets to your post. Alias: code 123&#123;% codeblock [title] [lang:language] [url] [link text] [additional options] %&#125;code snippet&#123;% endcodeblock %&#125; Specify additional options in option:value format, e.g. line_number:false first_line:5. Extra Options Description Default line_number Show line number true highlight Enable code highlighting true first_line Specify the first line number 1 mark Line highlight specific line(s), each value separated by a comma. Specify number range using a dash Example: mark:1,4-7,10 will mark line 1, 4 to 7 and 10. wrap Wrap the code block in true ExamplesA plain code block 1234&#123;% codeblock %&#125;alert(&apos;Hello World!&apos;);&#123;% endcodeblock %&#125;alert(&apos;Hello World!&apos;); Specifying the language 1234&#123;% codeblock lang:objc %&#125;[rectangle setX: 10 y: 10 width: 20 height: 20];&#123;% endcodeblock %&#125;[rectangle setX: 10 y: 10 width: 20 height: 20]; Adding a caption to the code block 1234&#123;% codeblock Array.map %&#125;array.map(callback[, thisArg])&#123;% endcodeblock %&#125;Array.maparray.map(callback[, thisArg]) Adding a caption and a URL 123456&#123;% codeblock _.compact http://underscorejs.org/#compact Underscore.js %&#125;_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3]&#123;% endcodeblock %&#125;_.compactUnderscore.js_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] Backtick Code BlockThis is identical to using a code block, but instead uses three backticks to delimit the block. 1[language] [title] [url] [link text] code snippet Pull QuoteTo add pull quotes to your posts: 123&#123;% pullquote [class] %&#125;content&#123;% endpullquote %&#125; jsFiddleTo embed a jsFiddle snippet: 1&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125; GistTo embed a Gist snippet: 1&#123;% gist gist_id [filename] %&#125; iframeTo embed an iframe: 1&#123;% iframe url [width] [height] %&#125; ImageInserts an image with specified size. 1&#123;% img [class names] /path/to/image [width] [height] &apos;&quot;title text&quot; &quot;alt text&quot;&apos; %&#125; LinkInserts a link with target=&quot;_blank&quot; attribute. 1&#123;% link text url [external] [title] %&#125; Include CodeInserts code snippets in source/downloads/code folder. The folder location can be specified through the code_dir option in the config. 1&#123;% include_code [title] [lang:language] [from:line] [to:line] path/to/file %&#125; ExamplesEmbed the whole content of test.js 1&#123;% include_code lang:javascript test.js %&#125; Embed line 3 only 1&#123;% include_code lang:javascript from:3 to:3 test.js %&#125; Embed line 5 to 8 1&#123;% include_code lang:javascript from:5 to:8 test.js %&#125; Embed line 5 to the end of file 1&#123;% include_code lang:javascript from:5 test.js %&#125; Embed line 1 to 8 1&#123;% include_code lang:javascript to:8 test.js %&#125; YouTubeInserts a YouTube video. 1&#123;% youtube video_id %&#125; VimeoInserts a responsive or specified size Vimeo video. 1&#123;% vimeo video_id [width] [height] %&#125; Include PostsInclude links to other posts. 12&#123;% post_path filename %&#125;&#123;% post_link filename [title] [escape] %&#125; You can ignore permalink and folder information, like languages and dates, when using this tag. For instance: . This will work as long as the filename of the post is how-to-bake-a-cake.md, even if the post is located at source/posts/2015-02-my-family-holiday and has permalink 2018/en/how-to-bake-a-cake. You can customize the text to display, instead of displaying the post’s title. Using post_path inside Markdown syntax []() is not supported. Post’s title and custom text are escaped by default. You can use the escape option to disable escaping. For instance: Display title of the post. 1&#123;% post_link hexo-3-8-released %&#125; Hexo 3.8.0 Released Display custom text. 1&#123;% post_link hexo-3-8-released &apos;Link to a post&apos; %&#125; Link to a post Escape title. 1&#123;% post_link hexo-4-released &apos;How to use &lt;b&gt; tag in title&apos; %&#125; How to use tag in title Do not escape title. 1&#123;% post_link hexo-4-released &apos;&lt;b&gt;bold&lt;/b&gt; custom title&apos; false %&#125; bold custom title Include AssetsInclude post assets. 123&#123;% asset_path filename %&#125;&#123;% asset_img filename [title] %&#125;&#123;% asset_link filename [title] [escape] %&#125; RawIf certain content is causing processing issues in your posts, wrap it with the raw tag to avoid rendering errors. 123&#123;% raw %&#125;content&#123;% endraw %&#125; Post ExcerptUse text placed before the tag as an excerpt for the post. excerpt: value in the front-matter, if specified, will take precedent. Examples: 123Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;!-- more --&gt;Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Group PicturesUsage123456group-pictures.js&#123;% grouppicture [group]-[layout] %&#125;&#123;% endgrouppicture %&#125;&#123;% gp [group]-[layout] %&#125;&#123;% endgp %&#125;[group] : Total number of pictures to add in the group.[layout] : Default picture under the group to show. Examples12345678&#123;% grouppicture 6-3 %&#125; ![](/images/docs/github.png) ![](/images/docs/github.png) ![](/images/docs/github.png) ![](/images/docs/github.png) ![](/images/docs/github.png) ![](/images/docs/github.png)&#123;% endgrouppicture %&#125; PDFSettings12345next/_config.ymlpdf: enable: true # Default height height: 500px Usage12345pdf.js&#123;% pdf url [height] %&#125;[url] : Relative path to PDF file.[height] : Optional. Height of the PDF display element, e.g. 800px. Examples12&#123;% pdf https://example.com/sample.pdf %&#125;&#123;% pdf /path/to/your/file.pdf 600px %&#125; LabelUsage1234567label.js&#123;% label [class]@Text %&#125;[class] : default | primary | success | info | warning | danger. &apos;@Text&apos; can be specified with or without space E.g. &apos;success @text&apos; similar to &apos;success@text&apos;. If not specified, default class will be selected. Examples12345Lorem &#123;% label @ipsum %&#125; &#123;% label primary@dolor sit %&#125; amet, consectetur &#123;% label success@adipiscing elit, %&#125; sed &#123;% label info@do eiusmod %&#125; tempor incididunt ut labore et dolore magna aliqua.Ut enim *&#123;% label warning @ad %&#125;* minim veniam, quis **&#123;% label danger@nostrud %&#125;** exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.Duis aute irure dolor in reprehenderit in voluptate ~~&#123;% label default @velit %&#125;~~ &lt;mark&gt;esse&lt;/mark&gt; cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.","raw":null,"content":null,"categories":[{"name":"blog","slug":"blog","permalink":"https://freehubs.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://freehubs.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"https://freehubs.github.io/tags/next/"}]},{"title":"计算机基础知识","slug":"计算机基础知识","date":"2020-02-06T01:28:00.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2020/02/06/计算机基础知识/","link":"","permalink":"https://freehubs.github.io/2020/02/06/计算机基础知识/","excerpt":"","text":"目的不积跬步，何以至千里。 链接戳我查看基础知识","raw":null,"content":null,"categories":[{"name":"basic","slug":"basic","permalink":"https://freehubs.github.io/categories/basic/"}],"tags":[{"name":"algo","slug":"algo","permalink":"https://freehubs.github.io/tags/algo/"},{"name":"basic","slug":"basic","permalink":"https://freehubs.github.io/tags/basic/"},{"name":"network","slug":"network","permalink":"https://freehubs.github.io/tags/network/"}]},{"title":"Github作为图床","slug":"Github作为图床","date":"2020-02-06T00:56:00.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2020/02/06/Github作为图床/","link":"","permalink":"https://freehubs.github.io/2020/02/06/Github作为图床/","excerpt":"","text":"为什么使用Github 因为免费。 如何使用 因为目前的使用的是Mac电脑，在网上冲浪时了解上传的图床的工具，推荐较多的为一款叫ipic的软件，但是该软件： 免费版本只支持新浪微博 不支持Github作为图床 所以放弃使用该软件。 继续网上冲浪之后，了解到一款叫做picgo的软件，有两点吸引我： 开源 支持Github 链接 戳我了解PicGo","raw":null,"content":null,"categories":[{"name":"tools","slug":"tools","permalink":"https://freehubs.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://freehubs.github.io/tags/tools/"}]},{"title":"链表","slug":"链表","date":"2020-02-05T11:55:00.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2020/02/05/链表/","link":"","permalink":"https://freehubs.github.io/2020/02/05/链表/","excerpt":"\n            \n          ","text":"概念 链表不需要连续的内存，通过指针将零散的内存块关联起来。 数组与链表的比较最直观的比较是数组是连续的内存块，而链表不需要连续。 性能比较： 常见分类 常见的链表有单链表，双向链表，循环链表，双向循环链表等。 单链表顾名思义，单链表是单方向的，链表由数据结点和后继指针组成。 特点 循环链表 双向链表 双向循环链表 特性 编码 实现一个简单的单链表。 scalajavapython1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 简单的链表 /case class NodeTclass HiLinkedList[T &gt;: Null] &#123; var head: Node[T] = _ var tail: Node[T] = _ var size = 0 //添加结点 def add(data: T): Unit = &#123; if (head == null) &#123; head = Node(data, null) tail = head &#125; else &#123; val node = Node(data, null) tail.next = node tail = node &#125; size += 1 println(“Adding Action succeed！size is “, size) &#125; //查询结点 def find(data: T): Node[T] = &#123; var tmp = head while (tmp != null) &#123; println(“loop..”) println(tmp.data) if (tmp.data == data) &#123; return tmp &#125; else &#123; tmp = tmp.next &#125; &#125; null &#125; //删除结点 def remove(data: T): Node[T] = &#123; val node = find(data) var tmp = head if (tmp.data == data) &#123; head = tmp.next size -= 1 &#125; else &#123; if (node != null) &#123; while (tmp != null) &#123; println(“remove loop..”) if (tmp.next == node) &#123; tmp.next = node.next size -= 1 return node &#125; tmp = tmp.next &#125; &#125; &#125; node &#125;&#125;123// todo123Todo 样例 此处使用scala实现常见的链表样例。 LRU回文","raw":null,"content":null,"categories":[{"name":"algo","slug":"algo","permalink":"https://freehubs.github.io/categories/algo/"}],"tags":[{"name":"algo","slug":"algo","permalink":"https://freehubs.github.io/tags/algo/"}]},{"title":"数组","slug":"数组","date":"2020-02-05T11:50:00.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2020/02/05/数组/","link":"","permalink":"https://freehubs.github.io/2020/02/05/数组/","excerpt":"\n            \n          ","text":"概念 数组（Array）\\是一种**线性表**数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 特性 数组下标由0开始为什么？ 数组查找数据时的寻址公式为：start_address + n*data_block_size。 一方面是按照上述公式，如果下标由1开始，则公式为：start_address + (n-1)*data_block_size 每次寻址时会做一次 n-1的运算。 另一方面是历史原因，都是从0开始的。 快速查找根据下标随机查找，时间复杂度为O(1)。 插入、删除慢插入、删除会导致数组后续元素的后移，时间复杂度为O(n)。 编程","raw":null,"content":null,"categories":[{"name":"algo","slug":"algo","permalink":"https://freehubs.github.io/categories/algo/"}],"tags":[{"name":"algo","slug":"algo","permalink":"https://freehubs.github.io/tags/algo/"}]},{"title":"new 2020","slug":"new page","date":"2020-02-05T00:24:00.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2020/02/05/new page/","link":"","permalink":"https://freehubs.github.io/2020/02/05/new page/","excerpt":"","text":"欢迎👏阔别","raw":null,"content":null,"categories":[{"name":"think","slug":"think","permalink":"https://freehubs.github.io/categories/think/"}],"tags":[{"name":"think","slug":"think","permalink":"https://freehubs.github.io/tags/think/"}]},{"title":"航海王：狂热行动 ONE PIECE STAMPEDE","slug":"航海王：狂热行动 ONE PIECE STAMPEDE","date":"2019-10-22T23:25:51.000Z","updated":"2019-10-22T23:25:51.000Z","comments":true,"path":"2019/10/22/航海王：狂热行动 ONE PIECE STAMPEDE/","link":"","permalink":"https://freehubs.github.io/2019/10/22/航海王：狂热行动 ONE PIECE STAMPEDE/","excerpt":"","text":"海贼明星大乱斗，海贼王，我当定了！ 简介「航海王：狂热行动」是“航海王系列”第14部剧场版，也是「航海王」动画二十周年纪念之作。 以超新星为代表的众多航海家纷纷现身世界最大的航海家庆典——航海世博会。草帽航海团也收到了主办者费斯塔的邀请函，搭乘万里阳光号前往。原以为航海家们的狂热世博会只是为争夺“航海王罗杰留下的宝藏”，就在神秘宝藏争夺战如火如荼之际，阻挡在路飞等人面前的可怕威胁道格拉斯·巴雷特突然现身！暗藏阴谋的敌我混战一触即发。","raw":null,"content":null,"categories":[{"name":"life","slug":"life","permalink":"https://freehubs.github.io/categories/life/"}],"tags":[{"name":"movie","slug":"movie","permalink":"https://freehubs.github.io/tags/movie/"},{"name":"life","slug":"life","permalink":"https://freehubs.github.io/tags/life/"}]},{"title":"胜利即是正义","slug":"胜利即是正义","date":"2019-02-22T23:25:51.000Z","updated":"2019-02-22T23:25:51.000Z","comments":true,"path":"2019/02/22/胜利即是正义/","link":"","permalink":"https://freehubs.github.io/2019/02/22/胜利即是正义/","excerpt":"\n\n            日剧「胜利即是正义」，从律师的角度看正义。\n          ","text":"日剧「胜利即是正义」，从律师的角度看正义。 剧情简介三木律师事务所的菜鸟黛真知子（新垣结衣 饰）为了帮一起谋杀案的当事人洗刷清白，在社长秘书泽地（小池荣子 饰）的指点下，找到了传奇律师古美门研介（堺雅人 饰）。古美门拥有极高的辩护才能，为了赢得胜利不惜使用任何手段，他至今保持着骄人的全胜纪录，也曾经是三木（生濑胜久 饰） 麾下的得意门生。但是5年前的一起事件导致这两大律师界巨擘的决裂。看在巨额律师费的份上，古美门同意出山，他凭借巧舌如簧、颠倒黑白的能力赢得诉讼。在此之后，黛加入古美门的事务所继续作为律师的修行，而接下来一连串的官司又将古美门和三木沉疴已久的旧怨重新摆上桌面。 这也是一场法律和正义的较量…… 分集剧情第1集 最棒的也是最烂的律师，爱和法律都说谎？！黛真知子为了给自己的辩护人坪仓洗脱杀人犯的嫌疑，而听从社长三木的秘书泽地的建议，找到了律师古美门研介，古美门同意了黛的诉讼请求，而代价则是黛在古美门的事务所内工作直到还清这场官司的诉讼费。两人开始了合作，共同为坪仓辩护。 第2集 赚著作权诉讼的钱？！无名地下摇滚乐队突然发现自己的歌被当红大牌音乐人剽窃了，小黛与古美门接下案子。三木得知后决定亲自上阵替知名音乐人辩护，两边对打，古美门他们面对实力坚强原上司是否能继续赢得正义呢？ 第3集 是初恋还是跟踪狂？号泣的恋爱审判？婚礼现场跟踪狂抢亲加绑架？背后的真相到底是什么？ 第4集 把太阳还给我们公寓审判仁义的较量！小区的旁边盖起了高层公寓，居民们的日照权遭到了侵犯，于是区委会会长委托大和田伸也而与开发商谈判，希望获得赔偿，而古美门却接受了开发商的委托，黛虽然不情愿，但在服部叔的建议下，当做被骗而与古美门共同完成委托，谈判的过程一波三折。 第5集 时限7天！要钱要命！？守护恶德的政治家议员富坚因为受贿而被判刑，富坚曾话重金组成的最强律师团全败并解散。富坚为了洗脱罪名而找到了古美门，古美门欣然同意，并开始了艰难的取证拟定上诉的过程，然而，富坚最后却改变了主意…… 第6集 家庭暴力？有小三？流血的离婚判决刺客是前妻曾受到国民关注的模范夫妻却另有隐情，终于难耐家庭暴力而引发了离婚调停官司，古美门接受了丈夫的委托，而妻子方的律师居然是自己的前妻圭子，而圭子也被黛形容为女版古美门，两个人争锋相对的较量，到底结果如何…… 第7集 骨肉相争！潜藏在酱油家族的秘密与谎言豪门遗产之争。 第8集 夺取抚养权！天才童星与母亲断绝关系的判决童星拥有着光鲜的外表，却有着鲜为人知的幕后生活。安永メイ想要摆脱母亲的控制，而更加独立，便找到了古美门，要求后者帮其断绝母女关系，古美门在金钱的驱动下接受了委托，然而，意想不到的是，母亲的律师却是古美门研介的父亲古美门清藏，判决结果如何，这对母女的关系还能修复吗…… 第9集 恩仇的村民们，取回美丽的故乡环境公益诉讼，要求化工厂停止污染并赔偿损失。关乎村民的生存方式和环境的尊严！ 第10集 要破产还是要五亿！？夸张的羁绊之乡仙羽化学污染案的官司进入白热化，双方使出各种手段，只为了赢得最后的胜利。黛一直食用绢美村的饭和蔬菜，喝绢美村的水，终于她病倒了，因为她的病倒，仙羽化学内的一名核心员工交给了古美门一份致命材料，胜利就在眼前…… 第11集 将内部告发者从不当解雇中拯救！！最强的律师居然输了！？真相常常是喜剧！！一年后，已经离开古美门事务所的黛与八木沼带着诉讼找到古美门，却得知对方已成为被告的律师，黛为了打败古美门，得到了各方的帮助，并且凭借着自己的一片真情实意，扭转了大不利的局势，眼看就要获胜……","raw":null,"content":null,"categories":[{"name":"life","slug":"life","permalink":"https://freehubs.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"https://freehubs.github.io/tags/life/"},{"name":"tvshow","slug":"tvshow","permalink":"https://freehubs.github.io/tags/tvshow/"}]},{"title":"IDEA 使用技巧","slug":"IDEA 使用技巧","date":"2017-12-28T09:34:44.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/12/28/IDEA 使用技巧/","link":"","permalink":"https://freehubs.github.io/2017/12/28/IDEA 使用技巧/","excerpt":"","text":"前言 在生产中主力是使用 IDEA ，工欲善其事，必先利其器。因而总结一下在使用过程中的经验，为方便初学者更快的掌握这个神器。 配置阿里云 配置 阿里云 作为 maven 的仓库来源，原因大家都懂得，国外的仓库速度有时候很呵呵，国内的这方面还是靠谱点。 第一步：打开 IDEA 左上角的偏好设置 Preferences，接连点击 Build &gt;&gt; Build Tools &gt;&gt; Maven ，在 Maven home directory 处选择 IDEA 自带的 maven 版本，在本地文件系统中找到该路径，找到并进入 conf 目录，打开编辑 settings.xml 。 第二步：在 settings.xml 中搜索 mirrors ,将以下配置写入该处：1234567&lt;!-- 阿里amven库 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; NOTE:注意将上述代码放入 &lt;mirrors&gt;这里面&lt;/mirrors&gt; 。 第三步：回到 Maven 的配置界面，User settings file 处点击 Override ,选择刚才编辑的 settings.xml 文件全路径。 第四步：Apply ,OK,完活。现在可以验证是否成功。","raw":null,"content":null,"categories":[{"name":"idea","slug":"idea","permalink":"https://freehubs.github.io/categories/idea/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://freehubs.github.io/tags/idea/"},{"name":"mac","slug":"mac","permalink":"https://freehubs.github.io/tags/mac/"}]},{"title":"Phoenix Secondary Indexing","slug":"Phoenix-Secondary-Indexing","date":"2017-12-27T16:48:35.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/12/27/Phoenix-Secondary-Indexing/","link":"","permalink":"https://freehubs.github.io/2017/12/27/Phoenix-Secondary-Indexing/","excerpt":"二级索引是从主访问路径访问数据的正交方式。在 HBase 中，您有一个索引按字典顺序排序在主键行上。以不同于主要行的方式访问记录需要扫描表中的所有行，以针对您的过滤器对其进行测试。通过二级索引，您索引的列或表达式形成一个备用行键，以允许沿着这个新轴进行点查找和范围扫描。\n\n            Covered Indexes 覆盖索引\n          \nPhoenix 是特别强大的，因为我们提供覆盖索引 - 一旦找到索引条目，我们不需要返回主表。相反，我们将我们关心的数据绑定到索引行，节省了读取时间的开销。\n例如，以下内容将在v1和v2列上创建索引，并在索引中包含v3列以防止从数据表中获取该列：\n1CREATE INDEX my_index ON my_table (v1,v2) INCLUDE(v3)","text":"二级索引是从主访问路径访问数据的正交方式。在 HBase 中，您有一个索引按字典顺序排序在主键行上。以不同于主要行的方式访问记录需要扫描表中的所有行，以针对您的过滤器对其进行测试。通过二级索引，您索引的列或表达式形成一个备用行键，以允许沿着这个新轴进行点查找和范围扫描。 Covered Indexes 覆盖索引 Phoenix 是特别强大的，因为我们提供覆盖索引 - 一旦找到索引条目，我们不需要返回主表。相反，我们将我们关心的数据绑定到索引行，节省了读取时间的开销。 例如，以下内容将在v1和v2列上创建索引，并在索引中包含v3列以防止从数据表中获取该列： 1CREATE INDEX my_index ON my_table (v1,v2) INCLUDE(v3) Functional Indexes 函数索引 函数索引（在4.3和更高版本中可用）允许您不仅在列上而且在任意表达式上创建索引。然后，当一个查询使用该表达式时，索引可以用来检索结果而不是数据表。例如，您可以在 UPPER（FIRST_NAME ||’’|| LAST_NAME）上创建一个索引，以允许您对组合的名字和姓氏进行不区分大小写的搜索。 例如，下面将创建这个功能索引： 1CREATE INDEX UPPER_NAME_IDX ON EMP (UPPER(FIRST_NAME||' '||LAST_NAME)) 有了这个索引，发出下面的查询时，将使用索引而不是数据表来检索结果：1SELECT EMP_ID FROM EMP WHERE UPPER(FIRST_NAME||' '||LAST_NAME)='JOHN DOE' Phoenix 支持两种索引技术：全局索引和本地索引。每个在不同的情况下都很有用，并且有自己的故障概况和性能特点。 Global Indexes 全局索引 全局索引目标是重度读操作用例。使用全局索引，索引的所有性能损失都是在写入时发生的。我们拦截数据表更新写（DELETE，UPSERT VALUES和UPSERT SELECT），建立索引更新，然后发送任何必要的更新到所有感兴趣的索引表。在读的时候，Phoenix 会选择使用的索引表，这将产生最快的查询时间，并直接扫描它，就像任何其他的 HBase 表一样。默认情况下，除非暗示，否则索引不会用于引用不属于索引的列的查询。 Local Indexes 本地索引 本地索引目标针对重度写操作，空间受限的用例。就像全局索引一样，Phoenix 会在查询时自动选择是否使用本地索引。使用本地索引，索引数据和表数据共同驻留在同一台服务器上，防止写入期间的任何网络开销。即使查询没有完全覆盖，也可以使用本地索引（即，Phoenix 自动检索不在索引中的列，通过与数据表相对应的索引）。与全局索引不同，表中的所有本地索引都存储在4.8.0版之前的单独的共享表中。从4.8.0开始，我们将所有本地索引数据存储在相同数据表中的单独的影子列族中。在读取本地索引时，由于不能确定索引数据的确切区域位置，所以必须检查每个区域的数据。因此在读取时会发生一些开销。 Index Population 默认情况下，创建索引时，会在 CREATE INDEX 调用期间同步填充该索引。根据数据表的当前大小，这可能是不可行的。从4.5开始，可以通过在索引创建 DDL 语句中包含 ASYNC 关键字来异步完成索引的填充：1CREATE INDEX async_index ON my_schema.my_table (v) ASYNC 必须通过 HBase 命令行单独启动填充索引表的 map-reduce 作业，如下所示：123$&#123;HBASE_HOME&#125;/bin/hbase org.apache.phoenix.mapreduce.index.IndexTool --schema MY_SCHEMA --data-table MY_TABLE --index-table ASYNC_IDX --output-path ASYNC_IDX_HFILES 只有 map-reduce 作业完成后，索引才会被激活并开始在查询中使用。这项工作对于退出的客户端是有弹性的。输出路径选项用于指定用于写入 HFile 的 HDFS 目录。 Index Usage 索引使用 Phoenix 自动使用索引来服务一个查询，当它确定更有效的时候。但是，除非查询中引用的所有列都包含在索引中，否则不会使用全局索引。例如，以下查询不会使用索引，因为在查询中引用了v2，但未包含在索引中：1SELECT v2 FROM my_table WHERE v1 = 'foo' 在这种情况下，有三种获取索引的方法： 1.通过在索引中包含v2来创建一个覆盖索引：1CREATE INDEX my_index ON my_table (v1) INCLUDE (v2) 这将导致v2列值被复制到索引中，并随着更改而保持同步。这显然会增加索引的大小。 2.提示查询强制它使用索引：1SELECT /*+ INDEX(my_table my_index) */ v2 FROM my_table WHERE v1 = 'foo' 这将导致在遍历索引时找到每个数据行以找到缺少的v2列值。这个提示只有在你知道索引有很好的选择性的时候才可以使用（例如，在这个例子中有少量的表格行的值是’foo’），否则你可以通过默认的行为来获得更好的性能全表扫描。 3.创建一个本地索引：1CREATE LOCAL INDEX my_index ON my_table (v1) 与全局索引不同，即使查询中引用的所有列都不包含在索引中，本地索引也将使用索引。这是默认为本地索引完成的，因为我们知道在同一个区域服务器上的表和索引数据coreside确保查找是本地的。 Index Removal 索引移除 要删除索引，使用以下语句：1DROP INDEX my_index ON my_table 如果索引列在数据表中被删除，索引将自动被删除。另外，如果在数据表中删除一个被覆盖的列，它也会自动从索引中删除。 Index Properties 索引属性 就像使用CREATE TABLE语句一样，CREATE INDEX语句可以通过属性应用到底层的HBase表，包括对其进行限制的能力:12CREATE INDEX my_index ON my_table (v2 DESC, v1) INCLUDE (v3) SALT_BUCKETS=10, DATA_BLOCK_ENCODING='NONE' 请注意，如果主表是加盐的，则对于全局索引，该索引将以相同的方式自动被加盐。另外，相对于主索引表与索引表的大小，索引的MAX_FILESIZE向下调整。欲了解更多信息，请参阅这里。另一方面，使用本地索引时，不允许指定SALT_BUCKETS。 Consistency Guarantees 一致性保证 在提交后成功返回到客户端，所有数据保证写入所有相关的索引和主表。换句话说，索引更新与HBase提供的相同强一致性保证是同步的。 但是，由于索引存储在与数据表不同的表中，因此根据表的属性和索引的类型，表和索引之间的一致性会因服务器端崩溃而失败。这是您的需求和使用案例驱动的重要设计考虑因素。 下面概述了各种一致性保证的不同选项。 Transactional Tables 事务表通过将您的表声明为事务性的，您可以实现表和索引之间最高级别的一致性保证。在这种情况下，您的表突变和相关索引更新的提交是具有强 ACID 保证的原子。如果提交失败，那么您的数据（表或索引）都不会更新，从而确保您的表和索引始终保持同步。 为什么不总是把你的表声明为事务性的？这可能很好，特别是如果你的表被声明为不可变的，因为在这种情况下事务开销非常小。但是，如果您的数据是可变的，请确保与事务性表发生冲突检测相关的开销和运行事务管理器的运行开销是可以接受的。此外，具有二级索引的事务表可能会降低写入数据表的可用性，因为数据表及其辅助索引表必须可用，否则写入将失败。 Immutable Tables 不可变表对于其中数据只写入一次而从不更新的表，可以进行某些优化以减少增量维护的写入时间开销。这是常见的时间序列数据，如日志或事件数据，一旦写入行，它将永远不会被更新。要利用这些优化，通过将 IMMUTABLE_ROWS = true 属性添加到您的 DDL 语句中，将您的表声明为不可变：1CREATE TABLE my_table (k VARCHAR PRIMARY KEY, v VARCHAR) IMMUTABLE_ROWS=true 使用 IMMUTABLE_ROWS = true 声明的表上的所有索引都被认为是不可变的（请注意，默认情况下表被认为是可变的）。对于全局不可变索引，索引完全在客户端维护，索引表是在数据表发生更改时生成的。另一方面，本地不可变索引在服务器端保持不变。请注意，没有任何保护措施可以强制执行，声明为不可变的表实际上不会改变数据（因为这会否定所达到的性能增益）。如果发生这种情况，索引将不再与表同步。 如果您有一个现有的表，您想从不可变索引切换到可变索引，请使用ALTER TABLE命令，如下所示：1ALTER TABLE my_table SET IMMUTABLE_ROWS=false 非事务性，不可变表的索引没有自动处理提交失败的机制。保持表和索引之间的一致性留给客户端处理。因为更新是幂等的，所以最简单的解决方案是客户端继续重试一批突变，直到它们成功。 Mutable Tables 可变表对于非事务性可变表，我们通过将索引更新添加到主表行的预写日志（WAL）条目来维护索引更新持久性。只有在WAL条目成功同步到磁盘后，我们才会尝试更新索引/主表。我们默认并行编写索引更新，从而导致非常高的吞吐量。如果服务器在我们写索引更新的时候崩溃了，我们会重播所有索引更新到WAL恢复过程中的索引表，并依赖更新的幂等性来确保正确性。因此，非事务性可变表上的索引只是主表背后的一批编辑。 重要的是要注意几点： 对于非事务性表，您可以看到索引表与主表不同步。 如上所述，这是可以的，因为我们在很短的时间内只有很小的一部分，并且不同步 每个数据行及其索引行都保证被写入或丢失 - 我们从来没有看到部分更新，因为这是HBase原子性保证的一部分。 首先将数据写入表中，然后写入索引表（如果禁用WAL，则反之亦然）。 Singular Write Path有一个保证失败属性的写入路径。所有写入HRegion的内容都被我们的协处理器拦截。然后，我们根据挂起更新（或更新，如果是批处理）构建索引更新。然后这些更新被附加到原始更新的WAL条目。 如果在此之前我们遇到任何问题，我们会将失败返回给客户端，并且没有任何数据被持久化或者不可见。 一旦WAL被写入，我们确保即使在失败的情况下，索引和主表数据也将变得可见。 如果服务器发生崩溃，我们会使用通常的WAL重播机制重播索引更新。 如果服务器没有崩溃，我们只是将索引更新插入到它们各自的表中。 如果索引更新失败，下面概述了保持一致性的各种方法。 如果Phoenix系统目录表发生故障时无法到达，我们强制服务器立即中止并失败，请在JVM上调用System.exit，强制服务器死机。通过杀死服务器，我们确保WAL将在恢复时重播，将索引更新重播到相应的表中。这确保了二级索引在知道无效状态时不会继续使用。 禁止表写入，直到可变的索引是一致的在非事务性表和索引之间保持一致性的最高级别是声明在更新索引失败的情况下应暂时禁止写入数据表。在此一致性模式下，表和索引将保留在发生故障之前的时间戳，写入数据表将被禁止，直到索引重新联机并与数据表同步。该索引将保持活动状态，并像往常一样继续使用查询。 以下服务器端配置控制此行为： phoenix.index.failure.block.write必须为true，以便在发生提交失败时写入数据表以失败，直到可以使用数据表追上索引。 phoenix.index.failure.handling.rebuild必须为true（默认值），以便在发生提交失败的情况下在后台重建可变索引。 写入失败时禁用可变索引，直到一致性恢复如果在提交时写入失败，具有可变索引的默认行为是将索引标记为禁用,在后台部分重建它们，然后在恢复一致性时再次将其标记为活动状态。在这种一致性模式下，在重建二级索引时，写入数据表不会被阻塞。但是，在重建过程中，二级索引不会被查询使用。 以下服务器端配置控制此行为： phoenix.index.failure.handling.rebuild必须为true（缺省值），以便在发生提交失败的情况下在后台重建可变索引。 phoenix.index.failure.handling.rebuild.interval控制服务器检查是否需要部分重建可变索引以赶上数据表更新的毫秒频率。默认值是10000或10秒。 phoenix.index.failure.handling.rebuild.overlap.time控制执行部分重建时从发生故障的时间戳开始返回的毫秒数。默认值是1。 写入失败时禁用可变索引，需要手动重建这是可变二级索引的最低一致性水平。在这种情况下，当写入二级索引失败时，索引将被标记为禁用，并且手动重建所需的索引以使其再次被查询使用。 以下服务器端配置控制此行为： 如果提交失败，phoenix.index.failure.handling.rebuild必须设置为false，以禁止在后台重建可变索引。 Setup 设置 非事务性，可变索引需要在区域服务器和主服务器上运行特殊的配置选项 - Phoenix确保在表上启用可变索引时，它们已正确设置;如果未设置正确的属性，则将无法使用辅助索引。将这些设置添加到您的hbase-site.xml后，您需要重启集群。 您将需要将以下参数添加到每个区域服务器上的hbase-site.xml：1234&lt;property&gt; &lt;name&gt;hbase.regionserver.wal.codec&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hbase.regionserver.wal.IndexedWALEditCodec&lt;/value&gt;&lt;/property&gt; 上面的属性使定制的WAL编辑能够被写入，确保索引更新的正确写入/重播。这个编解码器支持通常的主机WALEdit选项，最显着的是WALEdit压缩。12345678910&lt;property&gt; &lt;name&gt;hbase.region.server.rpc.scheduler.factory.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hbase.ipc.PhoenixRpcSchedulerFactory&lt;/value&gt; &lt;description&gt;Factory to create the Phoenix RPC Scheduler that uses separate queues for index and metadata updates&lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hbase.rpc.controllerfactory.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hbase.ipc.controller.ServerRpcControllerFactory&lt;/value&gt; &lt;description&gt;Factory to create the Phoenix RPC Scheduler that uses separate queues for index and metadata updates&lt;/description&gt;&lt;/property&gt; 通过确保索引更新的优先级高于数据更新，上述属性可防止在全局索引（HBase 0.98.4+和Phoenix 4.3.1+）的索引维护过程中发生死锁。它还通过确保元数据rpc调用比数据rpc调用具有更高的优先级来防止死锁。 从Phoenix 4.8.0开始，不需要更改配置就可以使用本地索引。在Phoenix 4.7及更低版本中，主服务器节点和区域服务器节点上的服务器端hbase-site.xml需要进行以下配置更改：123456789101112&lt;property&gt; &lt;name&gt;hbase.master.loadbalancer.class&lt;/name&gt; &lt;value&gt;org.apache.phoenix.hbase.index.balancer.IndexLoadBalancer&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt; &lt;value&gt;org.apache.phoenix.hbase.index.master.IndexMasterObserver&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hbase.coprocessor.regionserver.classes&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hbase.regionserver.LocalIndexMerger&lt;/value&gt;&lt;/property&gt; 升级4.8.0之前创建的本地索引在服务器上将Phoenix升级到4.8.0以上版本时，如果存在，请从hbase-site.xml中除去以上三个与本地索引相关的配置。从客户端，我们支持在线（在初始化来自4.8.0+版本的phoenix客户端的连接时）和离线（使用psql工具）在4.8.0之前创建的本地索引的升级。作为升级的一部分，我们以ASYNC模式重新创建本地索引。升级后用户需要使用IndexTool建立索引。 在升级之后使用客户端配置。 phoenix.client.localIndexUpgrade 值为 true 则表示在线升级, false 表示离线升级。 默认为 true 。 命令使用psql工具$ psql [zookeeper] -l运行离线升级。 Tuning 索引是相当快的。但是，要优化您的特定环境和工作负载，可以调整一些属性。 以下所有参数必须在hbase-site.xml中设置 - 对于整个集群和所有索引表，以及在同一台服务器上的所有区域上都是如此（例如，一台服务器也不会一次写入许多不同的索引表）。 index.builder.threads.max 用于从主表更新构建索引更新的线程数 增加此值克服了从底层HRegion读取当前行状态的瓶颈。调整这个值太高，只会增加HRegion瓶颈，因为它将无法处理太多的并发扫描请求，以及一般的线程交换问题。 Default: 10 index.builder.threads.keepalivetime 在构建器线程池中使线程过期后的时间（以秒为单位）。 未使用的线程会在这段时间后立即释放，而不会保留核心线程 Default: 60 index.writer.threads.max Number of threads to use when writing to the target index tables. The first level of parallelization, on a per-table basis - it should roughly correspond to the number of index tables Default: 10 index.writer.threads.keepalivetime Amount of time in seconds after we expire threads in the writer thread pool. Unused threads are immediately released after this amount of time and not core threads are retained (though this last is a small concern as tables are expected to sustain a fairly constant write load), but simultaneously allows us to drop threads if we are not seeing the expected load. Default: 60 hbase.htable.threads.max Number of threads each index HTable can use for writes. Increasing this allows more concurrent index updates (for instance across batches), leading to high overall throughput. Default: 2,147,483,647 hbase.htable.threads.keepalivetime Amount of time in seconds after we expire threads in the HTable’s thread pool. Using the “direct handoff” approach, new threads will only be created if it is necessary and will grow unbounded. This could be bad but HTables only create as many Runnables as there are region servers; therefore, it also scales when new region servers are added. Default: 60 index.tablefactory.cache.size Number of index HTables we should keep in cache. Increasing this number ensures that we do not need to recreate an HTable for each attempt to write to an index table. Conversely, you could see memory pressure if this value is set too high. Default: 10 org.apache.phoenix.regionserver.index.priority.min Value to specify to bottom (inclusive) of the range in which index priority may lie. Default: 1000 org.apache.phoenix.regionserver.index.priority.max Value to specify to top (exclusive) of the range in which index priority may lie. Higher priorites within the index min/max range do not means updates are processed sooner. Default: 1050 org.apache.phoenix.regionserver.index.handler.count Number of threads to use when serving index write requests for global index maintenance. Though the actual number of threads is dictated by the Max(number of call queues, handler count), where the number of call queues is determined by standard HBase configuration. To further tune the queues, you can adjust the standard rpc queue length parameters (currently, there are no special knobs for the index queues), specifically ipc.server.max.callqueue.length and ipc.server.callqueue.handler.factor. See the HBase Reference Guide for more details. Default: 30 Performance We track secondary index performance via our performance framework. This is a generic test of performance based on defaults - your results will vary based on hardware specs as well as you individual configuration. That said, we have seen secondary indexing (both immutable and mutable) go as quickly as &lt; 2x the regular write path on a small, (3 node) desktop-based cluster. This is actually pretty reasonable as we have to write to multiple tables as well as build the index update. Index Scrutiny Tool With Phoenix 4.12, there is now a tool to run a MapReduce job to verify that an index table is valid against its data table. The only way to find orphaned rows in either table is to scan over all rows in the table and do a lookup in the other table for the corresponding row. For that reason, the tool can run with either the data or index table as the “source” table, and the other as the “target” table. The tool writes all invalid rows it finds either to file or to an output table PHOENIX_INDEX_SCRUTINY. An invalid row is a source row that either has no corresponding row in the target table, or has an incorrect value in the target table (i.e. covered column value). The tool has job counters that track its status. VALID_ROW_COUNT, INVALID_ROW_COUNT, BAD_COVERED_COL_VAL_COUNT. Note that invalid rows - bad col val rows = number of orphaned rows. These counters are written to the table PHOENIX_INDEX_SCRUTINY_METADATA, along with other job metadata. The Index Scrutiny Tool can be launched via the hbase command (in hbase/bin) as follows: 1hbase org.apache.phoenix.mapreduce.index.IndexScrutinyTool -dt my_table -it my_index -o It can also be run from Hadoop using either the phoenix-core or phoenix-server jar as follows: 1HADOOP_CLASSPATH=$(hbase mapredcp) hadoop jar phoenix-&lt;version&gt;-server.jar org.apache.phoenix.mapreduce.index.IndexScrutinyTool -dt my_table -it my_index -o By default two mapreduce jobs are launched, one with the data table as the source table and one with the index table as the source table. The following parameters can be used with the Index Scrutiny Tool: 翻译自:secondary_indexing","raw":null,"content":null,"categories":[{"name":"phoenix","slug":"phoenix","permalink":"https://freehubs.github.io/categories/phoenix/"}],"tags":[{"name":"phoenix","slug":"phoenix","permalink":"https://freehubs.github.io/tags/phoenix/"}]},{"title":"Google Bigtable 中文版","slug":"Google-Bigtable-中文版","date":"2017-12-25T16:48:35.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/12/25/Google-Bigtable-中文版/","link":"","permalink":"https://freehubs.github.io/2017/12/25/Google-Bigtable-中文版/","excerpt":"\n            摘要\n          \nBigtable 是一个分布式的结构化数据存储系统，它被设计用来处理海量数据:通常是分布在数千台普通服务器上的 PB 级的数据。\nGoogle 的很多项目使用 Bigtable 存储数据，包括 Web 索引、Google Earth、Google Finance。这些应用对 Bigtable 提出的要求差异非常大，无论是在数据量上(从 URL 到网页到卫星图像)还是在响应速度上(从后端的批量处理到实时数据服务)。尽管应用需求差异很大，但是，针对 Google 的这些产品，Bigtable 还是成功的提供了一个灵活的、高性能的解决方案。\n本论文描述了 Bigtable 提供的简单的数据模型。利用这个模型，用户可以动态的控制数据的分布和格式。 我们还将描述 Bigtable 的设计和实现。","text":"摘要 Bigtable 是一个分布式的结构化数据存储系统，它被设计用来处理海量数据:通常是分布在数千台普通服务器上的 PB 级的数据。 Google 的很多项目使用 Bigtable 存储数据，包括 Web 索引、Google Earth、Google Finance。这些应用对 Bigtable 提出的要求差异非常大，无论是在数据量上(从 URL 到网页到卫星图像)还是在响应速度上(从后端的批量处理到实时数据服务)。尽管应用需求差异很大，但是，针对 Google 的这些产品，Bigtable 还是成功的提供了一个灵活的、高性能的解决方案。 本论文描述了 Bigtable 提供的简单的数据模型。利用这个模型，用户可以动态的控制数据的分布和格式。 我们还将描述 Bigtable 的设计和实现。 介绍 在过去两年半时间里，我们设计、实现并部署了一个分布式的结构化数据存储系统 — 在 Google，我们称之为 Bigtable。Bigtable 的设计目的是可靠的处理 PB 级别的数据，并且能够部署到上千台机器上。Bigtable 已经实现了下面的几个目标:适用性广泛、可扩展、高性能和高可用性。 Bigtable 已经在超过 60 个 Google 的产品和项目上得到了应用，包括 Google Analytics、Google Finance、 Orkut、Personalized Search、Writely 和 Google Earth。这些产品对 Bigtable 提出了迥异的需求，有的需要高吞吐量的批处理，有的则需要及时响应，快速返回数据给最终用户。它们使用的 Bigtable 集群的配置也有很大的差异，有的集群只有几台服务器，而有的则需要上千台服务器、存储几百 TB 的数据。 在很多方面，Bigtable 和数据库很类似:它使用了很多数据库的实现策略。并行数据库和内存数据库已经具备可扩展性和高性能，但是 Bigtable 提供了一个和这些系统完全不同的接口。Bigtable 不支持完整的关系数据模型;与之相反，Bigtable 为客户提供了简单的数据模型，利用这个模型，客户可以动态控制数据的分布和格式，用户也可以自己推测底层存储数据的位置相关性。数据的下标是行和列的名字，名字可以是任意的字符串。Bigtable 将存储的数据都视为字符串，但是 Bigtable 本身不去解析这些字符串，客户程序通常会在把各种结构化或者半结构化的数据串行化到这些字符串里。通过仔细选择数据的模式，客户可以控制数据的位置相关性。最后，可以通过 BigTable 的模式参数来控制数据是存放在内存中还是硬盘上。 第 3 节描述关于数据模型更多细节方面的东西; 第 4 节概要介绍了客户端 API; 第 5 节简要介绍了 BigTable 底层使用的 Google 的基础框架; 第 6 节描述了 BigTable 实现的关键部分; 第 7 节描述了我们为了提高 BigTable 的性能采用的一些精细的调优方法; 第 8 节提供了 BigTable 的性能数据; 第 9 节讲述了几个 Google 内部使用 BigTable 的例子; 第 10 节是我们在设计和后期支持过程中得到一些经验和教训; 最后，在第 11 节列出我们的相关研究工作，第 12 节是我们的结论。 数据模型 Bigtable 是一个稀疏的、分布式的、持久化存储的多维度排序 Map。Map 的索引是行关键字、列关键字以及时间戳;Map 中的每个 value 都是一个未经解析的 byte 数组。(row:string, column:string,time:int64)-&gt;string我们在仔细分析了一个类似 Bigtable 的系统的种种潜在用途之后，决定使用这个数据模型。我们先举个具体的例子，这个例子促使我们做了很多设计决策;假设我们想要存储海量的网页及相关信息，这些数据可以用于很多不同的项目，我们姑且称这个特殊的表为 Webtable。在 Webtable 里，我们使用 URL 作为行关键字，使用网页的某些属性作为列名，网页的内容存在“contents:”列中，并用获取该网页的时间戳作为标识,如图一所示。行名是一个反向 URL。contents 列族存放的是网页的内容，anchor 列族存放引用该网页的锚链接文本。 CNN 的主页被 Sports Illustrator 和 MY-look 的主页引用，因此该行包含了名为“anchor:cnnsi.com”和 “anchhor:my.look.ca”的列。每个锚链接只有一个版本;而 contents 列则有三个版本，分别由时间戳 t3，t5，和 t6 标识。 行表中的行关键字可以是任意的字符串(目前支持最大 64KB 的字符串，但是对大多数用户，10-100 个字 节就足够了)。对同一个行关键字的读或者写操作都是原子的(不管读或者写这一行里多少个不同列)，这个 设计决策能够使用户很容易的理解程序在对同一个行进行并发更新操作时的行为。 Bigtable 通过行关键字的字典顺序来组织数据。表中的每个行都可以动态分区。每个分区叫做一个”Tablet”， Tablet 是数据分布和负载均衡调整的最小单位。这样做的结果是，当操作只读取行中很少几列的数据时效率很 高，通常只需要很少几次机器间的通信即可完成。用户可以通过选择合适的行关键字，在数据访问时有效利 用数据的位置相关性，从而更好的利用这个特性。举例来说，在 Webtable 里，通过反转 URL 中主机名的方 式，可以把同一个域名下的网页聚集起来组织成连续的行。具体来说，我们可以把 maps.google.com/index.html 的数据存放在关键字 com.google.maps/index.html 下。把相同的域中的网页存储在连续的区域可以让基于主机 和域名的分析更加有效。 列族列关键字组成的集合叫做“列族“，列族是访问控制的基本单位。存放在同一列族下的所有数据通常都 属于同一个类型(我们可以把同一个列族下的数据压缩在一起)。列族在使用之前必须先创建，然后才能在列 族中任何的列关键字下存放数据;列族创建后，其中的任何一个列关键字下都可以存放数据。根据我们的设 计意图，一张表中的列族不能太多(最多几百个)，并且列族在运行期间很少改变。与之相对应的，一张表可 以有无限多个列。 列关键字的命名语法如下:列族:限定词。 列族的名字必须是可打印的字符串，而限定词的名字可以是 任意的字符串。比如，Webtable 有个列族 language，language 列族用来存放撰写网页的语言。我们在 language 列族中只使用一个列关键字，用来存放每个网页的语言标识 ID。Webtable 中另一个有用的列族是 anchor;这 个列族的每一个列关键字代表一个锚链接，如图一所示。Anchor 列族的限定词是引用该网页的站点名;Anchor 列族每列的数据项存放的是链接文本。 访问控制、磁盘和内存的使用统计都是在列族层面进行的。在我们的 Webtable 的例子中，上述的控制权 限能帮助我们管理不同类型的应用:我们允许一些应用可以添加新的基本数据、一些应用可以读取基本数据并创建继承的列族、一些应用则只允许浏览数据(甚至可能因为隐私的原因不能浏览所有数据)。 时间戳在 Bigtable 中，表的每一个数据项都可以包含同一份数据的不同版本;不同版本的数据通过时间戳来索 引。Bigtable 时间戳的类型是 64 位整型。Bigtable 可以给时间戳赋值，用来表示精确到毫秒的“实时”时间; 用户程序也可以给时间戳赋值。如果应用程序需要避免数据版本冲突，那么它必须自己生成具有唯一性的时 间戳。数据项中，不同版本的数据按照时间戳倒序排序，即最新的数据排在最前面。 为了减轻多个版本数据的管理负担，我们对每一个列族配有两个设置参数，Bigtable 通过这两个参数可以 对废弃版本的数据自动进行垃圾收集。用户可以指定只保存最后 n 个版本的数据，或者只保存“足够新”的 版本的数据(比如，只保存最近 7 天的内容写入的数据)。 在 Webtable 的举例里，contents:列存储的时间戳信息是网络爬虫抓取一个页面的时间。上面提及的垃圾 收集机制可以让我们只保留最近三个版本的网页数据。 API Bigtable 提供了建立和删除表以及列族的 API 函数。Bigtable 还提供了修改集群、表和列族的元数据的 API ，比如修改访问权限。 // Open the table Table *T = OpenOrDie(“/bigtable/web/webtable”); // Write a new anchor and delete an old anchor RowMutation r1(T, “com.cnn.www”); r1.Set(“anchor:www.c-span.org”, “CNN”); r1.Delete(“anchor:www.abc.com”); Operation op; Apply(&amp;op, &amp;r1); 客户程序可以对 Bigtable 进行如下的操作:写入或者删除 Bigtable 中的值、从每个行中查找值、或者遍历表中的一个数据子集。图 2 中的C++代码使用 RowMutation 抽象对象进行了一系列的更新操作。(为了保持 示例代码的简洁，我们忽略了一些细节相关代码)。调用 Apply 函数对Webtable 进行了一个原子修改操作:它为 www.cnn.com 增加了一个锚点，同时删除了另外一个锚点。 Scanner scanner(T); ScanStream *stream; stream = scanner.FetchColumnFamily(“anchor”); stream-&gt;SetReturnAllVersions(); scanner.Lookup(“com.cnn.www”); for (; !stream-&gt;Done(); stream-&gt;Next()) { printf(“%s %s %lld %s\\n”, scanner.RowName(), stream-&gt;ColumnName(), stream-&gt;MicroTimestamp(), stream-&gt;Value()); } 图表 3 Reading from Bigtable.图 3 中的 C++代码使用 Scanner 抽象对象遍历一个行内的所有锚点。客户程序可以遍历多个列族，有几种方法可以对扫描输出的行、列和时间戳进行限制。例如，我们可以限制上面的扫描，让它只输出那些匹配 正则表达式*.cnn.com 的锚点，或者那些时间戳在当前时间前 10 天的锚点。 Bigtable 还支持一些其它的特性，利用这些特性，用户可以对数据进行更复杂的处理。首先，Bigtable 支 持单行上的事务处理，利用这个功能，用户可以对存储在一个行关键字下的数据进行原子性的读-更新-写操作。 虽然 Bigtable 提供了一个允许用户跨行批量写入数据的接口，但是，Bigtable 目前还不支持通用的跨行事务处 理。其次，Bigtable 允许把数据项用做整数计数器。最后，Bigtable 允许用户在服务器的地址空间内执行脚本 程序。脚本程序使用 Google 开发的 Sawzall数据处理语言。虽然目前我们基于的 Sawzall 语言的 API 函数还不允许客户的脚本程序写入数据到 Bigtable，但是它允许多种形式的数据转换、基于任意表达式的数据 过滤、以及使用多种操作符的进行数据汇总。 Bigtable 可以和 MapReduce 一起使用，MapReduce 是 Google 开发的大规模并行计算框架。我们已 经开发了一些 Wrapper 类，通过使用这些 Wrapper 类，Bigtable 可以作为 MapReduce 框架的输入和输出。 BigTable 构件 Bigtable是建立在其它的几个Google基础构件上的。BigTable使用Google的分布式文件系统(GFS存储日志文件和数据文件。BigTable 集群通常运行在一个共享的机器池中，池中的机器还会运行其它的各种各样的分布式应用程序，BigTable 的进程经常要和其它应用的进程共享机器。BigTable 依赖集群管理系统来调度任务、管理共享的机器上的资源、处理机器的故障、以及监视机器的状态。 BigTable 内部存储数据的文件是 Google SSTable 格式的。SSTable 是一个持久化的、排序的、不可更改的 Map 结构，而 Map 是一个 key-value 映射的数据结构，key 和 value 的值都是任意的 Byte 串。可以对 SSTable 进行如下的操作:查询与一个 key 值相关的 value，或者遍历某个 key 值范围内的所有的 key-value 对。从内 部看，SSTable 是一系列的数据块(通常每个块的大小是 64KB，这个大小是可以配置的)。SSTable 使用块索 引(通常存储在 SSTable 的最后)来定位数据块;在打开 SSTable 的时候，索引被加载到内存。每次查找都可 以通过一次磁盘搜索完成:首先使用二分查找法在内存中的索引里找到数据块的位置，然后再从硬盘读取相 应的数据块。也可以选择把整个 SSTable 都放在内存中，这样就不必访问硬盘了。 BigTable 还依赖一个高可用的、序列化的分布式锁服务组件，叫做 Chubby【8】。一个 Chubby 服务包括 了 5 个活动的副本，其中的一个副本被选为 Master，并且处理请求。只有在大多数副本都是正常运行的，并 且彼此之间能够互相通信的情况下，Chubby 服务才是可用的。当有副本失效的时候，Chubby 使用 Paxos 算法 【9,23】来保证副本的一致性。Chubby 提供了一个名字空间，里面包括了目录和小文件。每个目录或者文件 可以当成一个锁，读写文件的操作都是原子的。Chubby 客户程序库提供对 Chubby 文件的一致性缓存。每个 Chubby 客户程序都维护一个与 Chubby 服务的会话。如果客户程序不能在租约到期的时间内重新签订会话的 租约，这个会话就过期失效了9。当一个会话失效时，它拥有的锁和打开的文件句柄都失效了。Chubby 客户 程序可以在文件和目录上注册回调函数，当文件或目录改变、或者会话过期时，回调函数会通知客户程序。 Bigtable 使用 Chubby 完成以下的几个任务: 确保在任何给定的时间内最多只有一个活动的 Master 副本; 存储 BigTable 数据的自引导指令的位置(参考 5.1 节); 查找 Tablet 服务器，以及在 Tablet 服务器失效时进行善后(5.2 节); 存储 BigTable 的模式信息(每张表的列族信息); 以及存储访问控制列表。 如果 Chubby 长时间无法访问，BigTable 就会失效。最近我们在使用 11 个 Chubby 服务实例的 14 个 BigTable集群上测量了这个影响。由于 Chubby 不可用而导致 BigTable 中的部分数据不能访问的平均比率是 0.0047% (Chubby 不能访问的原因可能是 Chubby 本身失效或者网络问题)。单个集群里，受 Chubby 失效影响最大的 百分比是 0.0326%10。 介绍 Bigtable 包括了三个主要的组件:链接到客户程序中的库、一个 Master 服务器和多个 Tablet 服务器。针 对系统工作负载的变化情况，BigTable 可以动态的向集群中添加(或者删除)Tablet 服务器。 Master 服务器主要负责以下工作:为 Tablet 服务器分配 Tablets、检测新加入的或者过期失效的 Table 服 务器、对 Tablet 服务器进行负载均衡、以及对保存在 GFS 上的文件进行垃圾收集。除此之外，它还处理对模 式的相关修改操作，例如建立表和列族。 每个 Tablet 服务器都管理一个 Tablet 的集合(通常每个服务器有大约数十个至上千个 Tablet)。每个 Tablet 服务器负责处理它所加载的 Tablet 的读写操作，以及在 Tablets 过大时，对其进行分割。 和很多 Single-Master 类型的分布式存储系统【17.21】类似，客户端读取的数据都不经过 Master 服务器: 客户程序直接和 Tablet 服务器通信进行读写操作。由于 BigTable 的客户程序不必通过 Master 服务器来获取 Tablet 的位置信息，因此，大多数客户程序甚至完全不需要和 Master 服务器通信。在实际应用中，Master 服 务器的负载是很轻的。 一个 BigTable 集群存储了很多表，每个表包含了一个 Tablet 的集合，而每个 Tablet 包含了某个范围内的 行的所有相关数据。初始状态下，一个表只有一个 Tablet。随着表中数据的增长，它被自动分割成多个 Tablet， 缺省情况下，每个 Tablet 的尺寸大约是 100MB 到 200MB。 Tablet 的位置我们使用一个三层的、类似B+树[10]的结构存储 Tablet 的位置信息(如图 4)。第一层是一个存储在 Chubby 中的文件，它包含了 Root Tablet 的位置信息。Root Tablet 包含了一个特殊 的 METADATA 表里所有的 Tablet 的位置信息。METADATA 表的每个 Tablet 包含了一个用户 Tablet 的集合。 Root Tablet 实际上是 METADATA 表的第一个 Tablet，只不过对它的处理比较特殊 — Root Tablet 永远不会被 分割 — 这就保证了 Tablet 的位置信息存储结构不会超过三层。 在 METADATA 表里面，每个 Tablet 的位置信息都存放在一个行关键字下面，而这个行关键字是由 Tablet 所在的表的标识符和 Tablet 的最后一行编码而成的。METADATA 的每一行都存储了大约 1KB 的内存数据。 在一个大小适中的、容量限制为 128MB 的 METADATA Tablet 中，采用这种三层结构的存储模式，可以标识 2^34 个 Tablet 的地址(如果每个 Tablet 存储 128MB 数据，那么一共可以存储 2^61 字节数据)。 客户程序使用的库会缓存 Tablet 的位置信息。如果客户程序没有缓存某个 Tablet 的地址信息，或者发现 它缓存的地址信息不正确，客户程序就在树状的存储结构中递归的查询 Tablet 位置信息;如果客户端缓存是 空的，那么寻址算法需要通过三次网络来回通信寻址，这其中包括了一次 Chubby 读操作;如果客户端缓存的 地址信息过期了，那么寻址算法可能需要最多6次网络来回通信才能更新数据，因为只有在缓存中没有查到 数据的时候才能发现数据过期11。尽管 Tablet 的地址信息是存放在内存里的，对它的操作不必访问 GFS 文件 系统，但是，通常我们会通过预取 Tablet 地址来进一步的减少访问的开销:每次需要从 METADATA 表中读取一个 Tablet 的元数据的时候，它都会多读取几个 Tablet 的元数据。 在 METADATA 表中还存储了次级信息12，包括每个 Tablet 的事件日志(例如，什么时候一个服务器开始为该 Tablet 提供服务)。这些信息有助于排查错误和性能分析。 Tablet 分配在任何一个时刻，一个 Tablet 只能分配给一个 Tablet 服务器。Master 服务器记录了当前有哪些活跃的 Tablet 服务器、哪些 Tablet 分配给了哪些 Tablet 服务器、哪些 Tablet 还没有被分配。当一个 Tablet 还没有被分配、 并且刚好有一个 Tablet 服务器有足够的空闲空间装载该 Tablet 时，Master 服务器会给这个 Tablet 服务器发送 一个装载请求，把 Tablet 分配给这个服务器。 BigTable 使用 Chubby 跟踪记录 Tablet 服务器的状态。当一个 Tablet 服务器启动时，它在 Chubby 的一个 指定目录下建立一个有唯一性名字的文件，并且获取该文件的独占锁。Master 服务器实时监控着这个目录(服 务器目录)，因此 Master 服务器能够知道有新的 Tablet 服务器加入了。如果 Tablet 服务器丢失了 Chubby 上的 独占锁 — 比如由于网络断开导致 Tablet 服务器和 Chubby 的会话丢失 — 它就停止对 Tablet 提供服务。 (Chubby 提供了一种高效的机制，利用这种机制，Tablet 服务器能够在不增加网络负担的情况下知道它是否 还持有锁)。只要文件还存在，Tablet 服务器就会试图重新获得对该文件的独占锁;如果文件不存在了，那么 Tablet 服务器就不能再提供服务了，它会自行退出13。当 Tablet 服务器终止时(比如，集群的管理系统将运行 该 Tablet 服务器的主机从集群中移除)，它会尝试释放它持有的文件锁，这样一来，Master 服务器就能尽快把 Tablet 分配到其它的 Tablet 服务器。 Master 服务器负责检查一个 Tablet 服务器是否已经不再为它的 Tablet 提供服务了，并且要尽快重新分配 它加载的 Tablet。Master 服务器通过轮询 Tablet 服务器文件锁的状态来检测何时 Tablet 服务器不再为 Tablet 提供服务。如果一个 Tablet 服务器报告它丢失了文件锁，或者 Master 服务器最近几次尝试和它通信都没有得到响应，Master 服务器就会尝试获取该 Tablet 服务器文件的独占锁;如果 Master 服务器成功获取了独占锁， 那么就说明 Chubby 是正常运行的，而 Tablet 服务器要么是宕机了、要么是不能和 Chubby 通信了，因此，Master 服务器就删除该 Tablet 服务器在 Chubby 上的服务器文件以确保它不再给 Tablet 提供服务。一旦 Tablet 服务器 在 Chubby 上的服务器文件被删除了，Master 服务器就把之前分配给它的所有的 Tablet 放入未分配的 Tablet 集合中。为了确保 Bigtable 集群在 Master 服务器和 Chubby 之间网络出现故障的时候仍然可以使用，Master 服务器在它的 Chubby 会话过期后主动退出。但是不管怎样，如同我们前面所描述的，Master 服务器的故障不 会改变现有 Tablet 在 Tablet 服务器上的分配状态。 当集群管理系统启动了一个 Master 服务器之后，Master 服务器首先要了解当前 Tablet 的分配状态，之后 才能够修改分配状态。Master 服务器在启动的时候执行以下步骤: Master 服务器从 Chubby 获取一个唯一的 Master 锁，用来阻止创建其它的 Master 服务器实例; Master 服务器扫描 Chubby 的服务器文件锁存储目录，获取当前正在运行的服务器列表; Master 服务器和所有的正在运行的 Tablet 表服务器通信，获取每个 Tablet 服务器上 Tablet 的分配信息; Master 服务器扫描 METADATA 表获取所有的 Tablet 的集合。 在扫描的过程中，当 Master 服务器发现了一个还没有分配的 Tablet，Master 服务器就将这个 Tablet 加入未分配的 Tablet 集合等待合适的时机分配。 可能会遇到一种复杂的情况:在 METADATA 表的 Tablet 还没有被分配之前是不能够扫描它的。因此，在开始扫描之前(步骤 4)，如果在第三步的扫描过程中发现 Root Tablet 还没有分配，Master 服务器就把 Root Tablet 加入到未分配的 Tablet 集合。这个附加操作确保了 Root Tablet 会被分配。由于 Root Tablet 包括了所有 METADATA 的 Tablet 的名字，因此 Master 服务器扫描完 Root Tablet 以后，就得到了所有的 METADATA 表 的 Tablet 的名字了。 保存现有 Tablet 的集合只有在以下事件发生时才会改变:建立了一个新表或者删除了一个旧表、两个 Tablet 被合并了、或者一个 Tablet 被分割成两个小的 Tablet。Master 服务器可以跟踪记录所有这些事件，因为 除了最后一个事件外的两个事件都是由它启动的。Tablet 分割事件需要特殊处理，因为它是由 Tablet 服务器启 动。在分割操作完成之后，Tablet 服务器通过在 METADATA 表中记录新的 Tablet 的信息来提交这个操作;当 分割操作提交之后，Tablet 服务器会通知 Master 服务器。如果分割操作已提交的信息没有通知到 Master 服务 器(可能两个服务器中有一个宕机了)，Master 服务器在要求 Tablet 服务器装载已经被分割的子表的时候会发现一个新的 Tablet。通过对比 METADATA 表中 Tablet 的信息，Tablet 服务器会发现 Master 服务器要求其装载的 Tablet 并不完整，因此，Tablet 服务器会重新向 Master 服务器发送通知信息。 Tablet 服务如图 5 所示，Tablet 的持久化状态信息保存在 GFS 上。更新操作提交到 REDO 日志中14。在这些更新操 作中，最近提交的那些存放在一个排序的缓存中，我们称这个缓存为 memtable;较早的更新存放在一系列 SSTable 中。为了恢复一个 Tablet，Tablet 服务器首先从 METADATA 表中读取它的元数据。Tablet 的元数据包 含了组成这个 Tablet 的 SSTable 的列表，以及一系列的 Redo Point15，这些 Redo Point 指向可能含有该 Tablet 数据的已提交的日志记录。Tablet 服务器把 SSTable 的索引读进内存，之后通过重复 Redo Point 之后提交的更 新来重建 memtable。 当对 Tablet 服务器进行写操作时，Tablet 服务器首先要检查这个操作格式是否正确、操作发起者是否有执 行这个操作的权限。权限验证的方法是通过从一个 Chubby 文件里读取出来的具有写权限的操作者列表来进行 验证(这个文件几乎一定会存放在 Chubby 客户缓存里)。成功的修改操作会记录在提交日志里。可以采用批 量提交方式16来提高包含大量小的修改操作的应用程序的吞吐量【13，16】。当一个写操作提交后，写的内容 插入到 memtable 里面。 当对 Tablet 服务器进行读操作时，Tablet 服务器会作类似的完整性和权限检查。一个有效的读操作在一个 由一系列 SSTable 和 memtable 合并的视图里执行。由于 SSTable 和 memtable 是按字典排序的数据结构，因此 可以高效生成合并视图。 当进行 Tablet 的合并和分割时，正在进行的读写操作能够继续进行。 空间收缩随着写操作的执行，memtable 的大小不断增加。当 memtable 的尺寸到达一个门限值的时候，这个 memtable 就会被冻结，然后创建一个新的 memtable;被冻结住 memtable 会被转换成 SSTable，然后写入 GFS18。Minor Compaction 过程有两个目的:shrink 19Tablet 服务器使用的内存，以及在服务器灾难恢复过程中，减少必须从 提交日志里读取的数据量。在 Compaction 过程中，正在进行的读写操作仍能继续。 每一次 Minor Compaction 都会创建一个新的 SSTable。如果 Minor Compaction 过程不停滞的持续进行下 去，读操作可能需要合并来自多个 SSTable 的更新;否则，我们通过定期在后台执行 Merging Compaction 过 程合并文件，限制这类文件的数量。Merging Compaction 过程读取一些 SSTable 和 memtable 的内容，合并成 一个新的 SSTable。只要 Merging Compaction 过程完成了，输入的这些 SSTable 和 memtable 就可以删除了。 合并所有的 SSTable 并生成一个新的 SSTable 的 Merging Compaction 过程叫作 Major Compaction。由非 Major Compaction 产生的 SSTable 可能含有特殊的删除条目，这些删除条目能够隐藏在旧的、但是依然有效的 SSTable 中已经删除的数据20。而 Major Compaction 过程生成的 SSTable 不包含已经删除的信息或数据。Bigtable 循环扫描它所有的 Tablet，并且定期对它们执行 Major Compaction。Major Compaction 机制允许 Bigtable 回收 已经删除的数据占有的资源，并且确保 BigTable 能及时清除已经删除的数据21，这对存放敏感数据的服务是 非常重要。 优化 上一章我们描述了 Bigtable 的实现，我们还需要很多优化工作才能使 Bigtable 到达用户要求的高性能、 高可用性和高可靠性。本章描述了 Bigtable 实现的其它部分，为了更好的强调这些优化工作，我们将深入细 节。 局部性群组客户程序可以将多个列族组合成一个局部性群族。对 Tablet 中的每个局部性群组都会生成一个单独的SSTable。将通常不会一起访问的列族分割成不同的局部性群组可以提高读取操作的效率。例如，在 Webtable表中，网页的元数据(比如语言和 Checksum)可以在一个局部性群组中，网页的内容可以在另外一个群组: 当一个应用程序要读取网页的元数据的时候，它没有必要去读取所有的页面内容。 此外，可以以局部性群组为单位设定一些有用的调试参数。比如，可以把一个局部性群组设定为全部存 储在内存中。Tablet 服务器依照惰性加载的策略将设定为放入内存的局部性群组的 SSTable 装载进内存。加载 完成之后，访问属于该局部性群组的列族的时候就不必读取硬盘了。这个特性对于需要频繁访问的小块数据 特别有用:在 Bigtable 内部，我们利用这个特性提高 METADATA 表中具有位置相关性的列族的访问速度。 压缩客户程序可以控制一个局部性群组的 SSTable 是否需要压缩;如果需要压缩，那么以什么格式来压缩。 每个 SSTable 的块(块的大小由局部性群组的优化参数指定)都使用用户指定的压缩格式来压缩。虽然分块 压缩浪费了少量空间22，但是，我们在只读取 SSTable 的一小部分数据的时候就不必解压整个文件了。很多客 户程序使用了“两遍”的、可定制的压缩方式。第一遍采用 Bentley and McIlroy’s 方式[6]，这种方式在一个 很大的扫描窗口里对常见的长字符串进行压缩;第二遍是采用快速压缩算法，即在一个 16KB 的小扫描窗口 中寻找重复数据。两个压缩的算法都很快，在现在的机器上，压缩的速率达到 100-200MB/s，解压的速率达 到 400-1000MB/s。 虽然我们在选择压缩算法的时候重点考虑的是速度而不是压缩的空间，但是这种两遍的压缩方式在空间 压缩率上的表现也是令人惊叹。比如，在 Webtable 的例子里，我们使用这种压缩方式来存储网页内容。在一 次测试中，我们在一个压缩的局部性群组中存储了大量的网页。针对实验的目的，我们没有存储每个文档所 有版本的数据，我们仅仅存储了一个版本的数据。该模式的空间压缩比达到了 10:1。这比传统的 Gzip 在压缩 HTML 页面时 3:1 或者 4:1 的空间压缩比好的多;“两遍”的压缩模式如此高效的原因是由于 Webtable 的行的 存放方式:从同一个主机获取的页面都存在临近的地方。利用这个特性，Bentley-McIlroy 算法可以从来自同 一个主机的页面里找到大量的重复内容。不仅仅是 Webtable，其它的很多应用程序也通过选择合适的行名来 将相似的数据聚簇在一起，以获取较高的压缩率。当我们在 Bigtable 中存储同一份数据的多个版本的时候， 压缩效率会更高。 通过缓存提高读操作的性能为了提高读操作的性能，Tablet 服务器使用二级缓存的策略。扫描缓存是第一级缓存，主要缓存 Tablet服务器通过 SSTable 接口获取的 Key-Value 对;Block 缓存是二级缓存，缓存的是从 GFS 读取的 SSTable 的 Block。对于经常要重复读取相同数据的应用程序来说，扫描缓存非常有效;对于经常要读取刚刚读过的数据 附近的数据的应用程序来说，Block 缓存更有用(例如，顺序读，或者在一个热点的行的局部性群组中随机读取不同的列)。 Bloom 过滤器如 6.3 节所述，一个读操作必须读取构成 Tablet 状态的所有 SSTable 的数据。如果这些 SSTable 不在内存 中，那么就需要多次访问硬盘。我们通过允许客户程序对特定局部性群组的 SSTable 指定 Bloom 过滤器【7】， 来减少硬盘访问的次数。我们可以使用 Bloom 过滤器查询一个 SSTable 是否包含了特定行和列的数据。对于 某些特定应用程序，我们只付出了少量的、用于存储 Bloom 过滤器的内存的代价，就换来了读操作显著减少 的磁盘访问的次数。使用 Bloom 过滤器也隐式的达到了当应用程序访问不存在的行或列时，大多数时候我们 都不需要访问硬盘的目的。 Commit 日志的实现如果我们把对每个 Tablet 的操作的 Commit 日志都存在一个单独的文件的话，那么就会产生大量的文件， 并且这些文件会并行的写入 GFS。根据 GFS 服务器底层文件系统实现的方案，要把这些文件写入不同的磁盘 日志文件时24，会有大量的磁盘 Seek 操作。另外，由于批量提交25中操作的数目一般比较少，因此，对每个 Tablet 设置单独的日志文件也会给批量提交本应具有的优化效果带来很大的负面影响。为了避免这些问题，我 们设置每个 Tablet 服务器一个 Commit 日志文件，把修改操作的日志以追加方式写入同一个日志文件，因此 一个实际的日志文件中混合了对多个 Tablet 修改的日志记录。 使用单个日志显著提高了普通操作的性能，但是将恢复的工作复杂化了。当一个 Tablet 服务器宕机时， 它加载的 Tablet 将会被移到很多其它的 Tablet 服务器上:每个 Tablet 服务器都装载很少的几个原来的服务器 的 Tablet。当恢复一个 Tablet 的状态的时候，新的 Tablet 服务器要从原来的 Tablet 服务器写的日志中提取修改 操作的信息，并重新执行。然而，这些 Tablet 修改操作的日志记录都混合在同一个日志文件中的。一种方法 新的 Tablet 服务器读取完整的 Commit 日志文件，然后只重复执行它需要恢复的 Tablet 的相关修改操作。使 用这种方法，假如有 100 台 Tablet 服务器，每台都加载了失效的 Tablet 服务器上的一个 Tablet，那么，这个日 志文件就要被读取 100 次(每个服务器读取一次)。 为了避免多次读取日志文件，我们首先把日志按照关键字(table，row name，log sequence number)排序。 排序之后，对同一个 Tablet 的修改操作的日志记录就连续存放在了一起，因此，我们只要一次磁盘 Seek 操作、之后顺序读取就可以了。为了并行排序，我们先将日志分割成 64MB 的段，之后在不同的 Tablet 服务器对段 进行并行排序。这个排序工作由 Master 服务器来协同处理，并且在一个 Tablet 服务器表明自己需要从 Commit 日志文件恢复 Tablet 时开始执行。 在向 GFS 中写 Commit 日志的时候可能会引起系统颠簸，原因是多种多样的(比如，写操作正在进行的时候，一个 GFS 服务器宕机了;或者连接三个 GFS 副本所在的服务器的网络拥塞或者过载了)。为了确保在 GFS 负载高峰时修改操作还能顺利进行，每个 Tablet 服务器实际上有两个日志写入线程，每个线程都写自己 的日志文件，并且在任何时刻，只有一个线程是工作的。如果一个线程的在写入的时候效率很低，Tablet 服务 器就切换到另外一个线程，修改操作的日志记录就写入到这个线程对应的日志文件中。每个日志记录都有一 个序列号，因此，在恢复的时候，Tablet 服务器能够检测出并忽略掉那些由于线程切换而导致的重复的记录。 Tablet 恢复提速当 Master 服务器将一个 Tablet 从一个 Tablet 服务器移到另外一个 Tablet 服务器时，源 Tablet 服务器会对 这个 Tablet 做一次 Minor Compaction。这个 Compaction 操作减少了 Tablet 服务器的日志文件中没有归并的记 录，从而减少了恢复的时间。Compaction 完成之后，该服务器就停止为该 Tablet 提供服务。在卸载 Tablet 之 前，源 Tablet 服务器还会再做一次(通常会很快)Minor Compaction，以消除前面在一次压缩过程中又产生的 未归并的记录。第二次 Minor Compaction 完成以后，Tablet 就可以被装载到新的 Tablet 服务器上了，并且不 需要从日志中进行恢复。 利用不变性我们在使用 Bigtable 时，除了 SSTable 缓存之外的其它部分产生的 SSTable 都是不变的，我们可以利用这 一点对系统进行简化。例如，当从 SSTable 读取数据的时候，我们不必对文件系统访问操作进行同步。这样 一来，就可以非常高效的实现对行的并行操作。memtable 是唯一一个能被读和写操作同时访问的可变数据结 构。为了减少在读操作时的竞争，我们对内存表采用 COW(Copy-on-write)机制，这样就允许读写操作并行执 行。 因为 SSTable 是不变的，因此，我们可以把永久删除被标记为“删除”的数据的问题，转换成对废弃的 SSTable 进行垃圾收集的问题了。每个 Tablet 的 SSTable 都在 METADATA 表中注册了。Master 服务器采用“标 记-删除”的垃圾回收方式删除 SSTable 集合中废弃的 SSTable【25】，METADATA 表则保存了 Root SSTable 的集合。 最后，SSTable 的不变性使得分割 Tablet 的操作非常快捷。我们不必为每个分割出来的 Tablet 建立新的 SSTable 集合，而是共享原来的 Tablet 的 SSTable 集合。 性能评估 为了测试 Bigtable 的性能和可扩展性，我们建立了一个包括 N 台 Tablet 服务器的 Bigtable 集群，这里 N 是可变的。每台 Tablet 服务器配置了 1GB 的内存，数据写入到一个包括 1786 台机器、每台机器有 2 个 IDE 硬盘的 GFS 集群上。我们使用 N 台客户机生成工作负载测试 Bigtable。(我们使用和 Tablet 服务器相同数目的 客户机以确保客户机不会成为瓶颈。) 每台客户机配置 2GZ 双核 Opteron 处理器，配置了足以容纳所有进程 工作数据集的物理内存，以及一张 Gigabit 的以太网卡。这些机器都连入一个两层的、树状的交换网络里，在 根节点上的带宽加起来有大约 100-200Gbps。所有的机器采用相同的设备，因此，任何两台机器间网络来回一 次的时间都小于 1ms。 Tablet 服务器、Master 服务器、测试机、以及 GFS 服务器都运行在同一组机器上。每台机器都运行一个 GFS 的服务器。其它的机器要么运行 Tablet 服务器、要么运行客户程序、要么运行在测试过程中，使用这组 机器的其它的任务启动的进程。 R 是测试过程中，Bigtable 包含的不同的列关键字的数量。我们精心选择 R 的值，保证每次基准测试对每 台 Tablet 服务器读/写的数据量都在 1GB 左右。 在序列写的基准测试中，我们使用的列关键字的范围是 0 到 R-1。这个范围又被划分为 10N 个大小相同 的区间。核心调度程序把这些区间分配给 N 个客户端，分配方式是:只要客户程序处理完上一个区间的数据， 调度程序就把后续的、尚未处理的区间分配给它。这种动态分配的方式有助于减少客户机上同时运行的其它 进程对性能的影响。我们在每个列关键字下写入一个单独的字符串。每个字符串都是随机生成的、因此也没 有被压缩26。另外，不同列关键字下的字符串也是不同的，因此也就不存在跨行的压缩。随机写入基准测试采 用类似的方法，除了行关键字在写入前先做 Hash，Hash 采用按 R 取模的方式，这样就保证了在整个基准测 试持续的时间内，写入的工作负载均匀的分布在列存储空间内。 序列读的基准测试生成列关键字的方式与序列写相同，不同于序列写在列关键字下写入字符串的是，序 列读是读取列关键字下的字符串(这些字符串由之前序列写基准测试程序写入)。同样的，随机读的基准测试 和随机写是类似的。 扫描基准测试和序列读类似，但是使用的是 BigTable 提供的、从一个列范围内扫描所有的 value 值的 API。 由于一次 RPC 调用就从一个 Tablet 服务器取回了大量的 Value 值，因此，使用扫描方式的基准测试程序可以 减少 RPC 调用的次数。 随机读(内存)基准测试和随机读类似，除了包含基准测试数据的局部性群组被设置为“in-memory”， 因此，读操作直接从 Tablet 服务器的内存中读取数据，不需要从 GFS 读取数据。针对这个测试，我们把每台Tablet 服务器存储的数据从 1GB 减少到 100MB，这样就可以把数据全部加载到 Tablet 服务器的内存中了。图 6 中有两个视图，显示了我们的基准测试的性能;图中的数据和曲线是读/写 1000-byte value 值时取得 的。图中的表格显示了每个 Tablet 服务器每秒钟进行的操作的次数;图中的曲线显示了每秒种所有的 Tablet 服务器上操作次数的总和。 单个 Tablet 服务器的性能我们首先分析下单个 Tablet 服务器的性能。随机读的性能比其它操作慢一个数量级或以上27。 每个随机 读操作都要通过网络从 GFS 传输 64KB 的 SSTable 到 Tablet 服务器，而我们只使用其中大小是 1000 byte 的一 个 value 值。Tablet 服务器每秒大约执行 1200 次读操作，也就是每秒大约从 GFS 读取 75MB 的数据。这个传 输带宽足以占满 Tablet 服务器的 CPU 时间，因为其中包括了网络协议栈的消耗、SSTable 解析、以及 BigTable 代码执行;这个带宽也足以占满我们系统中网络的链接带宽。大多数采用这种访问模式 BigTable 应用程序会 减小 Block 的大小，通常会减到 8KB。 内存中的随机读操作速度快很多，原因是，所有 1000-byte 的读操作都是从 Tablet 服务器的本地内存中读 取数据，不需要从 GFS 读取 64KB 的 Block。 随机和序列写操作的性能比随机读要好些，原因是每个 Tablet 服务器直接把写入操作的内容追加到一个 Commit 日志文件的尾部，并且采用批量提交的方式，通过把数据以流的方式写入到 GFS 来提高性能。随机 写和序列写在性能上没有太大的差异，这两种方式的写操作实际上都是把操作内容记录到同一个 Tablet 服务 器的 Commit 日志文件中。 序列读的性能好于随机读，因为每取出 64KB 的 SSTable 的 Block 后，这些数据会缓存到 Block 缓存中， 后续的 64 次读操作直接从缓存读取数据。 扫描的性能更高，这是由于客户程序每一次 RPC 调用都会返回大量的 value 的数据，所以，RPC 调用的 消耗基本抵消了。 性能提升随着我们将系统中的 Tablet 服务器从 1 台增加到 500 台，系统的整体吞吐量有了梦幻般的增长，增长的 倍率超过了 100。比如，随着 Tablet 服务器的数量增加了 500 倍，内存中的随机读操作的性能增加了 300 倍。 之所以会有这样的性能提升，主要是因为这个基准测试的瓶颈是单台 Tablet 服务器的 CPU。 尽管如此，性能的提升还不是线性的。在大多数的基准测试中我们看到，当 Tablet 服务器的数量从 1 台 增加到 50 台时，每台服务器的吞吐量会有一个明显的下降。这是由于多台服务器间的负载不均衡造成的，大 多数情况下是由于其它的程序抢占了 CPU。 我们负载均衡的算法会尽量避免这种不均衡，但是基于两个主要 原因，这个算法并不能完美的工作:一个是尽量减少 Tablet 的移动导致重新负载均衡能力受限(如果 Tablet 被移动了，那么在短时间内 — 一般是 1 秒内 — 这个 Tablet 是不可用的)，另一个是我们的基准测试程序产 生的负载会有波动28。 随机读基准测试的测试结果显示，随机读的性能随 Tablet 服务器数量增加的提升幅度最小(整体吞吐量 只提升了 100 倍，而服务器的数量却增加了 500 倍)。这是因为每个 1000-byte 的读操作都会导致一个 64KB 大的 Block 在网络上传输。这样的网络传输量消耗了我们网络中各种共享的 1GB 的链路，结果导致随着我们 增加服务器的数量，每台服务器上的吞吐量急剧下降。 实际应用 截止到 2006 年 8 月，Google 内部一共有 388 个非测试用的 Bigtable 集群运行在各种各样的服务器集群上， 合计大约有 24500 个 Tablet 服务器。表 1 显示了每个集群上 Tablet 服务器的大致分布情况。这些集群中，许 多用于开发目的，因此会有一段时期比较空闲。通过观察一个由 14 个集群、8069 个 Tablet 服务器组成的集群 组，我们看到整体的吞吐量超过了每秒 1200000 次请求，发送到系统的 RPC 请求导致的网络负载达到了 741MB/s，系统发出的 RPC 请求网络负载大约是 16GB/s。表 2 提供了一些目前正在使用的表的相关数据。一些表存储的是用户相关的数据，另外一些存储的则是 用于批处理的数据;这些表在总的大小、 每个数据项的平均大小、从内存中读取的数据的比例、表的 Schema 的复杂程度上都有很大的差别。本节的其余部分，我们将主要描述三个产品研发团队如何使用 Bigtable 的。 Google AnalyticsGoogle Analytics 是用来帮助 Web 站点的管理员分析他们网站的流量模式的服务。它提供了整体状况的统 计数据，比如每天的独立访问的用户数量、每天每个 URL 的浏览次数;它还提供了用户使用网站的行为报告， 比如根据用户之前访问的某些页面，统计出几成的用户购买了商品。 为了使用这个服务，Web 站点的管理员只需要在他们的 Web 页面中嵌入一小段 JavaScript 脚本就可以了。 这个 Javascript 程序在页面被访问的时候调用。它记录了各种 Google Analytics 需要使用的信息，比如用户的 标识、获取的网页的相关信息。Google Analytics 汇总这些数据，之后提供给 Web 站点的管理员。 我们粗略的描述一下 Google Analytics 使用的两个表。Row Click 表(大约有 200TB 数据)的每一行存放 了一个最终用户的会话。行的名字是一个包含 Web 站点名字以及用户会话创建时间的元组。这种模式保证了 对同一个 Web 站点的访问会话是顺序的，会话按时间顺序存储。这个表可以压缩到原来尺寸的 14%。 Summary 表(大约有 20TB 的数据)包含了关于每个 Web 站点的、各种类型的预定义汇总信息。一个周 期性运行的 MapReduce 任务根据 Raw Click 表的数据生成 Summary 表的数据。每个 MapReduce 工作进程都 从 Raw Click 表中提取最新的会话数据。系统的整体吞吐量受限于 GFS 的吞吐量。这个表的能够压缩到原有 尺寸的 29%。 Google EarthGoogle 通过一组服务为用户提供了高分辨率的地球表面卫星图像，访问的方式可以使通过基于 Web 的 Google Maps 访问接口(maps.google.com)，也可以通过 Google Earth 定制的客户端软件访问。这些软件产品 允许用户浏览地球表面的图像:用户可以在不同的分辨率下平移、查看和注释这些卫星图像。这个系统使用一个表存储预处理数据，使用另外一组表存储用户数据。 数据预处理流水线使用一个表存储原始图像。在预处理过程中，图像被清除，图像数据合并到最终的服务数据中。这个表包含了大约 70TB 的数据，所以需要从磁盘读取数据。图像已经被高效压缩过了，因此存 储在 Bigtable 后不需要再压缩了。 Imagery 表的每一行都代表了一个单独的地理区域。行都有名称，以确保毗邻的区域存储在了一起。 Imagery 表中有一个列族用来记录每个区域的数据源。这个列族包含了大量的列:基本上市每个列对应一个原 始图片的数据。由于每个地理区域都是由很少的几张图片构成的，因此这个列族是非常稀疏的。 数据预处理流水线高度依赖运行在 Bigtable 上的 MapReduce 任务传输数据。在运行某些 MapReduce 任务 的时候，整个系统中每台 Tablet 服务器的数据处理速度是 1MB/s。 这个服务系统使用一个表来索引 GFS 中的数据。这个表相对较小(大约是 500GB)，但是这个表必须在 保证较低的响应延时的前提下，针对每个数据中心，每秒处理几万个查询请求。 因此，这个表必须在上百个 Tablet 服务器上存储数据，并且使用 in-memory 的列族。 个性化查询个性化查询(www.google.com/psearch)是一个双向服务;这个服务记录用户的查询和点击，涉及到各种 Google 的服务，比如 Web 查询、图像和新闻。用户可以浏览他们查询的历史，重复他们之前的查询和点击; 用户也可以定制基于 Google 历史使用习惯模式的个性化查询结果。 个性化查询使用 Bigtable 存储每个用户的数据。每个用户都有一个唯一的用户 id，每个用户 id 和一个列 名绑定。一个单独的列族被用来存储各种类型的行为(比如，有个列族可能是用来存储所有的 Web 查询的)。 每个数据项都被用作 Bigtable 的时间戳，记录了相应的用户行为发生的时间。个性化查询使用以 Bigtable 为 存储的 MapReduce 任务生成用户的数据图表。这些用户数据图表用来个性化当前的查询结果。 个性化查询的数据会复制到几个 Bigtable 的集群上，这样就增强了数据可用性，同时减少了由客户端和 Bigtable 集群间的“距离”造成的延时。个性化查询的开发团队最初建立了一个基于 Bigtable 的、“客户侧” 的复制机制为所有的复制节点提供一致性保障。现在的系统则使用了内建的复制子系统。 个性化查询存储系统的设计允许其它的团队在它们自己的列中加入新的用户数据，因此，很多 Google 服 务使用个性化查询存储系统保存用户级的配置参数和设置。在多个团队之间分享数据的结果是产生了大量的 列族。为了更好的支持数据共享，我们加入了一个简单的配额机制29限制用户在共享表中使用的空间;配额也 为使用个性化查询系统存储用户级信息的产品团体提供了隔离机制。 经验教训 在设计、实现、维护和支持 Bigtable 的过程中，我们得到了很多有用的经验和一些有趣的教训。一个教训是，我们发现，很多类型的错误都会导致大型分布式系统受损，这些错误不仅仅是通常的网络 中断、或者很多分布式协议中设想的 fail-stop 类型的错误30。比如，我们遇到过下面这些类型的错误导致的问 题:内存数据损坏、网络中断、时钟偏差、机器挂起、扩展的和非对称的网络分区31、我们使用的其它系统的 Bug(比如 Chubby)、GFS 配额溢出、计划内和计划外的硬件维护。我们在解决这些问题的过程中学到了很多 经验，我们通过修改协议来解决这些问题。比如，我们在我们的 RPC 机制中加入了 Checksum。我们在设计 系统的部分功能时，不对其它部分功能做任何的假设，这样的做法解决了其它的一些问题。比如，我们不再 假设一个特定的 Chubby 操作只返回错误码集合中的一个值。 另外一个教训是，我们明白了在彻底了解一个新特性会被如何使用之后，再决定是否添加这个新特性是 非常重要的。比如，我们开始计划在我们的 API 中支持通常方式的事务处理。但是由于我们还不会马上用到 这个功能，因此，我们并没有去实现它。现在，Bigtable 上已经有了很多的实际应用，我们可以检查它们真实 的需求;我们发现，大多是应用程序都只是需要单个行上的事务功能。有些应用需要分布式的事务功能，分 布式事务大多数情况下用于维护二级索引，因此我们增加了一个特殊的机制去满足这个需求。新的机制在通 用性上比分布式事务差很多，但是它更有效(特别是在更新操作的涉及上百行数据的时候)，而且非常符合我 们的“跨数据中心”复制方案的优化策略。 还有一个具有实践意义的经验:我们发现系统级的监控对 Bigtable 非常重要(比如，监控 Bigtable 自身 以及使用 Bigtable 的客户程序)。比如，我们扩展了我们的 RPC 系统，因此对于一个 RPC 调用的例子，它可 以详细记录代表了 RPC 调用的很多重要操作。这个特性允许我们检测和修正很多的问题，比如 Tablet 数据结 构上的锁的内容、在修改操作提交时对 GFS 的写入非常慢的问题、以及在 METADATA 表的 Tablet 不可用时， 对 METADATA 表的访问挂起的问题。关于监控的用途的另外一个例子是，每个 Bigtable 集群都在 Chubby 中 注册了。这可以帮助我们跟踪所有的集群状态、监控它们的大小、检查集群运行的我们软件的版本、监控集 群流入数据的流量，以及检查是否有引发集群高延时的潜在因素。 对我们来说，最宝贵的经验是简单设计的价值。考虑到我们系统的代码量(大约 100000 行生产代码32)， 以及随着时间的推移，新的代码以各种难以预料的方式加入系统，我们发现简洁的设计和编码给维护和调试 带来的巨大好处。这方面的一个例子是我们的 Tablet 服务器成员协议。我们第一版的协议很简单:Master 服务器周期性的和 Tablet 服务器签订租约，Tablet 服务器在租约过期的时候 Kill 掉自己的进程。不幸的是，这 个协议在遇到网络问题时会大大降低系统的可用性，也会大大增加 Master 服务器恢复的时间。我们多次重新 设计这个协议，直到它能够很好的处理上述问题。但是，更不幸的是，最终的协议过于复杂了，并且依赖一 些 Chubby 很少被用到的特性。我们发现我们浪费了大量的时间在调试一些古怪的问题33，有些是 Bigtable 代 码的问题，有些是 Chubby 代码的问题。最后，我们只好废弃了这个协议，重新制订了一个新的、更简单、只使用 Chubby 最广泛使用的特性的协议。 相关工作 Boxwood 项目的有些组件在某些方面和 Chubby、GFS 以及 Bigtable 类似，因为它也提供了诸如分 布式协议、锁、分布式 Chunk 存储以及分布式 B-tree 存储。Boxwood 与 Google 的某些组件尽管功能类似， 但是 Boxwood 的组件提供更底层的服务。Boxwood 项目的目的是提供创建类似文件系统、数据库等高级服务 的基础构件，而 Bigtable 的目的是直接为客户程序的数据存储需求提供支持。 现在有不少项目已经攻克了很多难题，实现了在广域网上的分布式数据存储或者高级服务，通常是 “Internet 规模”的。这其中包括了分布式的 Hash 表，这项工作由一些类似 CAN【29】、Chord【32】、Tapestry 【37】和 Pastry【30】的项目率先发起。这些系统的主要关注点和 Bigtable 不同，比如应对各种不同的传输带 宽、不可信的协作者、频繁的更改配置等;另外，去中心化和 Byzantine 灾难冗余也不是 Bigtable 的目的。 就提供给应用程序开发者的分布式数据存储模型而言，我们相信，分布式 B-Tree 或者分布式 Hash 表提 供的 Key-value pair 方式的模型有很大的局限性。Key-value pair 模型是很有用的组件，但是它们不应该是提供给开发者唯一的组件。我们选择的模型提供的组件比简单的 Key-value pair 丰富的多，它支持稀疏的、半结构 化的数据。另外，它也足够简单，能够高效的处理平面文件;它也是透明的(通过局部性群组)，允许我们的 使用者对系统的重要行为进行调整。 有些数据库厂商已经开发出了并行的数据库系统，能够存储海量的数据。Oracle 的 RAC【27】使用共享 磁盘存储数据(Bigtable 使用 GFS)，并且有一个分布式的锁管理系统(Bigtable 使用 Chubby)。IBM 并行版 本的 DB2【4】基于一种类似于 Bigtable 的、不共享任何东西的架构35【33】。每个 DB2 的服务器都负责处理 存储在一个关系型数据库中的表中的行的一个子集。这些产品都提供了一个带有事务功能的完整的关系模型。 Bigtable 采用 memtable 和 SSTable 存储对表的更新的方法与 Log-Structured Merge Tree【26】存储索引数据更新的方法类似。这两个系统中，排序的数据在写入到磁盘前都先存放在内存中，读取操作必须从内存和磁盘中合并数据产生最终的结果集。 C-Store 和 Bigtable 有很多相似点:两个系统都采用 Shared-nothing 架构，都有两种不同的数据结构，一 种用于当前的写操作，另外一种存放“长时间使用”的数据，并且提供一种机制在两个存储结构间搬运数据。 两个系统在 API 接口函数上有很大的不同:C-Store 操作更像关系型数据库，而 Bigtable 提供了低层次的读写 操作接口，并且设计的目标是能够支持每台服务器每秒数千次操作。C-Store 同时也是个“读性能优化的关系 型数据库”，而 Bigtable 对读和写密集型应用都提供了很好的性能。 Bigtable 也必须解决所有的 Shared-nothing 数据库需要面对的、类型相似的一些负载和内存均衡方面的难 题(比如，【11，35】)。我们的问题在某种程度上简单一些: 我们不需要考虑同一份数据可能有多个拷贝的问题，同一份数据可能由于视图或索引的原因以不同 的形式表现出来; 我们让用户决定哪些数据应该放在内存里、哪些放在磁盘上，而不是由系统动态的判断; 3. 我们的系统中没有复杂的查询执行或优化工作。 结论 我们已经讲述完了 Bigtable，Google 的一个分布式的结构化数据存储系统。Bigtable 的集群从 2005 年 4 月开始已经投入使用了，在此之前，我们花了大约 7 人年设计和实现这个系统。截止到 2006 年 4 月，已经有 超过 60 个项目使用 Bigtable 了。我们的用户对 Bigtable 提供的高性能和高可用性很满意，随着时间的推移， 他们可以根据自己的系统对资源的需求增加情况，通过简单的增加机器，扩展系统的承载能力。 由于 Bigtable 提供的编程接口并不常见，一个有趣的问题是:我们的用户适应新的接口有多难?新的使 用者有时不太确定使用 Bigtable 接口的最佳方法，特别是在他们已经习惯于使用支持通用事务的关系型数据 库的接口的情况下。但是，Google 内部很多产品都成功的使用了 Bigtable 的事实证明了，我们的设计在实践 中行之有效。 我们现在正在对 Bigtable 加入一些新的特性，比如支持二级索引，以及支持多 Master 节点的、跨数据中心复制的 Bigtable 的基础构件。我们现在已经开始将 Bigtable 部署为服务供其它的产品团队使用，这样不同 的产品团队就不需要维护他们自己的 Bigtable 集群了。随着服务集群的扩展，我们需要在 Bigtable 系统内部处理更多的关于资源共享的问题了【3，5】。 最后，我们发现，建设 Google 自己的存储解决方案带来了很多优势。通过为 Bigtable 设计我们自己的数据模型，是我们的系统极具灵活性。另外，由于我们全面控制着 Bigtable 的实现过程，以及 Bigtable 使用到 的其它的 Google 的基础构件，这就意味着我们在系统出现瓶颈或效率低下的情况时，能够快速的解决这些问 题。 Acknowledgements We thank the anonymous reviewers, David Nagle, and our shepherd Brad Calder, for their feedback on this paper.The Bigtable system has benefited greatly from the feedback of our many users within Google. In addition,we thank the following people for their contributions to Bigtable: Dan Aguayo, Sameer Ajmani, Zhifeng Chen,Bill Coughran, Mike Epstein, Healfdene Goguen, Robert Griesemer, Jeremy Hylton, Josh Hyman, Alex Khesin,Joanna Kulik, Alberto Lerner, Sherry Listgarten, Mike Maloney, Eduardo Pinheiro, Kathy Polizzi, Frank Yellin,and Arthur Zwiegincew. References [1] ABADI, D. J., MADDEN, S. R., AND FERREIRA, M. C. Integrating compression and execution in columnoriented database systems. Proc. of SIGMOD (2006).[2] AILAMAKI, A., DEWITT, D. J., HILL, M. D., AND SKOUNAKIS, M. Weaving relations for cache performance.In The VLDB Journal (2001), pp. 169-180.[3] BANGA, G., DRUSCHEL, P., AND MOGUL, J. C. Resource containers: A new facility for resource management in server systems. In Proc. of the 3rd OSDI (Feb. 1999), pp. 45-58.[4] BARU, C. K., FECTEAU, G., GOYAL, A., HSIAO, H., JHINGRAN, A., PADMANABHAN, S., COPELAND,G. P., AND WILSON, W. G. DB2 parallel edition. IBM Systems Journal 34, 2 (1995), 292-322.[5] BAVIER, A., BOWMAN, M., CHUN, B., CULLER, D., KARLIN, S., PETERSON, L., ROSCOE, T., SPALINK, T., AND WAWRZONIAK, M. Operating system support for planetary-scale network services. In Proc. of the 1st NSDI(Mar. 2004), pp. 253-266.[6] BENTLEY, J. L., AND MCILROY, M. D. Data compression using long common strings. In Data Compression Conference (1999), pp. 287-295.[7] BLOOM, B. H. Space/time trade-offs in hash coding with allowable errors. CACM 13, 7 (1970), 422-426.[8] BURROWS, M. The Chubby lock service for looselycoupled distributed systems. In Proc. of the 7th OSDI (Nov. 2006).[9] CHANDRA, T., GRIESEMER, R., AND REDSTONE, J.Paxos made live ? An engineering perspective. In Proc. of PODC (2007).[10] COMER, D. Ubiquitous B-tree. Computing Surveys 11, 2 (June 1979), 121-137.[11] COPELAND, G. P., ALEXANDER, W., BOUGHTER, E. E., AND KELLER, T. W. Data placement in Bubba. In Proc. of SIGMOD (1988), pp. 99-108.[12] DEAN, J., AND GHEMAWAT, S. MapReduce: Simplified data processing on large clusters. In Proc. of the 6th OSDI (Dec. 2004), pp. 137-150.[13] DEWITT, D., KATZ, R., OLKEN, F., SHAPIRO, L., STONEBRAKER, M., AND WOOD, D. Implementation techniques for main memory database systems. In Proc. of SIGMOD (June 1984), pp. 1-8.[14] DEWITT, D. J., AND GRAY, J. Parallel database systems: The future of high performance database systems. CACM 35, 6 (June 1992), 85-98.[15] FRENCH, C. D. One size ts all database architectures do not work for DSS. In Proc. of SIGMOD (May 1995), pp. 449-450.[16] GAWLICK, D., AND KINKADE, D. Varieties of concurrency control in IMS/VS fast path. Database Engineering Bulletin 8, 2 (1985), 3-10.[17] GHEMAWAT, S., GOBIOFF, H., AND LEUNG, S.-T. The Google file system. In Proc. of the 19th ACM SOSP (Dec.2003), pp. 29-43.[18] GRAY, J. Notes on database operating systems. In Operating Systems ? An Advanced Course, vol. 60 of Lecture Notes in Computer Science. Springer-Verlag, 1978.[19] GREER, R. Daytona and the fourth-generation language Cymbal. In Proc. of SIGMOD (1999), pp. 525-526.[20] HAGMANN, R. Reimplementing the Cedar file system using logging and group commit. In Proc. of the 11th SOSP (Dec. 1987), pp. 155-162.[21] HARTMAN, J. H., AND OUSTERHOUT, J. K. The Zebra striped network file system. In Proc. of the 14th SOSP(Asheville, NC, 1993), pp. 29-43.[22] KX.COM. kx.com/products/database.php. Product page.[23] LAMPORT, L. The part-time parliament. ACM TOCS 16,2 (1998), 133-169.[24] MACCORMICK, J., MURPHY, N., NAJORK, M., THEKKATH, C. A., AND ZHOU, L.Boxwood:Abstractions as the foundation for storage infrastructure. In Proc. of the 6th OSDI (Dec. 2004), pp. 105-120.[25] MCCARTHY, J. Recursive functions of symbolic expressions and their computation by machine. CACM 3,4 (Apr. 1960), 184-195.[26] O’NEIL, P., CHENG, E., GAWLICK, D., AND O’NEIL, E. The log-structured merge-tree (LSM-tree).Acta Inf. 33, 4 (1996), 351-385.[27] ORACLE.COM. www.oracle.com/technology/products/database/clustering/index.html. Product page.[28] PIKE, R., DORWARD, S., GRIESEMER, R., AND QUINLAN, S. Interpreting the data: Parallel analysiswith Sawzall. Scientific Programming Journal 13, 4 (2005), 227-298.[29] RATNASAMY, S., FRANCIS, P., HANDLEY, M., KARP, R., AND SHENKER, S. A scalablecontent-addressable network. In Proc. of SIGCOMM (Aug. 2001), pp. 161-172.[30] ROWSTRON, A., AND DRUSCHEL, P. Pastry: Scalable, distributed object location and routing forlargescale peer-to-peer systems. In Proc. of Middleware 2001(Nov. 2001), pp. 329-350.[31] SENSAGE.COM. sensage.com/products-sensage.htm. Product page.[32] STOICA, I., MORRIS, R., KARGER, D., KAASHOEK, M. F., AND BALAKRISHNAN, H. Chord: Ascalable peer-to-peer lookup service for Internet applications. In Proc. of SIGCOMM (Aug. 2001), pp. 149-160.[33] STONEBRAKER, M. The case for shared nothing. Database Engineering Bulletin 9, 1 (Mar. 1986), 4-9. [34] STONEBRAKER,M., ABADI, D. J., BATKIN, A., CHEN, X., CHERNIACK, M., FERREIRA, M., LAU,E., LIN, A., MADDEN, S., O’NEIL, E., O’NEIL, P., RASIN, A., TRAN, N., AND ZDONIK, S. C-Store: A columnoriented DBMS. In Proc. of VLDB (Aug. 2005), pp. 553-564.[35] STONEBRAKER, M., AOKI, P. M., DEVINE, R., LITWIN, W., AND OLSON, M. A. Mariposa: A new architecture for distributed data. In Proc. of the Tenth ICDE(1994), IEEE Computer Society, pp. 54-65.[36] SYBASE.COM. www.sybase.com/products/databaseservers/sybaseiq. Product page.[37] ZHAO, B. Y., KUBIATOWICZ, J., AND JOSEPH, A. D. Tapestry: An infrastructure for fault-tolerant wide-area location and routing. Tech. Rep. UCB/CSD-01-1141, CS Division, UC Berkeley, Apr. 2001.[38] ZUKOWSKI, M., BONCZ, P. A., NES, N., AND HEMAN, S. MonetDB/X100 ?A DBMS in the CPU cache. IEEE Data Eng. Bull. 28, 2 (2005), 17-22.","raw":null,"content":null,"categories":[{"name":"paper","slug":"paper","permalink":"https://freehubs.github.io/categories/paper/"}],"tags":[{"name":"paper","slug":"paper","permalink":"https://freehubs.github.io/tags/paper/"}]},{"title":"Google MapReduce 中文版","slug":"Google-MapReduce-中文版","date":"2017-12-16T10:06:41.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/12/16/Google-MapReduce-中文版/","link":"","permalink":"https://freehubs.github.io/2017/12/16/Google-MapReduce-中文版/","excerpt":"\n            摘要\n          \nMapReduce 是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一 个 Map 函数处理一个基于 key/value pair 的数据集合，输出中间的基于 key/value pair 的数据集合;然后再创建 一个 Reduce 函数用来合并所有的具有相同中间 key 值的中间 value 值。现实世界中有很多满足上述处理模型 的例子，本论文将详细描述这个模型。\nMapReduce 架构的程序能够在大量的普通配置的计算机上实现并行化处理。这个系统在运行时只关心: 如何分割输入数据，在大量计算机组成的集群上的调度，集群中计算机的错误处理，管理集群中计算机之间 必要的通信。采用 MapReduce 架构可以使那些没有并行计算和分布式处理系统开发经验的程序员有效利用分 布式系统的丰富资源。\n我们的 MapReduce 实现运行在规模可以灵活调整的由普通机器组成的集群上:一个典型的 MapReduce 计算往往由几千台机器组成、处理以 TB 计算的数据。程序员发现这个系统非常好用:已经实现了数以百计 的 MapReduce 程序，在 Google 的集群上，每天都有 1000 多个 MapReduce 程序在执行。","text":"摘要 MapReduce 是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一 个 Map 函数处理一个基于 key/value pair 的数据集合，输出中间的基于 key/value pair 的数据集合;然后再创建 一个 Reduce 函数用来合并所有的具有相同中间 key 值的中间 value 值。现实世界中有很多满足上述处理模型 的例子，本论文将详细描述这个模型。 MapReduce 架构的程序能够在大量的普通配置的计算机上实现并行化处理。这个系统在运行时只关心: 如何分割输入数据，在大量计算机组成的集群上的调度，集群中计算机的错误处理，管理集群中计算机之间 必要的通信。采用 MapReduce 架构可以使那些没有并行计算和分布式处理系统开发经验的程序员有效利用分 布式系统的丰富资源。 我们的 MapReduce 实现运行在规模可以灵活调整的由普通机器组成的集群上:一个典型的 MapReduce 计算往往由几千台机器组成、处理以 TB 计算的数据。程序员发现这个系统非常好用:已经实现了数以百计 的 MapReduce 程序，在 Google 的集群上，每天都有 1000 多个 MapReduce 程序在执行。 介绍 在过去的 5 年里，包括本文作者在内的 Google 的很多程序员，为了处理海量的原始数据，已经实现了数 以百计的、专用的计算方法。这些计算方法用来处理大量的原始数据，比如，文档抓取(类似网络爬虫的程 序)、Web 请求日志等等;也为了计算处理各种类型的衍生数据，比如倒排索引、Web 文档的图结构的各种表 示形势、每台主机上网络爬虫抓取的页面数量的汇总、每天被请求的最多的查询的集合等等。大多数这样的 数据处理运算在概念上很容易理解。然而由于输入的数据量巨大，因此要想在可接受的时间内完成运算，只 有将这些计算分布在成百上千的主机上。如何处理并行计算、如何分发数据、如何处理错误?所有这些问题 综合在一起，需要大量的代码处理，因此也使得原本简单的运算变得难以处理。 为了解决上述复杂的问题，我们设计一个新的抽象模型，使用这个抽象模型，我们只要表述我们想要执 行的简单运算即可，而不必关心并行计算、容错、数据分布、负载均衡等复杂的细节，这些问题都被封装在 了一个库里面。设计这个抽象模型的灵感来自 Lisp 和许多其他函数式语言的 Map 和 Reduce 的原语。我们意 识到我们大多数的运算都包含这样的操作:在输入数据的“逻辑”记录上应用 Map 操作得出一个中间 key/value pair 集合，然后在所有具有相同 key 值的 value 值上应用 Reduce 操作，从而达到合并中间的数据，得到一个想要的结果的目的。使用 MapReduce 模型，再结合用户实现的 Map 和 Reduce 函数，我们就可以非常容易的 实现大规模并行化计算;通过 MapReduce 模型自带的“再次执行”(re-execution)功能，也提供了初级的容灾实现方案。 这个工作(实现一个 MapReduce 框架模型)的主要贡献是通过简单的接口来实现自动的并行化和大规模的分布式计算，通过使用 MapReduce 模型接口实现在大量普通的 PC 机上高性能计算。 第二部分描述基本的编程模型和一些使用案例。 第三部分描述了一个经过裁剪的、适合我们的基于集群的计算环境的 MapReduce 实现。 第四部分描述我们认为在 MapReduce 编程模型中一些实用的技巧。 第五部分对于各种不同的任务，测量我们 MapReduce 实现的性能。 第六部分揭示了在 Google 内部如何使用 MapReduce 作为基础重写我们的索引系统产品，包括其它一些 使用 MapReduce 的经验。 第七部分讨论相关的和未来的工作。 编程模型 MapReduce 编程模型的原理是:利用一个输入 key/value pair 集合来产生一个输出的 key/value pair 集合。 MapReduce 库的用户用两个函数表达这个计算:Map 和 Reduce。 用户自定义的 Map 函数接受一个输入的 key/value pair 值，然后产生一个中间 key/value pair 值的集合。 MapReduce 库把所有具有相同中间 key 值 I 的中间 value 值集合在一起后传递给 reduce 函数。 用户自定义的 Reduce 函数接受一个中间 key 的值 I 和相关的一个 value 值的集合。Reduce 函数合并这些 value 值，形成一个较小的 value 值的集合。一般的，每次 Reduce 函数调用只产生 0 或 1 个输出 value 值。通 常我们通过一个迭代器把中间 value 值提供给 Reduce 函数，这样我们就可以处理无法全部放入内存中的大量 的 value 值的集合。 例子例如，计算一个大的文档集合中每个单词出现的次数，下面是伪代码段: `map(String key, String value): // key: document name // value: document contents for each word w in value: EmitIntermediate(w, “1′′); reduce(String key, Iterator values): // key: a word // values: a list of counts int result = 0; for each v in values: result += ParseInt(v); Emit(AsString(result));12Map 函数输出文档中的每个词、以及这个词的出现次数(在这个简单的例子里就是 1)。Reduce 函数把 Map 函数产生的每一个特定的词的计数累加起来。 另外，用户编写代码，使用输入和输出文件的名字、可选的调节参数来完成一个符合 MapReduce 模型规 范的对象，然后调用 MapReduce 函数，并把这个规范对象传递给它。用户的代码和 MapReduce 库链接在一起 (用 C++实现)。附录 A 包含了这个实例的全部程序代码。 ### 类型 尽管在前面例子的伪代码中使用了以字符串表示的输入输出值，但是在概念上，用户定义的 Map 和 Reduce 函数都有相关联的类型: map(k1,v1) -&gt;list(k2,v2)reduce(k2,list(v2)) -&gt;list(v2)1234567891011121314 比如，输入的 key 和 value 值与输出的 key 和 value 值在类型上推导的域不同。此外，中间 key 和 value 值与输出 key 和 value 值在类型上推导的域相同。 我们的 C++中使用字符串类型作为用户自定义函数的输入输出，用户在自己的代码中对字符串进行适当 的类型转换。 ### 更多的例子 这里还有一些有趣的简单例子，可以很容易的使用 MapReduce 模型来表示: 分布式的 Grep:Map 函数输出匹配某个模式的一行，Reduce 函数是一个恒等函数，即把中间数据复制到 输出。 计算 URL 访问频率:Map 函数处理日志中 web 页面请求的记录，然后输出(URL,1)。Reduce 函数把相同URL 的 value 值都累加起来，产生(URL,记录总数)结果。 倒转网络链接图:Map 函数在源页面(source)中搜索所有的链接目标(target)并输出为(target,source)。Reduce 函数把给定链接目标(target)的链接组合成一个列表，输出(target,list(source))。 每个主机的检索词向量:检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些 词。Map 函数为每一个输入文档输出(主机名,检索词向量)，其中主机名来自文档的 URL。Reduce 函数接收给 定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索词，输出一个最终的(主 机名,检索词向量)。 倒排索引:Map 函数分析每个文档输出一个(词,文档号)的列表，Reduce 函数的输入是一个给定词的所有 (词，文档号)，排序所有的文档号，输出(词,list(文档号))。所有的输出集合形成一个简单的倒排索引，它 以一种简单的算法跟踪词在文档中的位置。 分布式排序:Map 函数从每个记录提取 key，输出(key,record)。Reduce 函数不改变任何的值。这个运算 依赖分区机制(在 4.1 描述)和排序属性(在 4.2 描述)。 &#123;% note info %&#125;## 实现 &#123;% endnote %&#125; MapReduce 模型可以有多种不同的实现方式。如何正确选择取决于具体的环境。例如，一种实现方式适 用于小型的共享内存方式的机器，另外一种实现方式则适用于大型 NUMA 架构的多处理器的主机，而有的实 现方式更适合大型的网络连接集群。 本章节描述一个适用于 Google 内部广泛使用的运算环境的实现:用以太网交换机连接、由普通 PC 机组 成的大型集群。在我们的环境里包括: 1. x86 架构、运行 Linux 操作系统、双处理器、2-4GB 内存的机器。 2. 普通的网络硬件设备，每个机器的带宽为百兆或者千兆，但是远小于网络的平均带宽的一半。 3. 集群中包含成百上千的机器，因此，机器故障是常态。 4. 存储为廉价的内置 IDE 硬盘。一个内部分布式文件系统用来管理存储在这些磁盘上的数据。文件系 统通过数据复制来在不可靠的硬件上保证数据的可靠性和有效性。 5. 用户提交工作(job)给调度系统。每个工作(job)都包含一系列的任务(task)，调度系统将这些任 务调度到集群中多台可用的机器上。 ### 执行概括 通过将 Map 调用的输入数据自动分割为 M 个数据片段的集合，Map 调用被分布到多台机器上执行。输 入的数据片段能够在不同的机器上并行处理。使用分区函数将 Map 调用产生的中间 key 值分成 R 个不同分区(例如，hash(key) mod R)，Reduce 调用也被分布到多台机器上执行。分区数量(R)和分区函数由用户来指定。![](http://oliji9s3j.bkt.clouddn.com/15133908393351.jpg) 图 1 展示了我们的 MapReduce 实现中操作的全部流程。当用户调用 MapReduce 函数时，将发生下面的一 系列动作(下面的序号和图 1 中的序号一一对应): 1. 用户程序首先调用的 MapReduce 库将输入文件分成 M 个数据片度，每个数据片段的大小一般从 16MB 到 64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量 的程序副本。 2. 这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是 worker 程序，由 master 分配 任务。有 M 个 Map 任务和 R 个 Reduce 任务将被分配，master 将一个 Map 任务或 Reduce 任务分配 给一个空闲的 worker。 3. 被分配了 map 任务的 worker 程序读取相关的输入数据片段，从输入的数据片段中解析出 key/value pair，然后把 key/value pair 传递给用户自定义的 Map 函数，由 Map 函数生成并输出的中间 key/value pair，并缓存在内存中。 4. 缓存中的 key/value pair 通过分区函数分成 R 个区域，之后周期性的写入到本地磁盘上。缓存的 key/value pair 在本地磁盘上的存储位置将被回传给 master，由 master 负责把这些存储位置再传送给 Reduce worker。 5. 当 Reduce worker 程序接收到 master 程序发来的数据存储位置信息后，使用 RPC 从 Map worker 所在 主机的磁盘上读取这些缓存数据。当 Reduce worker 读取了所有的中间数据后，通过对 key 进行排序后使得具有相同 key 值的数据聚合在一起。由于许多不同的 key 值会映射到相同的 Reduce 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。 6. Reduce worker 程序遍历排序后的中间数据，对于每一个唯一的中间 key 值，Reduce worker 程序将这 个 key 值和它相关的中间 value 值的集合传递给用户自定义的 Reduce 函数。Reduce 函数的输出被追加到所属分区的输出文件。 7. 当所有的 Map 和 Reduce 任务都完成之后，master 唤醒用户程序。在这个时候，在用户程序里的对MapReduce 调用才返回。 在成功完成任务之后，MapReduce 的输出存放在 R 个输出文件中(对应每个 Reduce 任务产生一个输出 文件，文件名由用户指定)。一般情况下，用户不需要将这 R 个输出文件合并成一个文件–他们经常把这些文 件作为另外一个 MapReduce 的输入，或者在另外一个可以处理多个分割文件的分布式应用中使用。 ### Master 数据结构 Master 持有一些数据结构，它存储每一个 Map 和 Reduce 任务的状态(空闲、工作中或完成)，以及 Worker 机器(非空闲任务的机器)的标识。 Master 就像一个数据管道，中间文件存储区域的位置信息通过这个管道从 Map 传递到 Reduce。因此， 对于每个已经完成的 Map 任务，master 存储了 Map 任务产生的 R 个中间文件存储区域的大小和位置。当 Map 任务完成时，Master 接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的 Reduce 任 务。 ### 容错 因为 MapReduce 库的设计初衷是使用由成百上千的机器组成的集群来处理超大规模的数据，所以，这个 库必须要能很好的处理机器故障。 #### worker 故障 master 周期性的 ping 每个 worker。如果在一个约定的时间范围内没有收到 worker 返回的信息，master 将 把这个 worker 标记为失效。所有由这个失效的 worker 完成的 Map 任务被重设为初始的空闲状态，之后这些 任务就可以被安排给其他的 worker。同样的，worker 失效时正在运行的 Map 或 Reduce 任务也将被重新置为 空闲状态，等待重新调度。 当 worker 故障时，由于已经完成的 Map 任务的输出存储在这台机器上，Map 任务的输出已不可访问了,因此必须重新执行。而已经完成的 Reduce 任务的输出存储在全局文件系统上，因此不需要再次执行。 当一个 Map 任务首先被 worker A 执行，之后由于 worker A 失效了又被调度到 worker B 执行，这个“重 新执行”的动作会被通知给所有执行 Reduce 任务的 worker。任何还没有从 worker A 读取数据的 Reduce 任务 将从 worker B 读取数据。 MapReduce 可以处理大规模 worker 失效的情况。比如，在一个 MapReduce 操作执行期间，在正在运行 的集群上进行网络维护引起 80 台机器在几分钟内不可访问了，MapReduce master 只需要简单的再次执行那些 不可访问的 worker 完成的工作，之后继续执行未完成的任务，直到最终完成这个 MapReduce 操作。 #### master 失败 一个简单的解决办法是让 master 周期性的将上面描述的数据结构(alex 注:指 3.2 节)的写入磁盘，即 检查点(checkpoint)。如果这个 master 任务失效了，可以从最后一个检查点(checkpoint)开始启动另一个 master 进程。然而，由于只有一个 master 进程，master 失效后再恢复是比较麻烦的，因此我们现在的实现是 如果 master 失效，就中止 MapReduce 运算。客户可以检查到这个状态，并且可以根据需要重新执行 MapReduce 操作。 #### 在失效方面的处理机制 (注:原文为”semantics in the presence of failures”) 当用户提供的 Map 和 Reduce 操作是输入确定性函数(即相同的输入产生相同的输出)时，我们的分布 式实现在任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。 我们依赖对 Map 和 Reduce 任务的输出是原子提交的来完成这个特性。每个工作中的任务把它的输出写 到私有的临时文件中。每个 Reduce 任务生成一个这样的文件，而每个 Map 任务则生成 R 个这样的文件(一 个 Reduce 任务对应一个文件)。当一个 Map 任务完成的时，worker 发送一个包含 R 个临时文件名的完成消息 给 master。如果 master 从一个已经完成的 Map 任务再次接收到到一个完成消息，master 将忽略这个消息;否 则，master 将这 R 个文件的名字记录在数据结构里。 当 Reduce 任务完成时，Reduce worker 进程以原子的方式把临时文件重命名为最终的输出文件。如果同 一个 Reduce 任务在多台机器上执行，针对同一个最终的输出文件将有多个重命名操作执行。我们依赖底层文 件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个 Reduce 任务产生的数据。 使用 MapReduce 模型的程序员可以很容易的理解他们程序的行为，因为我们绝大多数的 Map 和 Reduce 操作是确定性的，而且存在这样的一个事实:我们的失效处理机制等价于一个顺序的执行的操作。当 Map 或 /和 Reduce 操作是不确定性的时候，我们提供虽然较弱但是依然合理的处理机制。当使用非确定操作的时候， 一个 Reduce 任务 R1 的输出等价于一个非确定性程序顺序执行产生时的输出。但是，另一个 Reduce 任务 R2 的输出也许符合一个不同的非确定顺序程序执行产生的 R2 的输出。 考虑 Map 任务 M 和 Reduce 任务 R1、R2 的情况。我们设定 e(Ri)是 Ri 已经提交的执行过程(有且仅有一个这样的执行过程)。当 e(R1)读取了由 M 一次执行产生的输出，而 e(R2)读取了由 M 的另一次执行产生的 输出，导致了较弱的失效处理。 ### 存储位置 在我们的计算运行环境中，网络带宽是一个相当匮乏的资源。我们通过尽量把输入数据(由 GFS 管理)存 储在集群中机器的本地磁盘上来节省网络带宽。GFS 把每个文件按 64MB 一个 Block 分隔，每个 Block 保存 在多台机器上，环境中就存放了多份拷贝(一般是 3 个拷贝)。MapReduce 的 master 在调度 Map 任务时会考虑 输入文件的位置信息，尽量将一个 Map 任务调度在包含相关输入数据拷贝的机器上执行;如果上述努力失败 了，master 将尝试在保存有输入数据拷贝的机器附近的机器上执行 Map 任务(例如，分配到一个和包含输入数 据的机器在一个 switch 里的 worker 机器上执行)。当在一个足够大的 cluster 集群上运行大型 MapReduce 操作 的时候，大部分的输入数据都能从本地机器读取，因此消耗非常少的网络带宽。 ### 任务粒度 如前所述，我们把 Map 拆分成了 M 个片段、把 Reduce 拆分成 R 个片段执行。理想情况下，M 和 R 应当 比集群中 worker 的机器数量要多得多。在每台 worker 机器都执行大量的不同任务能够提高集群的动态的负载 均衡能力，并且能够加快故障恢复的速度:失效机器上执行的大量 Map 任务都可以分布到所有其他的 worker 机器上去执行。 但是实际上，在我们的具体实现中对 M 和 R 的取值都有一定的客观限制，因为 master 必须执行 O(M+R) 次调度，并且在内存中保存 O(M*R)个状态(对影响内存使用的因素还是比较小的:O(M*R)块状态，大概每 对 Map 任务/Reduce 任务 1 个字节就可以了)。 更进一步，R 值通常是由用户指定的，因为每个 Reduce 任务最终都会生成一个独立的输出文件。实际使 用时我们也倾向于选择合适的 M 值，以使得每一个独立任务都是处理大约 16M 到 64M 的输入数据(这样， 上面描写的输入数据本地存储优化策略才最有效)，另外，我们把 R 值设置为我们想使用的 worker 机器数量 的小的倍数。我们通常会用这样的比例来执行 MapReduce:M=200000，R=5000，使用 2000 台 worker 机器。 ### 备用任务 影响一个 MapReduce 的总执行时间最通常的因素是“落伍者”:在运算过程中，如果有一台机器花了很 长的时间才完成最后几个 Map 或 Reduce 任务，导致 MapReduce 操作总的执行时间超过预期。出现“落伍者” 的原因非常多。比如:如果一个机器的硬盘出了问题，在读取的时候要经常的进行读取纠错操作，导致读取数据的速度从 30M/s 降低到 1M/s。如果 cluster 的调度系统在这台机器上又调度了其他的任务，由于 CPU、内 存、本地硬盘和网络带宽等竞争因素的存在，导致执行 MapReduce 代码的执行效率更加缓慢。我们最近遇到 的一个问题是由于机器的初始化代码有 bug，导致关闭了的处理器的缓存:在这些机器上执行任务的性能和 正常情况相差上百倍。 我们有一个通用的机制来减少“落伍者”出现的情况。当一个 MapReduce 操作接近完成的时候，master 调度备用(backup)任务进程来执行剩下的、处于处理中状态(in-progress)的任务。无论是最初的执行进程、 还是备用(backup)任务进程完成了任务，我们都把这个任务标记成为已经完成。我们调优了这个机制，通 常只会占用比正常操作多几个百分点的计算资源。我们发现采用这样的机制对于减少超大 MapReduce 操作的 总处理时间效果显著。例如，在 5.3 节描述的排序任务，在关闭掉备用任务的情况下要多花 44%的时间完成 排序任务。 &#123;% note info %&#125;## 技巧 &#123;% endnote %&#125; 虽然简单的 Map 和 Reduce 函数提供的基本功能已经能够满足大部分的计算需要，我们还是发掘出了一 些有价值的扩展功能。本节将描述这些扩展功能。 ### 分区函数 MapReduce 的使用者通常会指定 Reduce 任务和 Reduce 任务输出文件的数量(R)。我们在中间 key 上使 用分区函数来对数据进行分区，之后再输入到后续任务执行进程。一个缺省的分区函数是使用 hash 方法(比如， hash(key) mod R)进行分区。hash 方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对 key 值进行的分区将非常有用。比如，输出的 key 值是 URLs，我们希望每个主机的所有条目保持在同一个输出文 件中。为了支持类似的情况，MapReduce 库的用户需要提供专门的分区函数。例如，使用“hash(Hostname(urlkey)) mod R”作为分区函数就可以把所有来自同一个主机的 URLs 保存在同一个输出文件中。 ### 顺序保证 我们确保在给定的分区中，中间 key/value pair 数据的处理顺序是按照 key 值增量顺序处理的。这样的顺 序保证对每个分成生成一个有序的输出文件，这对于需要对输出文件按 key 值随机存取的应用非常有意义， 对在排序输出的数据集也很有帮助。 ### Combiner 函数 在某些情况下，Map 函数产生的中间 key 值的重复数据会占很大的比重，并且，用户自定义的 Reduce 函 数满足结合律和交换律。在 2.1 节的词数统计程序是个很好的例子。由于词频率倾向于一个 zipf 分布(齐夫分布)，每个 Map 任务将产生成千上万个这样的记录&lt;the,1&gt;。所有的这些记录将通过网络被发送到一个单独的 Reduce 任务，然后由这个 Reduce 任务把所有这些记录累加起来产生一个数字。我们允许用户指定一个可选 的 combiner 函数，combiner 函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。 Combiner 函数在每台执行 Map 任务的机器上都会被执行一次。一般情况下，Combiner 和 Reduce 函数是一样的。Combiner 函数和 Reduce 函数之间唯一的区别是 MapReduce 库怎样控制函数的输出。Reduce 函数的 输出被保存在最终的输出文件里，而 Combiner 函数的输出被写到中间文件里，然后被发送给 Reduce 任务。 部分的合并中间结果可以显著的提高一些 MapReduce 操作的速度。附录 A 包含一个使用 combiner 函数 的例子。 ### 输入和输出的类型 MapReduce 库支持几种不同的格式的输入数据。比如，文本模式的输入数据的每一行被视为是一个 key/value pair。key 是文件的偏移量，value 是那一行的内容。另外一种常见的格式是以 key 进行排序来存储 的 key/value pair 的序列。每种输入类型的实现都必须能够把输入数据分割成数据片段，该数据片段能够由单 独的 Map 任务来进行后续处理(例如，文本模式的范围分割必须确保仅仅在每行的边界进行范围分割)。虽然 大多数 MapReduce 的使用者仅仅使用很少的预定义输入类型就满足要求了，但是使用者依然可以通过提供一 个简单的 Reader 接口实现就能够支持一个新的输入类型。 Reader 并非一定要从文件中读取数据，比如，我们可以很容易的实现一个从数据库里读记录的 Reader， 或者从内存中的数据结构读取数据的 Reader。 类似的，我们提供了一些预定义的输出数据的类型，通过这些预定义类型能够产生不同格式的数据。用 户采用类似添加新的输入数据类型的方式增加新的输出类型。 ### 副作用 在某些情况下，MapReduce 的使用者发现，如果在 Map 和/或 Reduce 操作过程中增加辅助的输出文件会 比较省事。我们依靠程序 writer 把这种“副作用”变成原子的和幂等的3。通常应用程序首先把输出结果写到 一个临时文件中，在输出全部数据之后，在使用系统级的原子操作 rename 重新命名这个临时文件。 如果一个任务产生了多个输出文件，我们没有提供类似两阶段提交的原子操作支持这种情况。因此，对 于会产生多个输出文件、并且对于跨文件有一致性要求的任务，都必须是确定性的任务。但是在实际应用过 程中，这个限制还没有给我们带来过麻烦。### 跳过损坏的记录 有时候，用户程序中的 bug 导致 Map 或者 Reduce 函数在处理某些记录的时候 crash 掉，MapReduce 操作 无法顺利完成。惯常的做法是修复 bug 后再次执行 MapReduce 操作，但是，有时候找出这些 bug 并修复它们 不是一件容易的事情;这些 bug 也许是在第三方库里边，而我们手头没有这些库的源代码。而且在很多时候， 忽略一些有问题的记录也是可以接受的，比如在一个巨大的数据集上进行统计分析的时候。我们提供了一种 执行模式，在这种模式下，为了保证保证整个处理能继续进行，MapReduce 会检测哪些记录导致确定性的 crash， 并且跳过这些记录不处理。 每个 worker 进程都设置了信号处理函数捕获内存段异常(segmentation violation)和总线错误(bus error)。 在执行 Map 或者 Reduce 操作之前，MapReduce 库通过全局变量保存记录序号。如果用户程序触发了一个系 统信号，消息处理函数将用“最后一口气”通过 UDP 包向 master 发送处理的最后一条记录的序号。当 master 看到在处理某条特定记录不止失败一次时，master 就标志着条记录需要被跳过，并且在下次重新执行相关的 Map 或者 Reduce 任务的时候跳过这条记录。 ### 本地执行 调试 Map 和 Reduce 函数的 bug 是非常困难的，因为实际执行操作时不但是分布在系统中执行的，而且 通常是在好几千台计算机上执行，具体的执行位置是由 master 进行动态调度的，这又大大增加了调试的难度。 为了简化调试、profile 和小规模测试，我们开发了一套 MapReduce 库的本地实现版本，通过使用本地版本的 MapReduce 库，MapReduce 操作在本地计算机上顺序的执行。用户可以控制 MapReduce 操作的执行，可以把 操作限制到特定的 Map 任务上。用户通过设定特别的标志来在本地执行他们的程序，之后就可以很容易的使 用本地调试和测试工具(比如 gdb)。 ### 状态信息 master 使用嵌入式的 HTTP 服务器(如 Jetty)显示一组状态信息页面，用户可以监控各种执行状态。状 态信息页面显示了包括计算执行的进度，比如已经完成了多少任务、有多少任务正在处理、输入的字节数、 中间数据的字节数、输出的字节数、处理百分比等等。页面还包含了指向每个任务的 stderr 和 stdout 文件的链 接。用户根据这些数据预测计算需要执行大约多长时间、是否需要增加额外的计算资源。这些页面也可以用 来分析什么时候计算执行的比预期的要慢。 另外，处于最顶层的状态页面显示了哪些 worker 失效了，以及他们失效的时候正在运行的 Map 和 Reduce 任务。这些信息对于调试用户代码中的 bug 很有帮助。### 计数器 MapReduce 库使用计数器统计不同事件发生次数。比如，用户可能想统计已经处理了多少个单词、已经 索引的多少篇 German 文档等等。 为了使用这个特性，用户在程序中创建一个命名的计数器对象，在 Map 和 Reduce 函数中相应的增加计 数器的值。例如: Counter* uppercase;uppercase = GetCounter(“uppercase”);map(String name, String contents): for each word w in contents: if (IsCapitalized(w)): uppercase-&gt;Increment(); EmitIntermediate(w, “1′′);1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 这些计数器的值周期性的从各个单独的 worker 机器上传递给 maste(r 附加在 ping 的应答包中传递)。master 把执行成功的 Map 和 Reduce 任务的计数器值进行累计，当 MapReduce 操作完成之后，返回给用户代码。 计数器当前的值也会显示在 master 的状态页面上，这样用户就可以看到当前计算的进度。当累加计数器 的值的时候，master 要检查重复运行的 Map 或者 Reduce 任务，避免重复累加(之前提到的备用任务和失效 后重新执行任务这两种情况会导致相同的任务被多次执行)。 有些计数器的值是由 MapReduce 库自动维持的，比如已经处理的输入的 key/value pair 的数量、输出的 key/value pair 的数量等等。 计数器机制对于 MapReduce 操作的完整性检查非常有用。比如，在某些 MapReduce 操作中，用户需要确 保输出的 key value pair 精确的等于输入的 key value pair，或者处理的 German 文档数量在处理的整个文档数 量中属于合理范围。 &#123;% note info %&#125;## 性能&#123;% endnote %&#125; 本节我们用在一个大型集群上运行的两个计算来衡量 MapReduce 的性能。一个计算在大约 1TB 的数据中 进行特定的模式匹配，另一个计算对大约 1TB 的数据进行排序。 这两个程序在大量的使用 MapReduce 的实际应用中是非常典型的 — 一类是对数据格式进行转换，从一 种表现形式转换为另外一种表现形式;另一类是从海量数据中抽取少部分的用户感兴趣的数据。 ### 集群配置 所有这些程序都运行在一个大约由 1800 台机器构成的集群上。每台机器配置 2 个 2G 主频、支持超线程 的 Intel Xeon 处理器，4GB 的物理内存，两个 160GB 的 IDE 硬盘和一个千兆以太网卡。这些机器部署在一个 两层的树形交换网络中，在 root 节点大概有 100-200GBPS 的传输带宽。所有这些机器都采用相同的部署(对 等部署)，因此任意两点之间的网络来回时间小于 1 毫秒。 在 4GB 内存里，大概有 1-1.5G 用于运行在集群上的其他任务。测试程序在周末下午开始执行，这时主机 的 CPU、磁盘和网络基本上处于空闲状态。 ### GREP 这个分布式的 grep 程序需要扫描大概 10 的 10 次方个由 100 个字节组成的记录，查找出现概率较小的 3 个字符的模式(这个模式在 92337 个记录中出现)。输入数据被拆分成大约 64M 的 Block(M=15000)，整个 输出数据存放在一个文件中(R=1)。![](http://oliji9s3j.bkt.clouddn.com/15133914679471.jpg) 图 2 显示了这个运算随时间的处理过程。其中 Y 轴表示输入数据的处理速度。处理速度随着参与 MapReduce 计算的机器数量的增加而增加，当 1764 台 worker 参与计算的时，处理速度达到了 30GB/s。当 Map 任务结束的时候，即在计算开始后 80 秒，输入的处理速度降到 0。整个计算过程从开始到结束一共花了 大概 150 秒。这包括了大约一分钟的初始启动阶段。初始启动阶段消耗的时间包括了是把这个程序传送到各 个 worker 机器上的时间、等待 GFS 文件系统打开 1000 个输入文件集合的时间、获取相关的文件本地位置优 化信息的时间。 ### 排序 排序程序处理 10 的 10 次方个 100 个字节组成的记录(大概 1TB 的数据)。这个程序模仿 TeraSort benchmark[10]。 排序程序由不到 50 行代码组成。只有三行的 Map 函数从文本行中解析出 10 个字节的 key 值作为排序的 key，并且把这个 key 和原始文本行作为中间的 key/value pair 值输出。我们使用了一个内置的恒等函数作为 Reduce 操作函数。这个函数把中间的 key/value pair 值不作任何改变输出。最终排序结果输出到两路复制的GFS 文件系统(也就是说，程序输出 2TB 的数据)。 如前所述，输入数据被分成 64MB 的 Block(M=15000)。我们把排序后的输出结果分区后存储到 4000 个文件(R=4000)。分区函数使用 key 的原始字节来把数据分区到 R 个片段中。 在这个 benchmark 测试中，我们使用的分区函数知道 key 的分区情况。通常对于排序程序来说，我们会 增加一个预处理的 MapReduce 操作用于采样 key 值的分布情况，通过采样的数据来计算对最终排序处理的分 区点。![](http://oliji9s3j.bkt.clouddn.com/15133915176963.jpg) 图三(a)显示了这个排序程序的正常执行过程。左上的图显示了输入数据读取的速度。数据读取速度峰 值会达到 13GB/s，并且所有 Map 任务完成之后，即大约 200 秒之后迅速滑落到 0。值得注意的是，排序程序 输入数据读取速度小于分布式 grep 程序。这是因为排序程序的 Map 任务花了大约一半的处理时间和 I/O 带宽 把中间输出结果写到本地硬盘。相应的分布式 grep 程序的中间结果输出几乎可以忽略不计。 左边中间的图显示了中间数据从 Map 任务发送到 Reduce 任务的网络速度。这个过程从第一个 Map 任务 完成之后就开始缓慢启动了。图示的第一个高峰是启动了第一批大概 1700 个 Reduce 任务(整个 MapReduce 分布到大概 1700 台机器上，每台机器 1 次最多执行 1 个 Reduce 任务)。排序程序运行大约 300 秒后，第一批 启动的 Reduce 任务有些完成了，我们开始执行剩下的 Reduce 任务。所有的处理在大约 600 秒后结束。左下图表示 Reduce 任务把排序后的数据写到最终的输出文件的速度。在第一个排序阶段结束和数据开始 写入磁盘之间有一个小的延时，这是因为 worker 机器正在忙于排序中间数据。磁盘写入速度在 2-4GB/s 持续 一段时间。输出数据写入磁盘大约持续 850 秒。计入初始启动部分的时间，整个运算消耗了 891 秒。这个速 度和 TeraSort benchmark[18]的最高纪录 1057 秒相差不多。 还有一些值得注意的现象:输入数据的读取速度比排序速度和输出数据写入磁盘速度要高不少，这是因 为我们的输入数据本地化优化策略起了作用 — 绝大部分数据都是从本地硬盘读取的，从而节省了网络带宽。 排序速度比输出数据写入到磁盘的速度快，这是因为输出数据写了两份(我们使用了 2 路的 GFS 文件系统， 写入复制节点的原因是为了保证数据可靠性和可用性)。我们把输出数据写入到两个复制节点的原因是因为这 是底层文件系统的保证数据可靠性和可用性的实现机制。如果底层文件系统使用类似容错编码[14](erasure coding)的方式而不是复制的方式保证数据的可靠性和可用性，那么在输出数据写入磁盘的时候，就可以降低 网络带宽的使用。 ### 高效的 backup 任务 图三(b)显示了关闭了备用任务后排序程序执行情况。执行的过程和图 3(a)很相似，除了输出数据写 磁盘的动作在时间上拖了一个很长的尾巴，而且在这段时间里，几乎没有什么写入动作。在 960 秒后，只有 5 个 Reduce 任务没有完成。这些拖后腿的任务又执行了 300 秒才完成。整个计算消耗了 1283 秒，多了 44% 的执行时间。 ### 失效的机器 在图三(c)中演示的排序程序执行的过程中，我们在程序开始后几分钟有意的 kill 了 1746 个 worker 中 的 200 个。集群底层的调度立刻在这些机器上重新开始新的 worker 处理进程(因为只是 worker 机器上的处理 进程被 kill 了，机器本身还在工作)。 图三(c)显示出了一个“负”的输入数据读取速度，这是因为一些已经完成的 Map 任务丢失了(由于 相应的执行 Map 任务的 worker 进程被 kill 了)，需要重新执行这些任务。相关 Map 任务很快就被重新执行了。 整个运算在 933 秒内完成，包括了初始启动时间(只比正常执行多消耗了 5%的时间)。 &#123;% note info %&#125;## 经验 &#123;% endnote %&#125; 我们在 2003 年 1 月完成了第一个版本的 MapReduce 库，在 2003 年 8 月的版本有了显著的增强，这包括 了输入数据本地优化、worker 机器之间的动态负载均衡等等。从那以后，我们惊喜的发现，MapReduce 库能 广泛应用于我们日常工作中遇到的各类问题。它现在在 Google 内部各个领域得到广泛应用，包括: 1. 大规模机器学习问题2. Google News 和 Froogle 产品的集群问题 3. 从公众查询产品(比如 Google 的 Zeitgeist)的报告中抽取数据。 4. 从大量的新应用和新产品的网页中提取有用信息(比如，从大量的位置搜索网页中抽取地理位置信息)。 5. 大规模的图形计算。![](http://oliji9s3j.bkt.clouddn.com/15133916089336.jpg) 图四显示了在我们的源代码管理系统中，随着时间推移，独立的 MapReduce 程序数量的显著增加。从 2003 年早些时候的 0 个增长到 2004 年 9 月份的差不多 900 个不同的程序。MapReduce 的成功取决于采用 MapReduce 库能够在不到半个小时时间内写出一个简单的程序，这个简单的程序能够在上千台机器的组成的集群上做大 规模并发处理，这极大的加快了开发和原形设计的周期。另外，采用 MapReduce 库，可以让完全没有分布式 和/或并行系统开发经验的程序员很容易的利用大量的资源，开发出分布式和/或并行处理的应用。![](http://oliji9s3j.bkt.clouddn.com/15133916531743.jpg) 在每个任务结束的时候，MapReduce 库统计计算资源的使用状况。在表 1，我们列出了 2004 年 8 月份 MapReduce 运行的任务所占用的相关资源。 ### 大规模索引 到目前为止，MapReduce 最成功的应用就是重写了 Google 网络搜索服务所使用到的 index 系统。索引系 统的输入数据是网络爬虫抓取回来的海量的文档，这些文档数据都保存在 GFS 文件系统里。这些文档原始内 容4的大小超过了 20TB。索引程序是通过一系列的 MapReduce 操作(大约 5 到 10 次)来建立索引。使用 MapReduce(替换上一个特别设计的、分布式处理的索引程序)带来这些好处: 实现索引部分的代码简单、小巧、容易理解，因为对于容错、分布式以及并行计算的处理都是 MapReduce 库提供的。比如，使用 MapReduce 库，计算的代码行数从原来的 3800 行 C++代码减少到大概 700 行代码。 MapReduce 库的性能已经足够好了，因此我们可以把在概念上不相关的计算步骤分开处理，而不是混在 一起以期减少数据传递的额外消耗。概念上不相关的计算步骤的隔离也使得我们可以很容易改变索引处理方 式。比如，对之前的索引系统的一个小更改可能要耗费好几个月的时间，但是在使用 MapReduce 的新系统上， 这样的更改只需要花几天时间就可以了。 索引系统的操作管理更容易了。因为由机器失效、机器处理速度缓慢、以及网络的瞬间阻塞等引起的绝 大部分问题都已经由 MapReduce 库解决了，不再需要操作人员的介入了。另外，我们可以通过在索引系统集 群中增加机器的简单方法提高整体处理性能。 &#123;% note info %&#125;## 相关工作 &#123;% endnote %&#125;很多系统都提供了严格的编程模式，并且通过对编程的严格限制来实现并行计算。例如，一个结合函数可以通过把 N 个元素的数组的前缀在 N 个处理器上使用并行前缀算法，在 log N 的时间内计算完[6，9，13]5。 MapReduce 可以看作是我们结合在真实环境下处理海量数据的经验，对这些经典模型进行简化和萃取的成果。 更加值得骄傲的是，我们还实现了基于上千台处理器的集群的容错处理。相比而言，大部分并发处理系统都 只在小规模的集群上实现，并且把容错处理交给了程序员。 Bulk Synchronous Programming[17]和一些 MPI 原语[11]提供了更高级别的并行处理抽象，可以更容易写 出并行处理的程序。MapReduce 和这些系统的关键不同之处在于，MapReduce 利用限制性编程模式实现了用 户程序的自动并发处理，并且提供了透明的容错处理。 我们数据本地优化策略的灵感来源于 active disks[12,15]等技术，在 active disks 中，计算任务是尽量推送 到数据存储的节点处理6，这样就减少了网络和 IO 子系统的吞吐量。我们在挂载几个硬盘的普通机器上执行 我们的运算，而不是在磁盘处理器上执行我们的工作，但是达到的目的一样的。 我们的备用任务机制和 Charlotte System[3]提出的 eager 调度机制比较类似。Eager 调度机制的一个缺点是 如果一个任务反复失效，那么整个计算就不能完成。我们通过忽略引起故障的记录的方式在某种程度上解决 了这个问题。 MapReduce 的实现依赖于一个内部的集群管理系统，这个集群管理系统负责在一个超大的、共享机器的 集群上分布和运行用户任务。虽然这个不是本论文的重点，但是有必要提一下，这个集群管理系统在理念上 和其它系统，如 Condor[16]是一样。 MapReduce 库的排序机制和 NOW-Sort[1]的操作上很类似。读取输入源的机器(map workers)把待排序 的数据进行分区后，发送到 R 个 Reduce worker 中的一个进行处理。每个 Reduce worker 在本地对数据进行排 序(尽可能在内存中排序)。当然，NOW-Sort 没有给用户自定义的 Map 和 Reduce 函数的机会，因此不具备 MapReduce 库广泛的实用性。 River[2]提供了一个编程模型:处理进程通过分布式队列传送数据的方式进行互相通讯。和 MapReduce 类似，River 系统尝试在不对等的硬件环境下，或者在系统颠簸的情况下也能提供近似平均的性能。River 是 通过精心调度硬盘和网络的通讯来平衡任务的完成时间。MapReduce 库采用了其它的方法。通过对编程模型 进行限制，MapReduce 框架把问题分解成为大量的“小”任务。这些任务在可用的 worker 集群上动态的调度， 这样快速的 worker 就可以执行更多的任务。通过对编程模型进行限制，我们可用在工作接近完成的时候调度 备用任务，缩短在硬件配置不均衡的情况下缩小整个操作完成的时间(比如有的机器性能差、或者机器被某 些操作阻塞了)。 BAD-FS[5]采用了和 MapReduce 完全不同的编程模式，它是面向广域网(alex 注:wide-area network)的。不过，这两个系统有两个基础功能很类似。1. 两个系统采用重新执行的方式来防止由于失效导致的数据丢 失。2. 两个都使用数据本地化调度策略，减少网络通讯的数据量。 TACC[7]是一个用于简化构造高可用性网络服务的系统。和 MapReduce 一样，它也依靠重新执行机制来 实现的容错处理。 &#123;% note info %&#125;## 结束语 &#123;% endnote %&#125; MapReduce 编程模型在 Google 内部成功应用于多个领域。我们把这种成功归结为几个方面:首先，由于 MapReduce 封装了并行处理、容错处理、数据本地化优化、负载均衡等等技术难点的细节，这使得 MapReduce 库易于使用。即便对于完全没有并行或者分布式系统开发经验的程序员而言;其次，大量不同类型的问题都 可以通过 MapReduce 简单的解决。比如，MapReduce 用于生成 Google 的网络搜索服务所需要的数据、用来 排序、用来数据挖掘、用于机器学习，以及很多其它的系统;第三，我们实现了一个在数千台计算机组成的 大型集群上灵活部署运行的 MapReduce。这个实现使得有效利用这些丰富的计算资源变得非常简单，因此也 适合用来解决 Google 遇到的其他很多需要大量计算的问题。 我们也从 MapReduce 开发过程中学到了不少东西。首先，约束编程模式使得并行和分布式计算非常容易， 也易于构造容错的计算环境;其次，网络带宽是稀有资源。大量的系统优化是针对减少网络传输量为目的的: 本地优化策略使大量的数据从本地磁盘读取，中间文件写入本地磁盘、并且只写一份中间文件也节约了网络 带宽;第三，多次执行相同的任务可以减少性能缓慢的机器带来的负面影响(alex 注:即硬件配置的不平衡)， 同时解决了由于机器失效导致的数据丢失问题。 &#123;% note info %&#125;## 感谢 &#123;% endnote %&#125; Josh Levenberg has been instrumental in revising and extending the user-level MapReduce API with a number of new features based on his experience with using MapReduce and other people’s suggestions for enhancements. MapReduce reads its input from and writes its output to the Google File System [8]. We would like to thank Mohit Aron, Howard Gobioff, Markus Gutschke, David Kramer, Shun-Tak Leung, and Josh Redstone for their work in developing GFS. We would also like to thank Percy Liang and Olcan Sercinoglu for their work in developing the cluster management system used by MapReduce. Mike Burrows, Wilson Hsieh, Josh Levenberg, Sharon Perl, Rob Pike, and Debby Wallach provided helpful comments on earlier drafts of this paper.The anonymous OSDI reviewers, and our shepherd, Eric Brewer, provided many useful suggestions of areas where the paper could be improved. Finally, we thank all the users of MapReduce within Google’s engineering organization for providing helpful feedback, suggestions, and bug reports. &#123;% note info %&#125;## 参考资料 &#123;% endnote %&#125; [1] Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau,David E. Culler, Joseph M. Hellerstein, and David A. Patterson.High-performance sorting on networks of workstations.In Proceedings of the 1997 ACM SIGMOD InternationalConference on Management of Data, Tucson,Arizona, May 1997. [2] Remzi H. Arpaci-Dusseau, Eric Anderson, NoahTreuhaft, David E. Culler, Joseph M. Hellerstein, David Patterson, and Kathy Yelick. Cluster I/O with River:Making the fast case common. In Proceedings of the Sixth Workshop on Input/Output in Parallel and Distributed Systems (IOPADS ’99), pages 10.22, Atlanta, Georgia, May 1999. [3] Arash Baratloo, Mehmet Karaul, Zvi Kedem, and Peter Wyckoff. Charlotte: Metacomputing on the web. In Proceedings of the 9th International Conference on Parallel and Distributed Computing Systems, 1996. [4] Luiz A. Barroso, Jeffrey Dean, and Urs H ̈olzle. Web search for a planet: The Google cluster architecture. IEEE Micro, 23(2):22.28, April 2003. [5] John Bent, Douglas Thain, Andrea C.Arpaci-Dusseau, Remzi H. Arpaci-Dusseau, and Miron Livny. Explicit control in a batch-aware distributed file system. In Proceedings of the 1st USENIX Symposium on Networked Systems Design and Implementation NSDI, March 2004. [6] Guy E. Blelloch. Scans as primitive parallel operations.IEEE Transactions on Computers, C-38(11), November 1989. [7] Armando Fox, Steven D. Gribble, Yatin Chawathe, Eric A. Brewer, and Paul Gauthier. Cluster-based scalable network services. In Proceedings of the 16th ACM Symposium on Operating System Principles, pages 78. 91, Saint-Malo, France, 1997. [8] Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung. The Google file system. In 19th Symposium on Operating Systems Principles, pages 29.43, Lake George, New York, 2003. To appear in OSDI 2004 12 [9] S. Gorlatch. Systematic efficient parallelization of scan and other list homomorphisms. In L. Bouge, P. Fraigniaud, A. Mignotte, and Y. Robert, editors, Euro-Par’96. Parallel Processing, Lecture Notes in Computer Science 1124, pages 401.408. Springer-Verlag, 1996. [10] Jim Gray. Sort benchmark home page. http://research.microsoft.com/barc/SortBenchmark/. [11] William Gropp, Ewing Lusk, and Anthony Skjellum. Using MPI: Portable Parallel Programming with the Message-Passing Interface. MIT Press, Cambridge, MA, 1999. [12] L. Huston, R. Sukthankar, R.Wickremesinghe, M. Satyanarayanan, G. R. Ganger, E. Riedel, and A. Ailamaki. Diamond: A storage architecture for early discard in interactive search. In Proceedings of the 2004USENIX File and Storage Technologies FAST Conference, April 2004. [13] Richard E. Ladner and Michael J. Fischer. Parallel prefix computation. Journal of the ACM, 27(4):831.838, 1980. [14] Michael O. Rabin. Efficient dispersal of information for security, load balancing and fault tolerance. Journal of the ACM, 36(2):335.348, 1989. [15] Erik Riedel, Christos Faloutsos, Garth A. Gibson, and David Nagle. Active disks for large-scale data processing. IEEE Computer, pages 68.74, June 2001. [16] Douglas Thain, Todd Tannenbaum, and Miron Livny. Distributed computing in practice: The Condor experience. Concurrency and Computation: Practice and Experience, 2004. [17] L. G. Valiant. A bridging model for parallel computation. Communications of the ACM, 33(8):103.111, 1997. [18] Jim Wyllie. Spsort: How to sort a terabyte quickly. http://alme1.almaden.ibm.com/cs/spsort.pdf.&#123;% note info %&#125;## 附录 A-单词频率统计 &#123;% endnote %&#125;本节包含了一个完整的程序，用于统计在一组命令行指定的输入文件中，每一个不同的单词出现频率。```python#include “mapreduce/mapreduce.h” // User’s map functionclass WordCounter :public Mapper&#123;public: virtual void Map(const MapInput&amp;input)&#123; const string&amp;text=input.value(); const int n=text.size(); for(int i=0;i&lt;n; )&#123;// Skip past leading whitespace while((i&lt;n)&amp;&amp;isspace(text[i]))i++;// Find word end int start=i; while((i&lt;n)&amp;&amp;!isspace(text[i]))i++; if(start&lt;i)Emit(text.substr(start,i-start),”1′′); &#125;&#125; &#125;; REGISTER_MAPPER(WordCounter);// User’s reduce functionclass Adder :public Reducer&#123; virtual void Reduce(ReduceInput*input)&#123; // Iterate over all entries with the// same key and add the values int64 value=0; while(!input-&gt;done())&#123; value+=StringToInt(input-&gt;value());input-&gt;NextValue(); &#125;// Emit sum for input-&gt;key() Emit(IntToString(value));&#125; &#125;; REGISTER_REDUCER(Adder); int main(int argc,char**argv)&#123;ParseCommandLineFlags(argc,argv); MapReduceSpecification spec;// Store list of input files into “spec” for(int i=1;i&lt;argc; i++)&#123; MapReduceInput*input=spec.add_input(); input-&gt;set_format(“text”); input-&gt;set_filepattern(argv[i]); input-&gt;set_mapper_class(“WordCounter”); &#125;// Specify the output files:// /gfs/test/freq-00000-of-00100// /gfs/test/freq-00001-of-00100// ... MapReduceOutput*out=spec.output(); out-&gt;set_filebase(“/gfs/test/freq”); out-&gt;set_num_tasks(100); out-&gt;set_format(“text”); out-&gt;set_reducer_class(“Adder”);// Optional: do partial sums within map tasks to save network bandwidth out-&gt;set_combiner_class(“Adder”);// Tuning parameters: use at most 2000// machines and 100 MB of memory per task spec.set_machines(2000); spec.set_map_megabytes(100); spec.set_reduce_megabytes(100);// Now run it MapReduceResult result; if(!MapReduce(spec,&amp;result))abort();// Done: ‘result’ structure contains info about counters, time taken, number of machines used, etc. return 0; &#125;","raw":null,"content":null,"categories":[{"name":"paper","slug":"paper","permalink":"https://freehubs.github.io/categories/paper/"}],"tags":[{"name":"paper","slug":"paper","permalink":"https://freehubs.github.io/tags/paper/"}]},{"title":"Google File System 中文版","slug":"Google-File-System-中文版","date":"2017-12-14T12:38:00.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/12/14/Google-File-System-中文版/","link":"","permalink":"https://freehubs.github.io/2017/12/14/Google-File-System-中文版/","excerpt":"\n            摘要\n          \n我们设计并实现了 Google GFS 文件系统，一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。GFS 虽然运行在廉价的普遍硬件设备上，但是它依然了提供灾难冗余的能力，为大量客户机提供了高性能的服务。\n虽然 GFS 的设计目标与许多传统的分布式文件系统有很多相同之处，但是，我们的设计还是以我们对自己的应用的负载情况和技术环境的分析为基础的，不管现在还是将来，GFS 和早期的分布式文件系统的设想都有明显的不同。所以我们重新审视了传统文件系统在设计上的折衷选择，衍生出了完全不同的设计思路。\nGFS 完全满足了我们对存储的需求。GFS 作为存储平台已经被广泛的部署在 Google 内部，存储我们的服务产生和处理的数据，同时还用于那些需要大规模数据集的研究和开发工作。目前为止，最大的一个集群利用数千台机器的数千个硬盘，提供了数百 TB 的存储空间，同时为数百个客户机服务。在本论文中，我们展示了能够支持分布式应用的文件系统接口的扩展，讨论我们设计的许多方面，最后列出了小规模性能测试以及真实生产系统中性能相关数据。","text":"摘要 我们设计并实现了 Google GFS 文件系统，一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。GFS 虽然运行在廉价的普遍硬件设备上，但是它依然了提供灾难冗余的能力，为大量客户机提供了高性能的服务。 虽然 GFS 的设计目标与许多传统的分布式文件系统有很多相同之处，但是，我们的设计还是以我们对自己的应用的负载情况和技术环境的分析为基础的，不管现在还是将来，GFS 和早期的分布式文件系统的设想都有明显的不同。所以我们重新审视了传统文件系统在设计上的折衷选择，衍生出了完全不同的设计思路。 GFS 完全满足了我们对存储的需求。GFS 作为存储平台已经被广泛的部署在 Google 内部，存储我们的服务产生和处理的数据，同时还用于那些需要大规模数据集的研究和开发工作。目前为止，最大的一个集群利用数千台机器的数千个硬盘，提供了数百 TB 的存储空间，同时为数百个客户机服务。在本论文中，我们展示了能够支持分布式应用的文件系统接口的扩展，讨论我们设计的许多方面，最后列出了小规模性能测试以及真实生产系统中性能相关数据。 简介 为了满足 Google 迅速增长的数据处理需求，我们设计并实现了 Google 文件系统(Google File System –GFS)。GFS 与传统的分布式文件系统有着很多相同的设计目标，比如，性能、可伸缩性、可靠性以及可用性。但是，我们的设计还基于我们对我们自己的应用的负载情况和技术环境的观察的影响，不管现在还是将来，GFS 和早期文件系统的假设都有明显的不同。所以我们重新审视了传统文件系统在设计上的折衷选择，衍生出了完全不同的设计思路。 首先，组件失效被认为是常态事件，而不是意外事件。GFS 包括几百甚至几千台普通的廉价设备组装的存储机器，同时被相当数量的客户机访问。GFS 组件的数量和质量导致在事实上，任何给定时间内都有可能发生某些组件无法工作，某些组件无法从它们目前的失效状态中恢复。我们遇到过各种各样的问题，比如应用程序 bug、操作系统的 bug、人为失误，甚至还有硬盘、内存、连接器、网络以及电源失效等造成的问题。所以，持续的监控、错误侦测、灾难冗余以及自动恢复的机制必须集成在 GFS 中。 其次，以通常的标准衡量，我们的文件非常巨大。数 GB 的文件非常普遍。每个文件通常都包含许多应用程序对象，比如 web 文档。当我们经常需要处理快速增长的、并且由数亿个对象构成的、数以 TB 的数据集时，采用管理数亿个 KB 大小的小文件的方式是非常不明智的，尽管有些文件系统支持这样的管理方式。因此，设计的假设条件和参数，比如 I/O 操作和 Block 的尺寸都需要重新考虑。 第三，绝大部分文件的修改是采用在文件尾部追加数据，而不是覆盖原有数据的方式。对文件的随机写入操作在实际中几乎不存在。一旦写完之后，对文件的操作就只有读，而且通常是按顺序读。大量的数据符合这些特性，比如：数据分析程序扫描的超大的数据集；正在运行的应用程序生成的连续的数据流；存档的数据；由一台机器生成、另外一台机器处理的中间数据，这些中间数据的处理可能是同时进行的、也可能是后续才处理的。对于这种针对海量文件的访问模式，客户端对数据块缓存是没有意义的，数据的追加操作是性能优化和原子性保证的主要考量因素。 第四，应用程序和文件系统 API 的协同设计提高了整个系统的灵活性。比如，我们放松了对 GFS 一致性模型的要求，这样就减轻了文件系统对应用程序的苛刻要求，大大简化了 GFS 的设计。我们引入了原子性的记录追加操作，从而保证多个客户端能够同时进行追加操作，不需要额外的同步操作来保证数据的一致性。本文后面还有对这些问题的细节的详细讨论。 Google 已经针对不同的应用部署了多套 GFS 集群。最大的一个集群拥有超过 1000 个存储节点，超过300TB 的硬盘空间，被不同机器上的数百个客户端连续不断的频繁访问。 设计概述 设计预期在设计满足我们需求的文件系统时候，我们的设计目标既有机会、又有挑战。之前我们已经提到了一些需要关注的关键点，这里我们将设计的预期目标的细节展开讨论。 系统由许多廉价的普通组件组成，组件失效是一种常态。系统必须持续监控自身的状态，它必须将组件失效作为一种常态，能够迅速地侦测、冗余并恢复失效的组件。 系统存储一定数量的大文件。我们预期会有几百万文件，文件的大小通常在 100MB 或者以上。数个 GB大小的文件也是普遍存在，并且要能够被有效的管理。系统也必须支持小文件，但是不需要针对小文件做专门的优化。 系统的工作负载主要由两种读操作组成：大规模的流式读取和小规模的随机读取。大规模的流式读取通常一次读取数百 KB 的数据，更常见的是一次读取 1MB 甚至更多的数据。来自同一个客户机的连续操作通常是读取同一个文件中连续的一个区域。小规模的随机读取通常是在文件某个随机的位置读取几个 KB 数据。如果应用程序对性能非常关注，通常的做法是把小规模的随机读取操作合并并排序，之后按顺序批量读取，这样就避免了在文件中前后来回的移动读取位置。 系统的工作负载还包括许多大规模的、顺序的、数据追加方式的写操作。一般情况下，每次写入的数据的大小和大规模读类似。数据一旦被写入后，文件就很少会被修改了。系统支持小规模的随机位置写入操作，但是可能效率不彰。 系统必须高效的、行为定义明确的（原文：well-defined）实现多客户端并行追加数据到同一个文件里的语意。我们的文件通常被用于“生产者-消费者”队列，或者其它多路文件合并操作。通常会有数百个生产者，每个生产者进程运行在一台机器上，同时对一个文件进行追加操作。使用最小的同步开销来实现的原子的多路追加数据操作是必不可少的。文件可以在稍后读取，或者是消费者在追加的操作的同时读取文件。 高性能的稳定网络带宽远比低延迟重要。我们的目标程序绝大部分要求能够高速率的、大批量的处理数据，极少有程序对单一的读写操作有严格的响应时间要求。 接口GFS 提供了一套类似传统文件系统的 API 接口函数，虽然并不是严格按照 POSIX 等标准 API 的形式实现的。文件以分层目录的形式组织，用路径名来标识。我们支持常用的操作，如创建新文件、删除文件、打开文件、关闭文件、读和写文件。 另外，GFS 提供了快照和记录追加操作。快照以很低的成本创建一个文件或者目录树的拷贝。记录追加操作允许多个客户端同时对一个文件进行数据追加操作，同时保证每个客户端的追加操作都是原子性的。这对于实现多路结果合并，以及“生产者-消费者”队列非常有用，多个客户端可以在不需要额外的同步锁定的情况下，同时对一个文件追加数据。我们发现这些类型的文件对于构建大型分布应用是非常重要的。快照和记录追加操作将在 3.4 和 3.3 节分别讨论。 架构一个 GFS 集群包含一个单独的 Master 节点（这里的一个单独的 Master 节点的含义是 GFS 系统中只存在一个逻辑上的 Master 组件。后面我们还会提到 Master 节点复制，因此，为了理解方便，我们把 Master 节点视为一个逻辑上的概念，一个逻辑的 Master 节点包括两台物理主机）、多台 Chunk 服务器，并且同时被多个客户端访问，如图 1所示。所有的这些机器通常都是普通的 Linux 机器，运行着用户级别(user-level)的服务进程。我们可以很容易的把 Chunk 服务器和客户端都放在同一台机器上，前提是机器资源允许，并且我们能够接受不可靠的应用程序代码带来的稳定性降低的风险。GFS 存储的文件都被分割成固定大小的 Chunk。在 Chunk 创建的时候，Master 服务器会给每个 Chunk 分配一个不变的、全球唯一的 64 位的 Chunk 标识。Chunk 服务器把 Chunk 以 Linux 文件的形式保存在本地硬盘上，并且根据指定的 Chunk 标识和字节范围来读写块数据。出于可靠性的考虑，每个块都会复制到多个块服务器上。缺省情况下，我们使用 3 个存储复制节点，不过用户可以为不同的文件命名空间设定不同的复制级别。 Master 节点管理所有的文件系统元数据。这些元数据包括名字空间、访问控制信息、文件和 Chunk 的映射信息、以及当前 Chunk 的位置信息。Master 节点还管理着系统范围内的活动，比如，Chunk 租用管理（BDB 也有关于 lease 的描述，不知道是否相同）、孤儿 Chunk（原文：orphaned chunks）的回收、以及 Chunk 在 Chunk 服务器之间的迁移。Master 节点使用心跳信息周期地和每个 Chunk服务器通讯，发送指令到各个 Chunk 服务器并接收 Chunk 服务器的状态信息。 GFS 客户端代码以库的形式被链接到客户程序里。客户端代码实现了 GFS 文件系统的 API 接口函数、应用程序与 Master 节点和 Chunk 服务器通讯、以及对数据进行读写操作。客户端和 Master 节点的通信只获取元数据，所有的数据操作都是由客户端直接和 Chunk 服务器进行交互的。我们不提供 POSIX 标准的 API 的功能，因此，GFS API 调用不需要深入到 Linux vnode 级别。 无论是客户端还是 Chunk 服务器都不需要缓存文件数据。客户端缓存数据几乎没有什么用处，因为大部分程序要么以流的方式读取一个巨大文件，要么工作集太大根本无法被缓存。无需考虑缓存相关的问题也简化了客户端和整个系统的设计和实现（注：不过，客户端会缓存元数据。）。Chunk 服务器不需要缓存文件数据的原因是，Chunk 以本地文件的方式保存，Linux 操作系统的文件系统缓存会把经常访问的数据缓存在内存中。 单一 Master 节点单一的 Master 节点的策略大大简化了我们的设计。单一的 Master 节点可以通过全局的信息精确定位Chunk 的位置以及进行复制决策。另外，我们必须减少对 Master 节点的读写，避免 Master 节点成为系统的瓶颈。客户端并不通过 Master 节点读写文件数据。反之，客户端向 Master 节点询问它应该联系的 Chunk 服务器。客户端将这些元数据信息缓存一段时间，后续的操作将直接和 Chunk 服务器进行数据读写操作。 我们利用图 1 解释一下一次简单读取的流程。首先，客户端把文件名和程序指定的字节偏移，根据固定的 Chunk 大小，转换成文件的 Chunk 索引。然后，它把文件名和 Chunk 索引发送给 Master 节点。Master 节点将相应的 Chunk 标识和副本的位置信息发还给客户端。客户端用文件名和 Chunk 索引作为 key 缓存这些信息。 之后客户端发送请求到其中的一个副本处，一般会选择最近的。请求信息包含了 Chunk 的标识和字节范围。在对这个 Chunk 的后续读取操作中，客户端不必再和 Master 节点通讯了，除非缓存的元数据信息过期或者文件被重新打开。实际上，客户端通常会在一次请求中查询多个 Chunk 信息，Master 节点的回应也可能包含了紧跟着这些被请求的 Chunk 后面的 Chunk 的信息。在实际应用中，这些额外的信息在没有任何代价的情况下，避免了客户端和 Master 节点未来可能会发生的几次通讯。 Chunk 尺寸Chunk 的大小是关键的设计参数之一。我们选择了 64MB，这个尺寸远远大于一般文件系统的 Block size。每个 Chunk 的副本都以普通 Linux 文件的形式保存在 Chunk 服务器上，只有在需要的时候才扩大。惰性空间分配策略避免了因内部碎片造成的空间浪费，内部碎片或许是对选择这么大的 Chunk 尺寸最具争议一点。 选择较大的 Chunk 尺寸有几个重要的优点。首先，它减少了客户端和 Master 节点通讯的需求，因为只需要一次和 Mater 节点的通信就可以获取 Chunk 的位置信息，之后就可以对同一个 Chunk 进行多次的读写操作。这种方式对降低我们的工作负载来说效果显著，因为我们的应用程序通常是连续读写大文件。即使是小规模的随机读取，采用较大的 Chunk 尺寸也带来明显的好处，客户端可以轻松的缓存一个数 TB 的工作数据集所有的 Chunk 位置信息。其次，采用较大的 Chunk 尺寸，客户端能够对一个块进行多次操作，这样就可以通过与 Chunk 服务器保持较长时间的 TCP 连接来减少网络负载。第三，选用较大的 Chunk 尺寸减少了 Master节点需要保存的元数据的数量。这就允许我们把元数据全部放在内存中，在 2.6.1 节我们会讨论元数据全部放在内存中带来的额外的好处。 另一方面，即使配合惰性空间分配，采用较大的 Chunk 尺寸也有其缺陷。小文件包含较少的 Chunk，甚至只有一个 Chunk。当有许多的客户端对同一个小文件进行多次的访问时，存储这些 Chunk 的 Chunk 服务器就会变成热点。在实际应用中，由于我们的程序通常是连续的读取包含多个 Chunk 的大文件，热点还不是主要的问题。 然而，当我们第一次把 GFS 用于批处理队列系统的时候，热点的问题还是产生了：一个可执行文件在GFS 上保存为 single-chunk 文件，之后这个可执行文件在数百台机器上同时启动。存放这个可执行文件的几个 Chunk 服务器被数百个客户端的并发请求访问导致系统局部过载。我们通过使用更大的复制参数来保存可执行文件，以及错开批处理队列系统程序的启动时间的方法解决了这个问题。一个可能的长效解决方案是，在这种的情况下，允许客户端从其它客户端读取数据。 元数据Master 服务器（注意逻辑的 Master 节点和物理的 Master 服务器的区别。后续我们谈的是每个 Master 服务器的行为，如存储、内存等等，因此我们将全部使用物理名称）存储 3 种主要类型的元数据，包括：文件和 Chunk 的命名空间、文件和 Chunk 的对应关系、每个 Chunk 副本的存放地点。所有的元数据都保存在 Master 服务器的内存中。前两种类型的 元数据（元数据：命名空间、文件和 Chunk 的对应关系）同时也会以记录变更日志的方式记录在操作系统的系统日志文件中，日志文件存储在本地磁盘上，同时日志会被复制到其它的远程Master服务器上。采用保存变更日志的方式，我们能够简单可靠的更新 Master 服务器的状态，并且不用担心 Master 服务器崩溃导致数据不一致的风险。Master 服务器不会持久保存 Chunk 位置信息。Master服务器在启动时，或者有新的 Chunk 服务器加入时，向各个 Chunk 服务器轮询它们所存储的 Chunk 的信息。 内存中的数据结构因为元数据保存在内存中，所以 Master 服务器的操作速度非常快。并且，Master 服务器可以在后台简单而高效的周期性扫描自己保存的全部状态信息。这种周期性的状态扫描也用于实现 Chunk 垃圾收集、在 Chunk服务器失效的时重新复制数据、通过 Chunk 的迁移实现跨 Chunk 服务器的负载均衡以及磁盘使用状况统计等功能。4.3 和 4.4 章节将深入讨论这些行为。 将元数据全部保存在内存中的方法有潜在问题：Chunk 的数量以及整个系统的承载能力都受限于 Master服务器所拥有的内存大小。但是在实际应用中，这并不是一个严重的问题。Master 服务器只需要不到 64 个字节的元数据就能够管理一个 64MB 的 Chunk。由于大多数文件都包含多个 Chunk，因此绝大多数 Chunk 都是满的，除了文件的最后一个 Chunk 是部分填充的。同样的，每个文件的在命名空间中的数据大小通常在 64字节以下，因为保存的文件名是用前缀压缩算法压缩过的。 即便是需要支持更大的文件系统，为 Master 服务器增加额外内存的费用是很少的，而通过增加有限的费用，我们就能够把元数据全部保存在内存里，增强了系统的简洁性、可靠性、高性能和灵活性。 Chunk 位置信息Master 服务器并不保存持久化保存哪个 Chunk 服务器存有指定 Chunk 的副本的信息。Master 服务器只是在启动的时候轮询 Chunk 服务器以获取这些信息。Master 服务器能够保证它持有的信息始终是最新的，因为它控制了所有的 Chunk 位置的分配，而且通过周期性的心跳信息监控 Chunk 服务器的状态。 最初设计时，我们试图把 Chunk 的位置信息持久的保存在 Master 服务器上，但是后来我们发现在启动的时候轮询 Chunk 服务器，之后定期轮询更新的方式更简单。这种设计简化了在有 Chunk 服务器加入集群、离开集群、更名、失效、以及重启的时候，Master 服务器和 Chunk 服务器数据同步的问题。在一个拥有数百台服务器的集群中，这类事件会频繁的发生。 可以从另外一个角度去理解这个设计决策：只有 Chunk 服务器才能最终确定一个 Chunk 是否在它的硬盘上。我们从没有考虑过在 Master 服务器上维护一个这些信息的全局视图，因为 Chunk 服务器的错误可能会导致 Chunk 自动消失(比如，硬盘损坏了或者无法访问了)，亦或者操作人员可能会重命名一个 Chunk 服务器。 操作日志操作日志包含了关键的元数据变更历史记录。这对 GFS 非常重要。这不仅仅是因为操作日志是元数据唯一的持久化存储记录，它也作为判断同步操作顺序的逻辑时间基线(也就是通过逻辑日志的序号作为操作发生的逻辑时间，类似于事务系统中的 LSN)。文件和 Chunk，连同它们的版本(参考4.5 节)，都由它们创建的逻辑时间唯一的、永久的标识。 操作日志非常重要，我们必须确保日志文件的完整，确保只有在元数据的变化被持久化后，日志才对客户端是可见的。否则，即使 Chunk 本身没有出现任何问题，我们仍有可能丢失整个文件系统，或者丢失客户端最近的操作。所以，我们会把日志复制到多台远程机器，并且只有把相应的日志记录写入到本地以及远程机器的硬盘后，才会响应客户端的操作请求。Master 服务器会收集多个日志记录后批量处理，以减少写入磁盘和复制对系统整体性能的影响。 Master 服务器在灾难恢复时，通过重演操作日志把文件系统恢复到最近的状态。为了缩短 Master 启动的时间，我们必须使日志足够小(即重演系统操作的日志量尽量的少)。Master 服务器在日志增长到一定量时对系统状态做一次 Checkpoint(Checkpoint 是一种行为，一种对数据库状态作一次快照的行为)，将所有的状态数据写入一个 Checkpoint 文件(注：并删除之前的日志文件)。在灾难恢复的时候，Master 服务器就通过从磁盘上读取这个Checkpoint 文件，以及重演 Checkpoint 之后的有限个日志文件就能够恢复系统。Checkpoint 文件以压缩 B-树形势的数据结构存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析。这大大提高了恢复速度，增强了可用性。 由于创建一个 Checkpoint 文件需要一定的时间，所以 Master 服务器的内部状态被组织为一种格式，这种格式要确保在 Checkpoint 过程中不会阻塞正在进行的修改操作。Master 服务器使用独立的线程切换到新的日志文件和创建新的 Checkpoint 文件。新的 Checkpoint 文件包括切换前所有的修改。对于一个包含数百万个文件的集群，创建一个 Checkpoint 文件需要 1 分钟左右的时间。创建完成后，Checkpoint 文件会被写入在本地和远程的硬盘里。 Master 服务器恢复只需要最新的 Checkpoint 文件和后续的日志文件。旧的 Checkpoint 文件和日志文件可以被删除，但是为了应对灾难性的故障(catastrophes，数据备份相关文档中经常会遇到这个词，表示一种超出预期范围的灾难性事件)，我们通常会多保存一些历史文件。Checkpoint 失败不会对正确性产生任何影响，因为恢复功能的代码可以检测并跳过没有完成的 Checkpoint 文件。 一致性模型GFS 支持一个宽松的一致性模型，这个模型能够很好的支撑我们的高度分布的应用，同时还保持了相对简单且容易实现的优点。本节我们讨论 GFS 的一致性的保障机制，以及对应用程序的意义。我们也着重描述了 GFS 如何管理这些一致性保障机制，但是实现的细节将在本论文的其它部分讨论。 GFS 一致性保障机制文件命名空间的修改（例如，文件创建）是原子性的。它们仅由 Master 节点的控制：命名空间锁提供了原子性和正确性（4.1 章）的保障；Master 节点的操作日志定义了这些操作在全局的顺序（2.6.3 章）。数据修改后文件 region的状态取决于操作的类型、成功与否、以及是否同步修改。表 1 总结了各种操作的结果。 如果所有客户端，无论从哪个副本读取，读到的数据都一样，那么我们认为文件 region 是“一致的”；如果对文件的数据修改之后，region 是一致的，并且客户端能够看到写入操作全部的内容，那么这个 region是“已定义的”。 当一个数据修改操作成功执行，并且没有受到同时执行的其它写入操作的干扰，那么影响的 region 就是已定义的（隐含了一致性）：所有的客户端都可以看到写入的内容。并行修改操作成功完成之后，region 处于一致的、未定义的状态：所有的客户端看到同样的数据，但是无法读到任何一次写入操作写入的数据。通常情况下，文件 region 内包含了来自多个修改操作的、混杂的数据片段。失败的修改操作导致一个 region 处于不一致状态（同时也是未定义的）：不同的客户在不同的时间会看到不同的数据。后面我们将描述应用如何区分已定义和未定义的 region。应用程序没有必要再去细分未定义 region 的不同类型。 数据修改操作分为写入或者记录追加两种。写入操作把数据写在应用程序指定的文件偏移位置上。即使有多个修改操作并行执行时，记录追加操作至少可以把数据原子性的追加到文件中一次，但是偏移位置是由GFS 选择的（3.3 章）(这句话有点费解，其含义是所有的追加写入都会成功，但是有可能被执行了多次，而且每次追加的文件偏移量由 GFS 自己计算。相比而言，通常说的追加操作写的偏移位置是文件的尾部)。GFS 返回给客户端一个偏移量，表示了包含了写入记录的、已定义的 region 的起点。另外，GFS 可能会在文件中间插入填充数据或者重复记录。这些数据占据的文件 region 被认定是不一致的，这些数据通常比用户数据小的多。 经过了一系列的成功的修改操作之后，GFS 确保被修改的文件 region 是已定义的，并且包含最后一次修改操作写入的数据。GFS 通过以下措施确保上述行为：（a） 对 Chunk 的所有副本的修改操作顺序一致（3.1章），（b）使用 Chunk 的版本号来检测副本是否因为它所在的 Chunk 服务器宕机（4.5 章）而错过了修改操作而导致其失效。失效的副本不会再进行任何修改操作，Master 服务器也不再返回这个 Chunk 副本的位置信息给客户端。它们会被垃圾收集系统尽快回收。 由于 Chunk 位置信息会被客户端缓存，所以在信息刷新前，客户端有可能从一个失效的副本读取了数据。在缓存的超时时间和文件下一次被打开的时间之间存在一个时间窗，文件再次被打开后会清除缓存中与该文件有关的所有 Chunk 位置信息。而且，由于我们的文件大多数都是只进行追加操作的，所以，一个失效的副本通常返回一个提前结束的 Chunk 而不是过期的数据。当一个 Reader(本文中将用到两个专有名词，Reader 和 Writer，分别表示执行 GFS 读取和写入操作的程序)重新尝试并联络 Master 服务器时，它就会立刻得到最新的 Chunk 位置信息。 即使在修改操作成功执行很长时间之后，组件的失效也可能损坏或者删除数据。GFS 通过 Master 服务器和所有 Chunk 服务器的定期“握手”来找到失效的 Chunk 服务器，并且使用 Checksum 来校验数据是否损坏（5.2 章）。一旦发现问题，数据要尽快利用有效的副本进行恢复（4.3 章）。只有当一个 Chunk 的所有副本在 GFS 检测到错误并采取应对措施之前全部丢失，这个 Chunk 才会不可逆转的丢失。在一般情况下 GFS 的反应时间(指 Master 节点检测到错误并采取应对措施)是几分钟。即使在这种情况下，Chunk 也只是不可用了，而不是损坏了：应用程序会收到明确的错误信息而不是损坏的数据。 程序的实现使用 GFS 的应用程序可以利用一些简单技术实现这个宽松的一致性模型，这些技术也用来实现一些其它的目标功能，包括：尽量采用追加写入而不是覆盖，Checkpoint，自验证的写入操作，自标识的记录。 在实际应用中，我们所有的应用程序对文件的写入操作都是尽量采用数据追加方式，而不是覆盖方式。一种典型的应用，应用程序从头到尾写入数据，生成了一个文件。写入所有数据之后，应用程序自动将文件改名为一个永久保存的文件名，或者周期性的作 Checkpoint，记录成功写入了多少数据。Checkpoint 文件可以包含程序级别的校验和。Readers 仅校验并处理上个 Checkpoint 之后产生的文件 region，这些文件 region 的状态一定是已定义的。这个方法满足了我们一致性和并发处理的要求。追加写入比随机位置写入更加有效率，对应用程序的失败处理更具有弹性。Checkpoint 可以让 Writer 以渐进的方式重新开始，并且可以防止 Reader处理已经被成功写入，但是从应用程序的角度来看还并未完成的数据。 我们再来分析另一种典型的应用。许多应用程序并行的追加数据到同一个文件，比如进行结果的合并或者是一个生产者-消费者队列。记录追加方式的“至少一次追加”的特性保证了 Writer 的输出。Readers 使用下面的方法来处理偶然性的填充数据和重复内容。Writers 在每条写入的记录中都包含了额外的信息，例如Checksum，用来验证它的有效性。Reader 可以利用 Checksum 识别和抛弃额外的填充数据和记录片段。如果应用不能容忍偶尔的重复内容(比如，如果这些重复数据触发了非幂等操作)，可以用记录的唯一标识符来过滤它们，这些唯一标识符通常用于命名程序中处理的实体对象，例如 web 文档。这些记录 I/O 功能(These functionalities for record I/O，除了剔除重复数据的功能)都包含在我们的程序共享的库中，并且适用于 Google 内部的其它的文件接口实现。所以，相同序列的记录，加上一些偶尔出现的重复数据，都被分发到 Reader 了。 系统交互 我们在设计这个系统时，一个重要的原则是最小化所有操作和 Master 节点的交互。带着这样的设计理念，我们现在描述一下客户机、Master 服务器和 Chunk 服务器如何进行交互，以实现数据修改操作、原子的记录追加操作以及快照功能。 租约（lease）和变更顺序变更是一个会改变 Chunk 内容或者元数据的操作，比如写入操作或者记录追加操作。变更操作会在 Chunk的所有副本上执行。我们使用租约（lease）机制来保持多个副本间变更顺序的一致性。Master 节点为 Chunk的一个副本建立一个租约，我们把这个副本叫做主 Chunk。主 Chunk 对 Chunk 的所有更改操作进行序列化。所有的副本都遵从这个序列进行修改操作。因此，修改操作全局的顺序首先由 Master 节点选择的租约的顺序决定，然后由租约中主 Chunk 分配的序列号决定。 设计租约机制的目的是为了最小化 Master 节点的管理负担。租约的初始超时设置为 60 秒。不过，只要Chunk 被修改了，主 Chunk 就可以申请更长的租期，通常会得到 Master 节点的确认并收到租约延长的时间。这些租约延长请求和批准的信息通常都是附加在 Master 节点和 Chunk 服务器之间的心跳消息中来传递。有时Master 节点会试图提前取消租约（例如，Master 节点想取消在一个已经被改名的文件上的修改操作）。即使Master节点和主Chunk失去联系，它仍然可以安全地在旧的租约到期后和另外一个Chunk副本签订新的租约。 在图 2 中，我们依据步骤编号，展现写入操作的控制流程。 客户机向 Master 节点询问哪一个 Chunk 服务器持有当前的租约，以及其它副本的位置。如果没有一个 Chunk 持有租约，Master 节点就选择其中一个副本建立一个租约(这个步骤在图上没有显示)。 Master 节点将主 Chunk 的标识符以及其它副本(又称为 secondary 副本、二级副本)的位置返回给客户 机。客户机缓存这些数据以便后续的操作。只有在主 Chunk 不可用，或者主 Chunk 回复信息表明它已不再持 有租约的时候，客户机才需要重新跟 Master 节点联系。 客户机把数据推送到所有的副本上。客户机可以以任意的顺序推送数据。Chunk 服务器接收到数据并保 存在它的内部 LRU 缓存中，一直到数据被使用或者过期交换出去。由于数据流的网络传输负载非常高，通过 分离数据流和控制流，我们可以基于网络拓扑情况对数据流进行规划，提高系统性能，而不用去理会哪个 Chunk 服务器保存了主 Chunk。3.2 章节会进一步讨论这点。 当所有的副本都确认接收到了数据，客户机发送写请求到主 Chunk 服务器。这个请求标识了早前推送到 所有副本的数据。主 Chunk 为接收到的所有操作分配连续的序列号，这些操作可能来自不同的客户机，序列 号保证了操作顺序执行。它以序列号的顺序把操作应用到它自己的本地状态中(alex 注:也就是在本地执行这些操作，这句话按字面翻译有点费解，也许应该翻译为“它顺序执行这些操作，并更新自己的状态”)。 主 Chunk 把写请求传递到所有的二级副本。每个二级副本依照主 Chunk 分配的序列号以相同的顺序执行 这些操作。所有的二级副本回复主 Chunk，它们已经完成了操作。 主 Chunk 服务器20回复客户机。任何副本产生的任何错误都会返回给客户机。在出现错误的情况下，写 入操作可能在主 Chunk 和一些二级副本执行成功。(如果操作在主 Chunk 上失败了，操作就不会被分配序列 号，也不会被传递。)客户端的请求被确认为失败，被修改的 region 处于不一致的状态。我们的客户机代码通 过重复执行失败的操作来处理这样的错误。在从头开始重复执行之前，客户机会先从步骤(3)到步骤(7) 做几次尝试。 如果应用程序一次写入的数据量很大，或者数据跨越了多个 Chunk，GFS 客户机代码会把它们分成多个 写操作。这些操作都遵循前面描述的控制流程，但是可能会被其它客户机上同时进行的操作打断或者覆盖。 因此，共享的文件 region 的尾部可能包含来自不同客户机的数据片段，尽管如此，由于这些分解后的写入操 作在所有的副本上都以相同的顺序执行完成，Chunk 的所有副本都是一致的。这使文件 region 处于 2.7 节描述 的一致的、但是未定义的状态。 数据流为了提高网络效率，我们采取了把数据流和控制流分开的措施。在控制流从客户机到主 Chunk、然后再 到所有二级副本的同时，数据以管道的方式，顺序的沿着一个精心选择的 Chunk 服务器链推送。我们的目标 是充分利用每台机器的带宽，避免网络瓶颈和高延时的连接，最小化推送所有数据的延时。 为了充分利用每台机器的带宽，数据沿着一个 Chunk 服务器链顺序的推送，而不是以其它拓扑形式分散 推送(例如，树型拓扑结构)。线性推送模式下，每台机器所有的出口带宽都用于以最快的速度传输数据，而 不是在多个接受者之间分配带宽。 为了尽可能的避免出现网络瓶颈和高延迟的链接(eg，inter-switch 最有可能出现类似问题)，每台机器 都尽量的在网络拓扑中选择一台还没有接收到数据的、离自己最近的机器作为目标推送数据。假设客户机把 数据从 Chunk 服务器 S1 推送到 S4。它把数据推送到最近的 Chunk 服务器 S1。S1 把数据推送到 S2，因为 S2 和 S4 中最接近的机器是 S2。同样的，S2 把数据传递给 S3 和 S4 之间更近的机器，依次类推推送下去。我们 的网络拓扑非常简单，通过 IP 地址就可以计算出节点的“距离”。 最后，我们利用基于 TCP 连接的、管道式数据推送方式来最小化延迟。Chunk 服务器接收到数据后， 马上开始向前推送。管道方式的数据推送对我们帮助很大，因为我们采用全双工的交换网络。接收到数据后(即主 Chunk 所在的 Chunk 服务器)立刻向前推送不会降低接收的速度。在没有网络拥塞的情况下，传送 B 字节的数据到 R 个副本的理想时间是 B/T+RL ，T 是网络的吞吐量，L 是在两台机器数据传输的延迟。通常情况下，我们的网络连接速度是 100Mbps(T)，L 将远小于 1ms。因此，1MB 的数据在理想情况下 80ms 左右就能分发出去。 原子的记录追加GFS 提供了一种原子的数据追加操作–记录追加。传统方式的写入操作，客户程序会指定数据写入的偏 移量。对同一个 region 的并行写入操作不是串行的:region 尾部可能会包含多个不同客户机写入的数据片段。 使用记录追加，客户机只需要指定要写入的数据。GFS 保证至少有一次原子的写入操作成功执行(即写入一 个顺序的 byte 流)，写入的数据追加到 GFS 指定的偏移位置上，之后 GFS 返回这个偏移量给客户机。这类似 于在 Unix 操作系统编程环境中，对以 O_APPEND 模式打开的文件，多个并发写操作在没有竞态条件时的行 为。 记录追加在我们的分布应用中非常频繁的使用，在这些分布式应用中，通常有很多的客户机并行地对同 一个文件追加写入数据。如果我们采用传统方式的文件写入操作，客户机需要额外的复杂、昂贵的同步机制， 例如使用一个分布式的锁管理器。在我们的工作中，这样的文件通常用于多个生产者/单一消费者的队列系统， 或者是合并了来自多个客户机的数据的结果文件。 记录追加是一种修改操作，它也遵循 3.1 节描述的控制流程，除了在主 Chunk 有些额外的控制逻辑。客 户机把数据推送给文件最后一个 Chunk 的所有副本，之后发送请求给主 Chunk。主 Chunk 会检查这次记录追 加操作是否会使 Chunk 超过最大尺寸(64MB)。如果超过了最大尺寸，主 Chunk 首先将当前 Chunk 填充到最 大尺寸，之后通知所有二级副本做同样的操作，然后回复客户机要求其对下一个 Chunk 重新进行记录追加操 作。(记录追加的数据大小严格控制在 Chunk 最大尺寸的 1/4，这样即使在最坏情况下，数据碎片的数量仍然 在可控的范围。)通常情况下追加的记录不超过 Chunk 的最大尺寸，主 Chunk 把数据追加到自己的副本内， 然后通知二级副本把数据写在跟主 Chunk 一样的位置上，最后回复客户机操作成功。 如果记录追加操作在任何一个副本上失败了，客户端就需要重新进行操作。重新进行记录追加的结果是， 同一个 Chunk 的不同副本可能包含不同的数据–重复包含一个记录全部或者部分的数据。GFS 并不保证 Chunk 的所有副本在字节级别是完全一致的。它只保证数据作为一个整体原子的被至少写入一次。这个特性可以通 过简单观察推导出来:如果操作成功执行，数据一定已经写入到 Chunk 的所有副本的相同偏移位置上。这之 后，所有的副本至少都到了记录尾部的长度，任何后续的记录都会追加到更大的偏移地址，或者是不同的 Chunk 上，即使其它的 Chunk 副本被 Master 节点选为了主 Chunk。就我们的一致性保障模型而言，记录追加 操作成功写入数据的 region 是已定义的(因此也是一致的)，反之则是不一致的(因此也就是未定义的)。正如我们在 2.7.2 节讨论的，我们的程序可以处理不一致的区域。 快照快照操作几乎可以瞬间完成对一个文件或者目录树(“源”)做一个拷贝，并且几乎不会对正在进行的其 它操作造成任何干扰。我们的用户可以使用快照迅速的创建一个巨大的数据集的分支拷贝(而且经常是递归 的拷贝拷贝)，或者是在做实验性的数据操作之前，使用快照操作备份当前状态，这样之后就可以轻松的提交 或者回滚到备份时的状态。 就像 AFS(alex 注:AFS，即 Andrew File System，一种分布式文件系统)，我们用标准的 copy-on-write 技术实现快照。当 Master 节点收到一个快照请求，它首先取消作快照的文件的所有 Chunk 的租约。这个措施 保证了后续对这些 Chunk 的写操作都必须与 Master 交互以找到租约持有者。这就给 Master 节点一个率先创建 Chunk 的新拷贝的机会。 租约取消或者过期之后，Master 节点把这个操作以日志的方式记录到硬盘上。然后，Master 节点通过复 制源文件或者目录的元数据的方式，把这条日志记录的变化反映到保存在内存的状态中。新创建的快照文件 和源文件指向完全相同的 Chunk 地址。 在快照操作之后，当客户机第一次想写入数据到 Chunk C，它首先会发送一个请求到 Master 节点查询当 前的租约持有者。Master 节点注意到 Chunk C 的引用计数超过了 1。Master 节点不会马上回复客户机的请求， 而是选择一个新的 Chunk 句柄 C。之后，Master 节点要求每个拥有 Chunk C 当前副本的 Chunk 服务器创建一 个叫做 C的新 Chunk。通过在源 Chunk 所在 Chunk 服务器上创建新的 Chunk，我们确保数据在本地而不是通 过网络复制(我们的硬盘比我们的 100Mb 以太网大约快 3 倍)。从这点来讲，请求的处理方式和任何其它 Chunk 没什么不同:Master 节点确保新 Chunk C`的一个副本拥有租约，之后回复客户机，客户机得到回复后就可以 正常的写这个 Chunk，而不必理会它是从一个已存在的 Chunk 克隆出来的。 Master 节点的操作 Master 节点执行所有的名称空间操作。此外，它还管理着整个系统里所有 Chunk 的副本:它决定 Chunk 的存储位置，创建新 Chunk 和它的副本，协调各种各样的系统活动以保证 Chunk 被完全复制，在所有的 Chunk 服务器之间的进行负载均衡，回收不再使用的存储空间。本节我们讨论上述的主题。 名称空间管理和锁Master 节点的很多操作会花费很长的时间:比如，快照操作必须取消 Chunk 服务器上快照所涉及的所有 的 Chunk 的租约。我们不希望在这些操作的运行时，延缓了其它的 Master 节点的操作。因此，我们允许多个 操作同时进行，使用名称空间的 region 上的锁来保证执行的正确顺序。 不同于许多传统文件系统，GFS 没有针对每个目录实现能够列出目录下所有文件的数据结构。GFS 也不 支持文件或者目录的链接(即 Unix 术语中的硬链接或者符号链接)。在逻辑上，GFS 的名称空间就是一个全 路径和元数据映射关系的查找表。利用前缀压缩，这个表可以高效的存储在内存中。在存储名称空间的树型 结构上，每个节点(绝对路径的文件名或绝对路径的目录名)都有一个关联的读写锁。 每个 Master 节点的操作在开始之前都要获得一系列的锁。通常情况下，如果一个操作涉及/d1/d2/… /dn/leaf，那么操作首先要获得目录/d1，/d1/d2，…，/d1/d2/…/dn 的读锁，以及/d1/d2/…/dn/leaf 的读写锁。注 意，根据操作的不同，leaf 可以是一个文件，也可以是一个目录。 现在，我们演示一下在/home/user 被快照到/save/user 的时候，锁机制如何防止创建文件/home/user/foo。 快照操作获取/home 和/save 的读取锁，以及/home/user 和/save/user 的写入锁。文件创建操作获得/home 和 /home/user 的读取锁，以及/home/user/foo 的写入锁。这两个操作要顺序执行，因为它们试图获取的/home/user 的锁是相互冲突。文件创建操作不需要获取父目录的写入锁，因为这里没有“目录”，或者类似 inode 等用来 禁止修改的数据结构。文件名的读取锁足以防止父目录被删除。 采用这种锁方案的优点是支持对同一目录的并行操作。比如，可以再同一个目录下同时创建多个文件: 每一个操作都获取一个目录名的上的读取锁和文件名上的写入锁。目录名的读取锁足以的防止目录被删除、 改名以及被快照。文件名的写入锁序列化文件创建操作，确保不会多次创建同名的文件。 因为名称空间可能有很多节点，读写锁采用惰性分配策略，在不再使用的时候立刻被删除。同样，锁的 获取也要依据一个全局一致的顺序来避免死锁:首先按名称空间的层次排序，在同一个层次内按字典顺序排序。 副本的位置GFS 集群是高度分布的多层布局结构，而不是平面结构。典型的拓扑结构是有数百个 Chunk 服务器安装 在许多机架上。Chunk 服务器被来自同一或者不同机架上的数百个客户机轮流访问。不同机架上的两台机器 间的通讯可能跨越一个或多个网络交换机。另外，机架的出入带宽可能比机架内所有机器加和在一起的带宽 要小。多层分布架构对数据的灵活性、可靠性以及可用性方面提出特有的挑战。 Chunk 副本位置选择的策略服务两大目标:最大化数据可靠性和可用性，最大化网络带宽利用率。为了 实现这两个目的，仅仅是在多台机器上分别存储这些副本是不够的，这只能预防硬盘损坏或者机器失效带来的影响，以及最大化每台机器的网络带宽利用率。我们必须在多个机架间分布储存 Chunk 的副本。这保证 Chunk 的一些副本在整个机架被破坏或掉线(比如，共享资源，如电源或者网络交换机造成的问题)的情况下依然 存在且保持可用状态。这还意味着在网络流量方面，尤其是针对 Chunk 的读操作，能够有效利用多个机架的整合带宽。另一方面，写操作必须和多个机架上的设备进行网络通信，但是这个代价是我们愿意付出的。 创建，重新复制，重新负载均衡Chunk 的副本有三个用途:Chunk 创建，重新复制和重新负载均衡。当 Master 节点创建一个 Chunk 时，它会选择在哪里放置初始的空的副本。Master 节点会考虑几个因素 :(1)我们希望在低于平均硬盘使用率的 Chunk 服务器上存储新的副本。这样的做法最终能够平衡Chunk服务器之间的硬盘使用率。 (2)我们希望限制在每个 Chunk 服务器上“最近”的 Chunk 创建操作的次数。虽然创建操作本身是廉价的，但是创建操作也意味着随之会有大量的写入数据的操作，因为 Chunk 在 Writer 真正写入数据的时候才 被创建，而在我们的“追加一次，读取多次”的工作模式下，Chunk 一旦写入成功之后就会变为只读的了。 (3)如上所述，我们希望把 Chunk 的副本分布在多个机架之间。 当 Chunk 的有效副本数量少于用户指定的复制因数的时候，Master 节点会重新复制它。这可能是由几个 原因引起的:一个 Chunk 服务器不可用了，Chunk 服务器报告它所存储的一个副本损坏了，Chunk 服务器的 一个磁盘因为错误不可用了，或者 Chunk 副本的复制因数提高了。每个需要被重新复制的 Chunk 都会根据几 个因素进行排序。一个因素是 Chunk 现有副本数量和复制因数相差多少。例如，丢失两个副本的 Chunk 比丢 失一个副本的 Chunk 有更高的优先级。另外，我们优先重新复制活跃(live)文件的 Chunk 而不是最近刚被 删除的文件的 Chunk(查看 4.4 节)。最后，为了最小化失效的 Chunk 对正在运行的应用程序的影响，我们提 高会阻塞客户机程序处理流程的 Chunk 的优先级。 Master 节点选择优先级最高的 Chunk，然后命令某个 Chunk 服务器直接从可用的副本”克隆”一个副本 出来。选择新副本的位置的策略和创建时类似:平衡硬盘使用率、限制同一台 Chunk 服务器上的正在进行的 克隆操作的数量、在机架间分布副本。为了防止克隆产生的网络流量大大超过客户机的流量，Master 节点对 整个集群和每个 Chunk 服务器上的同时进行的克隆操作的数量都进行了限制。另外，Chunk 服务器通过调节 它对源 Chunk 服务器读请求的频率来限制它用于克隆操作的带宽。 最后，Master 服务器周期性地对副本进行重新负载均衡:它检查当前的副本分布情况，然后移动副本以 便更好的利用硬盘空间、更有效的进行负载均衡。而且在这个过程中，Master 服务器逐渐的填满一个新的 Chunk 服务器，而不是在短时间内用新的 Chunk 填满它，以至于过载。新副本的存储位置选择策略和上面讨论的相 同。另外，Master 节点必须选择哪个副本要被移走。通常情况，Master 节点移走那些剩余空间低于平均值的Chunk 服务器上的副本，从而平衡系统整体的硬盘使用率。 垃圾回收GFS 在文件删除后不会立刻回收可用的物理空间。GFS 空间回收采用惰性的策略，只在文件和 Chunk 级 的常规垃圾收集时进行。我们发现这个方法使系统更简单、更可靠。 机制当一个文件被应用程序删除时，Master 节点象对待其它修改操作一样，立刻把删除操作以日志的方式记 录下来。但是，Master 节点并不马上回收资源，而是把文件名改为一个包含删除时间戳的、隐藏的名字。当 Master 节点对文件系统命名空间做常规扫描的时候，它会删除所有三天前的隐藏文件(这个时间间隔是可以 设置的)。直到文件被真正删除，它们仍旧可以用新的特殊的名字读取，也可以通过把隐藏文件改名为正常显 示的文件名的方式“反删除”。当隐藏文件被从名称空间中删除，Master 服务器内存中保存的这个文件的相关 元数据才会被删除。这也有效的切断了文件和它包含的所有 Chunk 的连接。 在对 Chunk 名字空间做类似的常规扫描时，Master 节点找到孤儿 Chunk(不被任何文件包含的 Chunk) 并删除它们的元数据。Chunk 服务器在和 Master 节点交互的心跳信息中，报告它拥有的 Chunk 子集的信息， Master 节点回复 Chunk 服务器哪些 Chunk 在 Master 节点保存的元数据中已经不存在了。Chunk 服务器可以任 意删除这些 Chunk 的副本。 讨论虽然分布式垃圾回收在编程语言领域是一个需要复杂的方案才能解决的难题，但是在 GFS 系统中是非常 简单的。我们可以轻易的得到 Chunk 的所有引用:它们都只存储在 Master 服务器上的文件到块的映射表中。 我们也可以很轻易的得到所有 Chunk 的副本:它们都以 Linux 文件的形式存储在 Chunk 服务器的指定目录下。 所有 Master 节点不能识别的副本都是“垃圾”。 垃圾回收在空间回收方面相比直接删除有几个优势。首先，对于组件失效是常态的大规模分布式系统， 垃圾回收方式简单可靠。Chunk 可能在某些 Chunk 服务器创建成功，某些 Chunk 服务器上创建失败，失败的 副本处于无法被 Master 节点识别的状态。副本删除消息可能丢失，Master 节点必须重新发送失败的删除消息， 包括自身的和 Chunk 服务器的(自身的指删除 metadata 的消息)。垃圾回收提供了一致的、可靠的清除无用副本的方法。第二，垃圾回收把 存储空间的回收操作合并到 Master 节点规律性的后台活动中，比如，例行扫描和与 Chunk 服务器握手等。因 此，操作被批量的执行，开销会被分散。另外，垃圾回收在 Master 节点相对空闲的时候完成。这样 Master节点就可以给那些需要快速反应的客户机请求提供更快捷的响应。第三，延缓存储空间回收为意外的、不可逆转的删除操作提供了安全保障。 根据我们的使用经验，延迟回收空间的主要问题是，延迟回收会阻碍用户调优存储空间的使用，特别是当存储空间比较紧缺的时候。当应用程序重复创建和删除临时文件时，释放的存储空间不能马上重用。我们 通过显式的再次删除一个已经被删除的文件的方式加速空间回收的速度。我们允许用户为命名空间的不同部 分设定不同的复制和回收策略。例如，用户可以指定某些目录树下面的文件不做复制，删除的文件被即时的、 不可恢复的从文件系统移除。 过期失效的副本检测当 Chunk 服务器失效时，Chunk 的副本有可能因错失了一些修改操作而过期失效。Master 节点保存了每 个 Chunk 的版本号，用来区分当前的副本和过期副本。 无论何时，只要 Master 节点和 Chunk 签订一个新的租约，它就增加 Chunk 的版本号，然后通知最新的 副本。Master 节点和这些副本都把新的版本号记录在它们持久化存储的状态信息中。这个动作发生在任何客 户机得到通知以前，因此也是对这个 Chunk 开始写之前。如果某个副本所在的 Chunk 服务器正好处于失效状 态，那么副本的版本号就不会被增加。Master 节点在这个 Chunk 服务器重新启动，并且向 Master 节点报告它 拥有的 Chunk 的集合以及相应的版本号的时候，就会检测出它包含过期的 Chunk。如果 Master 节点看到一个 比它记录的版本号更高的版本号，Master 节点会认为它和 Chunk 服务器签订租约的操作失败了，因此会选择 更高的版本号作为当前的版本号。 Master 节点在例行的垃圾回收过程中移除所有的过期失效副本。在此之前，Master 节点在回复客户机的 Chunk 信息请求的时候，简单的认为那些过期的块根本就不存在。另外一重保障措施是，Master 节点在通知 客户机哪个 Chunk 服务器持有租约、或者指示 Chunk 服务器从哪个 Chunk 服务器进行克隆时，消息中都附带 了 Chunk 的版本号。客户机或者 Chunk 服务器在执行操作时都会验证版本号以确保总是访问当前版本的数据。 容错和诊断 我们在设计 GFS 时遇到的最大挑战之一是如何处理频繁发生的组件失效。组件的数量和质量让这些问题 出现的频率远远超过一般系统意外发生的频率:我们不能完全依赖机器的稳定性，也不能完全相信硬盘的可 靠性。组件的失效可能造成系统不可用，更糟糕的是，还可能产生不完整的数据。我们讨论我们如何面对这 些挑战，以及当组件失效不可避免的发生时，用 GFS 自带工具诊断系统故障。 高可用性在 GFS 集群的数百个服务器之中，在任何给定的时间必定会有些服务器是不可用的。我们使用两条简单但是有效的策略保证整个系统的高可用性:快速恢复和复制。 快速恢复不管 Master 服务器和 Chunk 服务器是如何关闭的，它们都被设计为可以在数秒钟内恢复它们的状态并重 新启动。事实上，我们并不区分正常关闭和异常关闭;通常，我们通过直接 kill 掉进程来关闭服务器。客户 机和其它的服务器会感觉到系统有点颠簸(a minor hiccup)，正在发出的请求会超时，需要重新连接到重启后的服务器，然后 重试这个请求。6.6.2 章节记录了实测的启动时间。 Chunk 复制正如之前讨论的，每个 Chunk 都被复制到不同机架上的不同的 Chunk 服务器上。用户可以为文件命名空 间的不同部分设定不同的复制级别。缺省是 3。当有 Chunk 服务器离线了，或者通过 Chksum 校验(参考 5.2 节)发现了已经损坏的数据，Master 节点通过克隆已有的副本保证每个 Chunk 都被完整复制(即每个 Chunk 都有复制因子制定的个数个副本，缺省是 3)。虽然 Chunk 复制策略对我们非常有效，但是我们也在寻找其它形式的跨服务器的冗余解决方案，比如使用奇偶校验、或 者 Erasure codes(Erasure codes 用来解决链接层中不相关的错误，以及网络拥塞和 buffer 限制造成的丢包错误)来解决我们日益增长的只读存储需求。我们的系统主要的工作负载是追加方式的写入和读取 操作，很少有随机的写入操作，因此，我们认为在我们这个高度解耦合的系统架构下实现这些复杂的冗余方 案很有挑战性，但并非不可实现。 Master 服务器的复制为了保证 Master 服务器的可靠性，Master 服务器的状态也要复制。Master 服务器所有的操作日志和 checkpoint 文件都被复制到多台机器上。对 Master 服务器状态的修改操作能够提交成功的前提是，操作日志 写入到 Master 服务器的备节点和本机的磁盘。简单说来，一个 Master 服务进程负责所有的修改操作，包括后 台的服务，比如垃圾回收等改变系统内部状态活动。当它失效的时，几乎可以立刻重新启动。如果 Master 进 程所在的机器或者磁盘失效了，处于 GFS 系统外部的监控进程会在其它的存有完整操作日志的机器上启动一 个新的 Master 进程。客户端使用规范的名字访问 Master(比如 gfs-test)节点，这个名字类似 DNS 别名，因 此也就可以在 Master 进程转到别的机器上执行时，通过更改别名的实际指向访问新的 Master 节点。 此外，GFS 中还有些“影子”Master 服务器，这些“影子”服务器在“主”Master 服务器宕机的时候提 供文件系统的只读访问。它们是影子，而不是镜像，所以它们的数据可能比“主”Master 服务器更新要慢， 通常是不到 1 秒。对于那些不经常改变的文件、或者那些允许获取的数据有少量过期的应用程序，“影子”Master 服务器能够提高读取的效率。事实上，因为文件内容是从 Chunk 服务器上读取的，因此，应用程序不 会发现过期的文件内容。在这个短暂的时间窗内，过期的可能是文件的元数据，比如目录的内容或者访问控制信息。 “影子”Master 服务器为了保持自身状态是最新的，它会读取一份当前正在进行的操作的日志副本，并且依照和主 Master 服务器完全相同的顺序来更改内部的数据结构。和主 Master 服务器一样，“影子”Master 服务器在启动的时候也会从 Chunk 服务器轮询数据(之后定期拉数据)，数据中包括了 Chunk 副本的位置信 息;“影子”Master 服务器也会定期和 Chunk 服务器“握手”来确定它们的状态。在主 Master 服务器因创建 和删除副本导致副本位置信息更新时，“影子”Master 服务器才和主 Master 服务器通信来更新自身状态。 数据完整性每个 Chunk 服务器都使用 Checksum 来检查保存的数据是否损坏。考虑到一个 GFS 集群通常都有好几百 台机器、几千块硬盘，磁盘损坏导致数据在读写过程中损坏或者丢失是非常常见的(第 7 节讲了一个原因)。 我们可以通过别的 Chunk 副本来解决数据损坏问题，但是跨越 Chunk 服务器比较副本来检查数据是否损坏很 不实际。另外，GFS 允许有歧义的副本存在:GFS 修改操作的语义，特别是早先讨论过的原子纪录追加的操 作，并不保证副本完全相同(alex 注:副本不是 byte-wise 完全一致的)。因此，每个 Chunk 服务器必须独立维 护 Checksum 来校验自己的副本的完整性。 我们把每个 Chunk 都分成 64KB 大小的块。每个块都对应一个 32 位的 Checksum。和其它元数据一样， Checksum 与其它的用户数据是分开的，并且保存在内存和硬盘上，同时也记录操作日志。对于读操作来说，在把数据返回给客户端或者其它的 Chunk 服务器之前，Chunk 服务器会校验读取操作 涉及的范围内的块的 Checksum。因此 Chunk 服务器不会把错误数据传递到其它的机器上。如果发生某个块的 Checksum 不正确，Chunk 服务器返回给请求者一个错误信息，并且通知 Master 服务器这个错误。作为回应， 请求者应当从其它副本读取数据，Master 服务器也会从其它副本克隆数据进行恢复。当一个新的副本就绪后， Master 服务器通知副本错误的 Chunk 服务器删掉错误的副本。 Checksum 对读操作的性能影响很小，可以基于几个原因来分析一下。因为大部分的读操作都至少要读取 几个块，而我们只需要读取一小部分额外的相关数据进行校验。GFS 客户端代码通过每次把读取操作都对齐 在 Checksum block 的边界上，进一步减少了这些额外的读取操作的负面影响。另外，在 Chunk 服务器上， Checksum 的查找和比较不需要 I/O 操作，Checksum 的计算可以和 I/O 操作同时进行。 Checksum 的计算针对在 Chunk 尾部的追加写入操作做了高度优化(与之对应的是覆盖现有数据的写入操 作)，因为这类操作在我们的工作中占了很大比例。我们只增量更新最后一个不完整的块的 Checksum，并且 用所有的追加来的新 Checksum 块来计算新的 Checksum。即使是最后一个不完整的 Checksum 块已经损坏了，且我们不能够马上检查出来，由于新的 Checksum 和已有数据不吻合，在下次对这个块进行读取操作的时候，会检查出数据已经损坏了。 相比之下，如果写操作覆盖已经存在的一个范围内的 Chunk，我们必须读取和校验被覆盖的第一个和最后一个块，然后再执行写操作;操作完成之后再重新计算和写入新的 Checksum。如果我们不校验第一个和最 后一个被写的块，那么新的 Checksum 可能会隐藏没有被覆盖区域内的数据错误。 在 Chunk 服务器空闲的时候，它会扫描和校验每个不活动的 Chunk 的内容。这使得我们能够发现很少被 读取的 Chunk 是否完整。一旦发现有 Chunk 的数据损坏，Master 可以创建一个新的、正确的副本，然后把损 坏的副本删除掉。这个机制也避免了非活动的、已损坏的 Chunk 欺骗 Master 节点，使 Master 节点认为它们已 经有了足够多的副本了。 诊断工具详尽的、深入细节的诊断日志，在问题隔离、调试、以及性能分析等方面给我们带来无法估量的帮助， 同时也只需要很小的开销。没有日志的帮助，我们很难理解短暂的、不重复的机器之间的消息交互。GFS 的 服务器会产生大量的日志，记录了大量关键的事件(比如，Chunk 服务器启动和关闭)以及所有的 RPC 的请 求和回复。这些诊断日志可以随意删除，对系统的正确运行不造成任何影响。然而，我们在存储空间允许的 情况下会尽量的保存这些日志。 RPC 日志包含了网络上发生的所有请求和响应的详细记录，但是不包括读写的文件数据。通过匹配请求 与回应，以及收集不同机器上的 RPC 日志记录，我们可以重演所有的消息交互来诊断问题。日志还用来跟踪 负载测试和性能分析。 日志对性能的影响很小(远小于它带来的好处)，因为这些日志的写入方式是顺序的、异步的。最近发生 的事件日志保存在内存中，可用于持续不断的在线监控。 度量 本节中，我们将使用一些小规模基准测试来展现 GFS 系统架构和实现上的一些固有瓶颈，还有些来自Google 内部使用的真实的 GFS 集群的基准数据。 小规模基准测试我们在一个包含 1 台 Master 服务器，2 台 Master 服务器复制节点，16 台 Chunk 服务器和 16 个客户机组 成的 GFS 集群上测量性能。注意，采用这样的集群配置方案只是为了易于测试。典型的 GFS 集群有数百个 Chunk 服务器和数百个客户机。 所有机器的配置都一样:两个 PIII 1.4GHz 处理器，2GB 内存，两个 80G/5400rpm 的硬盘，以及 100Mbps 全双工以太网连接到一个 HP2524 交换机。GFS 集群中所有的 19 台服务器都连接在一个交换机，所有 16 台客户机连接到另一个交换机上。两个交换机之间使用 1Gbps 的线路连接。 读取N 个客户机从 GFS 文件系统同步读取数据。每个客户机从 320GB 的文件集合中随机读取 4MB region 的 内容。读取操作重复执行 256 次，因此，每个客户机最终都读取 1GB 的数据。所有的 Chunk 服务器加起来总 共只有 32GB 的内存，因此，我们预期只有最多 10%的读取请求命中 Linux 的文件系统缓冲。我们的测试结 果应该和一个在没有文件系统缓存的情况下读取测试的结果接近。上边的曲线显示了我们网络拓扑下的合计理论吞吐量上限。下边的曲线显示了观测到的吞吐量。这个曲线有着 95%的可靠性，因为有时候测量会不够精确。 图 3(a)显示了 N 个客户机整体的读取速度以及这个速度的理论极限。当连接两个交换机的 1Gbps 的链路饱和时，整体读取速度达到理论的极限值是 125MB/S，或者说每个客户机配置的 100Mbps 网卡达到饱和时， 每个客户机读取速度的理论极限值是 12.5MB/s。实测结果是，当一个客户机读取的时候，读取的速度是 10MB/s， 也就是说达到客户机理论读取速度极限值的 80%。对于 16 个客户机，整体的读取速度达到了 94MB/s，大约 是理论整体读取速度极限值的 75%，也就是说每个客户机的读取速度是 6MB/s。读取效率从 80%降低到了 75%， 主要的原因是当读取的客户机增加时，多个客户机同时读取一个 Chunk 服务器的几率也增加了，导致整体的 读取效率下降。 写入N 个客户机同时向 N 个不同的文件中写入数据。每个客户机以每次 1MB 的速度连续写入 1GB 的数据。 图 3(b)显示了整体的写入速度和它们理论上的极限值。理论上的极限值是 67MB/s，因为我们需要把每一 byte 写入到 16 个 Chunk 服务器中的 3 个上，而每个 Chunk 服务器的输入连接速度是 12.5MB/s。 一个客户机的写入速度是 6.3MB，大概是理论极限值的一半。导致这个结果的主要原因是我们的网络协 议栈。它与我们推送数据到 Chunk 服务器时采用的管道模式不相适应。从一个副本到另一个副本的数据传输延迟降低了整个的写入速度。 16 个客户机整体的写入速度达到了 35MB/s(即每个客户机 2.2MB/s)，大约只是理论极限值的一半。和多个客户机读取的情形很类型，随着客户机数量的增加，多个客户机同时写入同一个 Chunk 服务器的几率也 增加了。而且，16 个客户机并行写入可能引起的冲突比 16 个客户机并行读取要大得多，因为每个写入都会 涉及三个不同的副本。 写入的速度比我们想象的要慢。在实际应用中，这没有成为我们的主要问题，因为即使在单个客户机上 能够感受到延时，它也不会在有大量客户机的时候对整体的写入带宽造成显著的影响。 记录追加图 3(c)显示了记录追加操作的性能。N 个客户机同时追加数据到一个文件。记录追加操作的性能受限 于保存文件最后一个 Chunk 的 Chunk 服务器的带宽，而与客户机的数量无关。记录追加的速度由一个客户机 的 6.0MB/s 开始，下降到 16 个客户机的 4.8MB/s 为止，速度的下降主要是由于不同客户端的网络拥塞以及网 络传输速度的不同而导致的。 我们的程序倾向于同时处理多个这样的文件。换句话说，即 N 个客户机同时追加数据到 M 个共享文件中， 这里 N 和 M 都是数十或者数百以上。所以，在我们的实际应用中，Chunk 服务器的网络拥塞并没有成为一个 严重问题，如果 Chunk 服务器的某个文件正在写入，客户机会去写另外一个文件。 实际应用中的集群我们现在来仔细评估一下 Google 内部正在使用的两个集群，它们具有一定的代表性。集群 A 通常被上百 个工程师用于研究和开发。典型的任务是被人工初始化后连续运行数个小时。它通常读取数 MB 到数 TB 的 数据，之后进行转化或者分析，最后把结果写回到集群中。集群 B 主要用于处理当前的生产数据。集群 B 的 任务持续的时间更长，在很少人工干预的情况下，持续的生成和处理数 TB 的数据集。在这两个案例中，一 个单独的“任务”都是指运行在多个机器上的多个进程，它们同时读取和写入多个文件。 存储如上表前五行所描述的，两个集群都由上百台 Chunk 服务器组成，支持数 TB 的硬盘空间;两个集群虽 然都存储了大量的数据，但是还有剩余的空间。“已用空间”包含了所有的 Chunk 副本。实际上所有的文件都 复制了三份。因此，集群实际上各存储了 18TB 和 52TB 的文件数据。 两个集群存储的文件数量都差不多，但是集群 B 上有大量的死文件。所谓“死文件”是指文件被删除了 或者是被新版本的文件替换了，但是存储空间还没有来得及被回收。由于集群 B 存储的文件较大，因此它的 Chunk 数量也比较多。 元数据Chunk 服务器总共保存了十几 GB 的元数据，大多数是来自用户数据的、64KB 大小的块的 Checksum。 保存在 Chunk 服务器上其它的元数据是 Chunk 的版本号信息，我们在 4.5 节描述过。 在 Master 服务器上保存的元数据就小的多了，大约只有数十 MB，或者说平均每个文件 100 字节的元数 据。这和我们设想的是一样的，Master 服务器的内存大小在实际应用中并不会成为 GFS 系统容量的瓶颈。大 多数文件的元数据都是以前缀压缩模式存放的文件名。Master 服务器上存放的其它元数据包括了文件的所有 者和权限、文件到 Chunk 的映射关系，以及每一个 Chunk 的当前版本号。此外，针对每一个 Chunk，我们都 保存了当前的副本位置以及对它的引用计数，这个引用计数用于实现写时拷贝(即 COW，copy-on-write)。 对于每一个单独的服务器，无论是 Chunk 服务器还是 Master 服务器，都只保存了 50MB 到 100MB 的元 数据。因此，恢复服务器是非常快速的:在服务器响应客户请求之前，只需要花几秒钟时间从磁盘上读取这 些数据就可以了。不过，Master 服务器会持续颠簸一段时间–通常是 30 到 60 秒–直到它完成轮询所有的 Chunk服务器，并获取到所有 Chunk 的位置信息。 读写速率表三显示了不同时段的读写速率。在测试的时候，这两个集群都运行了一周左右的时间。(这两个集群最 近都因为升级新版本的 GFS 重新启动过了)。 集群重新启动后，平均写入速率小于 30MB/s。当我们提取性能数据的时候，集群 B 正进行大量的写入操 作，写入速度达到了 100MB/s，并且因为每个 Chunk 都有三个副本的原因，网络负载达到了 300MB/s。 读取速率要比写入速率高的多。正如我们设想的那样，总的工作负载中，读取的比例远远高于写入的比 例。两个集群都进行着繁重的读取操作。特别是，集群 A 在一周时间内都维持了 580MB/s 的读取速度。集群 A 的网络配置可以支持 750MB/s 的速度，显然，它有效的利用了资源。集群 B 支持的峰值读取速度是 1300MB/s， 但是它的应用只用到了 380MB/s。 Master 服务器的负载表 3 的数据显示了发送到 Master 服务器的操作请求大概是每秒钟 200 到 500 个。Master 服务器可以轻松 的应付这个请求速度，所以 Master 服务器的处理能力不是系统的瓶颈。 在早期版本的 GFS 中，Master 服务器偶尔会成为瓶颈。它大多数时间里都在顺序扫描某个很大的目录 (包含数万个文件)去查找某个特定的文件。因此我们修改了 Master 服务器的数据结构，通过对名字空间进 行二分查找来提高效率。现在 Master 服务器可以轻松的每秒钟进行数千次文件访问。如果有需要的话，我们 可以通过在名称空间数据结构之前设置名称查询缓冲的方式进一步提高速度。 恢复时间当某个 Chunk 服务器失效了，一些 Chunk 副本的数量可能会低于复制因子指定的数量，我们必须通过克 隆副本使 Chunk 副本数量达到复制因子指定的数量。恢复所有 Chunk 副本所花费的时间取决于资源的数量。 在我们的试验中，我们把集群 B 上的一个 Chunk 服务器 Kill 掉。这个 Chunk 服务器上大约有 15000 个 Chunk， 共计 600GB 的数据。为了减小克隆操作对正在运行的应用程序的影响，以及为 GFS 调度决策提供修正空间， 我们缺省的把集群中并发克隆操作的数量设置为 91 个(Chunk 服务器的数量的 40%)，每个克隆操作最多允 许使用的带宽是 6.25MB/s(50mbps)。所有的 Chunk 在 23.2 分钟内恢复了，复制的速度高达 440MB/s。 在另外一个测试中，我们 Kill 掉了两个 Chunk 服务器，每个 Chunk 服务器大约有 16000 个 Chunk，共 计 660GB 的数据。这两个故障导致了 266 个 Chunk 只有单个副本。这 266 个 Chunk 被 GFS 优先调度进行复 制，在 2 分钟内恢复到至少有两个副本;现在集群被带入到另外一个状态，在这个状态下，系统可以容忍另 外一个 Chunk 服务器失效而不丢失数据。 工作负荷分析(Workload Breakdown)本节中，我们展示了对两个 GFS 集群工作负载情况的详细分析，这两个集群和 6.2 节中的类似，但是不完全相同。集群 X 用于研究和开发，集群 Y 用于生产数据处理。 方法论和注意事项本章节列出的这些结果数据只包括客户机发起的原始请求，因此，这些结果能够反映我们的应用程序对 GFS 文件系统产生的全部工作负载。它们不包含那些为了实现客户端请求而在服务器间交互的请求，也不包 含 GFS 内部的后台活动相关的请求，比如前向转发的写操作，或者重新负载均衡等操作。 我们从 GFS 服务器记录的真实的 RPC 请求日志中推导重建出关于 IO 操作的统计信息。例如，GFS 客 户程序可能会把一个读操作分成几个 RPC 请求来提高并行度，我们可以通过这些 RPC 请求推导出原始的读 操作。因为我们的访问模式是高度程式化，所以我们认为任何不符合的数据都是误差。应用程序如果能够记 录更详尽的日志，就有可能提供更准确的诊断数据;但是为了这个目的去重新编译和重新启动数千个正在运 行的客户机是不现实的，而且从那么多客户机上收集结果也是个繁重的工作。 应该避免从我们的工作负荷数据中过度的归纳出普遍的结论(即不要把本节的数据作为基础的指导性数据)。因为 Google 完全控制着 GFS 和使用 GFS 的应用程序，所以，应用程序都针对 GFS 做了优化，同时，GFS 也是为了这些应用程序而设计的。这样的相 互作用也可能存在于一般程序和文件系统中，但是在我们的案例中这样的作用影响可能更显著。 Chunk 服务器工作负荷表 4 显示了操作按涉及的数据量大小的分布情况。读取操作按操作涉及的数据量大小呈现了双峰分布。 小的读取操作(小于 64KB)一般是由查找操作的客户端发起的，目的在于从巨大的文件中查找小块的数据。 大的读取操作(大于 512KB)一般是从头到尾顺序的读取整个文件。 在集群 Y 上，有相当数量的读操作没有返回任何的数据。在我们的应用中，尤其是在生产系统中，经常 使用文件作为生产者-消费者队列。生产者并行的向文件中追加数据，同时，消费者从文件的尾部读取数据。某些情况下，消费者读取的速度超过了生产者写入的速度，这就会导致没有读到任何数据的情况。集群 X 通 常用于短暂的数据分析任务，而不是长时间运行的分布式应用，因此，集群 X 很少出现这种情况。 写操作按数据量大小也同样呈现为双峰分布。大的写操作(超过 256KB)通常是由于 Writer 使用了缓存 机制导致的。Writer 缓存较小的数据，通过频繁的 Checkpoint 或者同步操作，或者只是简单的统计小的写入 (小于 64KB)的数据量(alex 注:即汇集多次小的写入操作，当数据量达到一个阈值，一次写入)，之后批量 写入。 再来观察一下记录追加操作。我们可以看到集群 Y 中大的记录追加操作所占比例比集群 X 多的多，这是 因为集群 Y 用于我们的生产系统，针对 GFS 做了更全面的调优。表 5 显示了按操作涉及的数据量的大小统计出来的总数据传输量。在所有的操作中，大的操作(超过 256KB)占据了主要的传输量。小的读取(小于 64KB)虽然传输的数据量比较少，但是在读取的数据量中仍 占了相当的比例，这是因为在文件中随机 Seek 的工作负荷而导致的。 记录追加 vs. 写操作记录追加操作在我们的生产系统中大量使用。对于集群 X，记录追加操作和普通写操作的比例按照字节 比是 108:1，按照操作次数比是 8:1。对于作为我们的生产系统的集群 Y 来说，这两个比例分别是 3.7:1 和 2.5:1。 更进一步，这一组数据说明在我们的两个集群上，记录追加操作所占比例都要比写操作要大。对于集群 X， 在整个测量过程中，记录追加操作所占比率都比较低，因此结果会受到一两个使用某些特定大小的 buffer 的 应用程序的影响。 如同我们所预期的，我们的数据修改操作主要是记录追加操作而不是覆盖方式的写操作。我们测量了第 一个副本的数据覆盖写的情况。这近似于一个客户机故意覆盖刚刚写入的数据，而不是增加新的数据。对于 集群 X，覆盖写操作在写操作所占据字节上的比例小于 0.0001%，在所占据操作数量上的比例小于 0.0003%。 对于集群 Y，这两个比率都是 0.05%。虽然这只是某一片断的情况，但是仍然高于我们的预期。这是由于这 些覆盖写的操作，大部分是由于客户端在发生错误或者超时以后重试的情况。这在本质上应该不算作工作负 荷的一部分，而是重试机制产生的结果。 Master 的工作负荷表 6 显示了 Master 服务器上的请求按类型区分的明细表。大部分的请求都是读取操作查询 Chunk 位置信 息(FindLocation)、以及修改操作查询 lease 持有者的信息(FindLease-Locker)。 集群 X 和 Y 在删除请求的数量上有着明显的不同，因为集群 Y 存储了生产数据，一般会重新生成数据 以及用新版本的数据替换旧有的数据。数量上的差异也被隐藏在了 Open 请求中，因为旧版本的文件可能在以 重新写入的模式打开时，隐式的被删除了(类似 UNIX 的 open 函数中的“w”模式)。 FindMatchingFiles 是一个模式匹配请求，支持“ls”以及其它类似的文件系统操作。不同于 Master 服务 器的其它请求，它可能会检索 namespace 的大部分内容，因此是非常昂贵的操作。集群 Y 的这类请求要多一 些，因为自动化数据处理的任务进程需要检查文件系统的各个部分，以便从全局上了解应用程序的状态。与 之不同的是，集群 X 的应用程序更加倾向于由单独的用户控制，通常预先知道自己所需要使用的全部文件的 名称。 经验 在建造和部署 GFS 的过程中，我们经历了各种各样的问题，有些是操作上的，有些是技术上的。起初，GFS 被设想为我们的生产系统的后端文件系统。随着时间推移，在 GFS 的使用中逐步的增加了对 研究和开发任务的支持。我们开始增加一些小的功能，比如权限和配额，到了现在，GFS 已经初步支持了这 些功能。虽然我们生产系统是严格受控的，但是用户层却不总是这样的。需要更多的基础架构来防止用户间 的相互干扰。 我们最大的问题是磁盘以及和 Linux 相关的问题。很多磁盘都声称它们支持某个范围内的 Linux IDE 硬盘 驱动程序，但是实际应用中反映出来的情况却不是这样，它们只支持最新的驱动。因为协议版本很接近，所 以大部分磁盘都可以用，但是偶尔也会有由于协议不匹配，导致驱动和内核对于驱动器的状态判断失误。这会导致数据因为内核中的问题意外的被破坏了。这个问题促使我们使用 Checksum 来校验数据，同时我们也修改内核来处理这些因为协议不匹配带来的问题。 较早的时候，我们在使用 Linux 2.2 内核时遇到了些问题，主要是 fsync()的效率问题。它的效率与文件的大小而不是文件修改部分的大小有关。这在我们的操作日志文件过大时给出了难题，尤其是在我们尚未实 现 Checkpoint 的时候。我们费了很大的力气用同步写来解决这个问题，但是最后还是移植到了 Linux2.4 内核 上。 另一个和 Linux 相关的问题是单个读写锁的问题，也就是说，在某一个地址空间的任意一个线程都必须 在从磁盘 page in(读锁)的时候先 hold 住，或者在 mmap()调用(写锁)的时候改写地址空间。我们发现即 使我们的系统负载很轻的情况下也会有偶尔的超时，我们花费了很多的精力去查找资源的瓶颈或者硬件的问 题。最后我们终于发现这个单个锁在磁盘线程交换以前映射的数据到磁盘的时候，锁住了当前的网络线程， 阻止它把新数据映射到内存。由于我们的性能主要受限于网络接口，而不是内存 copy 的带宽，因此，我们用 pread()替代 mmap()，用了一个额外的 copy 动作来解决这个问题。 尽管偶尔还是有其它的问题，Linux 的开放源代码还是使我们能够快速探究和理解系统的行为。在适当的 时候，我们会改进内核并且和公开源码组织共享这些改动。 相关工作 和其它的大型分布式文件系统，比如 AFS[5]类似，GFS 提供了一个与位置无关的名字空间，这使得数据 可以为了负载均衡或者灾难冗余等目的在不同位置透明的迁移。不同于 AFS 的是，GFS 把文件分布存储到不 同的服务器上，这种方式更类似 Xfs[1]和 Swift[3]，这是为了提高整体性能以及灾难冗余的能力。 由于磁盘相对来说比较便宜，并且复制的方式比 RAID[9]方法简单的多，GFS 目前只使用复制的方式来 进行冗余，因此要比 xFS 或者 Swift 占用更多的裸存储空间(alex 注:Raw storage，裸盘的空间)。 与 AFS、xFS、Frangipani[12]以及 Intermezzo[6]等文件系统不同的是，GFS 并没有在文件系统层面提供 任何 Cache 机制。我们主要的工作在单个应用程序执行的时候几乎不会重复读取数据，因为它们的工作方式 要么是流式的读取一个大型的数据集，要么是在大型的数据集中随机 Seek 到某个位置，之后每次读取少量的 数据。 某些分布式文件系统，比如 Frangipani、xFS、Minnesota’s GFS[11]、GPFS[10]，去掉了中心服务器，只 依赖于分布式算法来保证一致性和可管理性。我们选择了中心服务器的方法，目的是为了简化设计，增加可 靠性，能够灵活扩展。特别值得一提的是，由于处于中心位置的 Master 服务器保存有几乎所有的 Chunk 相关 信息，并且控制着 Chunk 的所有变更，因此，它极大地简化了原本非常复杂的 Chunk 分配和复制策略的实现 方法。我们通过减少 Master 服务器保存的状态信息的数量，以及将 Master 服务器的状态复制到其它节点来保证系统的灾难冗余能力。扩展能力和高可用性(对于读取)目前是通过我们的影子 Master 服务器机制来保证 的。对 Master 服务器状态更改是通过预写日志的方式实现持久化。为此，我们可以调整为使用类似 Harp[7]中的 primary-copy 方案，从而提供比我们现在的方案更严格的一致性保证。 我们解决了一个难题，这个难题类似 Lustre[8]在如何在有大量客户端时保障系统整体性能遇到的问题。不过，我们通过只关注我们的应用程序的需求，而不是提供一个兼容 POSIX 的文件系统，从而达到了简化问 题的目的。此外，GFS 设计预期是使用大量的不可靠节点组建集群，因此，灾难冗余方案是我们设计的核心。 GFS 很类似 NASD 架构[4]。NASD 架构是基于网络磁盘的，而 GFS 使用的是普通计算机作为 Chunk 服 务器，就像 NASD 原形中方案一样。所不同的是，我们的 Chunk 服务器采用惰性分配固定大小的 Chunk 的方 式，而不是分配变长的对象存储空间。此外，GFS 实现了诸如重新负载均衡、复制、恢复机制等等在生产环境中需要的特性。 不同于与 Minnesota’s GFS 和 NASD，我们并不改变存储设备的 Model。我们只关注用普通的设备来解决非常复杂的分布式系统日常的数据处理。 我们通过原子的记录追加操作实现了生产者-消费者队列，这个问题类似 River[2]中的分布式队列。River使用的是跨主机的、基于内存的分布式队列，为了实现这个队列，必须仔细控制数据流;而 GFS 采用可以被 生产者并发追加记录的持久化的文件的方式实现。River 模式支持 m-到-n 的分布式队列，但是缺少由持久化 存储提供的容错机制，GFS 只支持 m-到-1 的队列。多个消费者可以同时读取一个文件，但是它们输入流的区 间必须是对齐的。 结束语 Google 文件系统展示了一个使用普通硬件支持大规模数据处理的系统的特质。虽然一些设计要点都是针 对我们的特殊的需要定制的，但是还是有很多特性适用于类似规模的和成本的数据处理任务。 首先，我们根据我们当前的和可预期的将来的应用规模和技术环境来评估传统的文件系统的特性。我们 的评估结果将我们引导到一个使用完全不同于传统的设计思路上。根据我们的设计思路，我们认为组件失效 是常态而不是异常，针对采用追加方式(有可能是并发追加)写入、然后再读取(通常序列化读取)的大文 件进行优化，以及扩展标准文件系统接口、放松接口限制来改进整个系统。 我们系统通过持续监控，复制关键数据，快速和自动恢复提供灾难冗余。Chunk 复制使得我们可以对 Chunk 服务器的失效进行容错。高频率的组件失效要求系统具备在线修复机制，能够周期性的、透明的修复 损坏的数据，也能够第一时间重新建立丢失的副本。此外，我们使用 Checksum 在磁盘或者 IDE 子系统级别 检测数据损坏，在这样磁盘数量惊人的大系统中，损坏率是相当高的。 我们的设计保证了在有大量的并发读写操作时能够提供很高的合计吞吐量。我们通过分离控制流和数据 流来实现这个目标，控制流在 Master 服务器处理，而数据流在 Chunk 服务器和客户端处理。当一般的操作涉 及到 Master 服务器时，由于 GFS 选择的 Chunk 尺寸较大(alex 注:从而减小了元数据的大小)，以及通过 Chunk Lease 将控制权限移交给主副本，这些措施将 Master 服务器的负担降到最低。这使得一个简单、中心的 Master不会成为成为瓶颈。我们相信我们对网络协议栈的优化可以提升当前对于每客户端的写入吞吐量限制。 GFS 成功的实现了我们对存储的需求，在 Google 内部，无论是作为研究和开发的存储平台，还是作为 生产系统的数据处理平台，都得到了广泛的应用。它是我们持续创新和处理整个 WEB 范围内的难题的一个重要工具。","raw":null,"content":null,"categories":[{"name":"paper","slug":"paper","permalink":"https://freehubs.github.io/categories/paper/"}],"tags":[{"name":"paper","slug":"paper","permalink":"https://freehubs.github.io/tags/paper/"}]},{"title":"Hive事务-翻译自官方文档","slug":"Hive事务-翻译自官方文档","date":"2017-12-13T16:34:17.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/12/13/Hive事务-翻译自官方文档/","link":"","permalink":"https://freehubs.github.io/2017/12/13/Hive事务-翻译自官方文档/","excerpt":"\n            ACID简介\n          \nACID代表数据库事务的四个特性:\n\n原子性（Atomicity）:一个事务是一个不可再分割的工作单位，事务中的所有操作要么都发生，要么都不发生。\n一致性（Consistency）:事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。\n隔离性（Isolation）:多个事务并发访问，事务之间是隔离的，一个事务不影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操作相同的数据时，每个事务都有各自完整的数据空间。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改后的状态，事务不会查看到中间状态的数据。事务之间的相应影响，分别为：脏读、不可重复读、幻读、丢失更新。\n持久性（Durability）:意味着在事务完成以后，该事务锁对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。\n\n在Hive0.13中添加事务之后，在分区级别上提供了原子性、一致性和持久性。可以通过打开可用的锁定机制(ZooKeeper或内存)来提供隔离。现在可以在行级别上提供完整的ACID语义，这样一个应用程序可以添加行，而另一个应用程序可以在相同的分区上读取，而不会相互干扰。","text":"ACID简介 ACID代表数据库事务的四个特性: 原子性（Atomicity）:一个事务是一个不可再分割的工作单位，事务中的所有操作要么都发生，要么都不发生。 一致性（Consistency）:事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。 隔离性（Isolation）:多个事务并发访问，事务之间是隔离的，一个事务不影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操作相同的数据时，每个事务都有各自完整的数据空间。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改后的状态，事务不会查看到中间状态的数据。事务之间的相应影响，分别为：脏读、不可重复读、幻读、丢失更新。 持久性（Durability）:意味着在事务完成以后，该事务锁对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 在Hive0.13中添加事务之后，在分区级别上提供了原子性、一致性和持久性。可以通过打开可用的锁定机制(ZooKeeper或内存)来提供隔离。现在可以在行级别上提供完整的ACID语义，这样一个应用程序可以添加行，而另一个应用程序可以在相同的分区上读取，而不会相互干扰。使用ACID语义的事务被添加到Hive中，以解决以下用例: 流数据的接入。许多用户都使用 Apache Flume, Apache Storm, or Apache Kafka 将流式数据导入Hadoop集群。 这些工具都是每秒百万行级的数据写入，而Hive只能每十五分钟到一个小时添加一次分区。快速的增加分区会对表中的分区数量形成压力。当然可以事先创建好分区再将数据导入，但这样会引起脏读，而且目录下生成的小文件会对namenode造成很大的压力。而新特性可以很好的解决上述问题 维度表的缓慢变化：在典型的星型架构数据仓库中，维度表随时间慢慢变化。例如，零售商将会打开新的商店，这些商店需要被添加到商店的表中，或者现有的商店可能会改变它的平方英尺或其他一些被跟踪的特性。这些更改会导致插入单个记录或更新记录(取决于所选择的策略)。Hive从0.14开始支持。 数据更新。从Hive 0.14开始，可以 INSERT, UPDATE, 和 DELETE。 使用SQL MERGE语句进行批量更新。 事务限制 BEGIN, COMMIT, and ROLLBACK还不支持。所有操作都是自动提交的。该计划将在未来的版本中提供支持。 现目前只支持ORC文件格式。已经构建了这样的功能，可以通过任何存储格式来使用事务，以确定更新或删除如何应用于基本记录(基本上，具有显式或隐式行id)，但到目前为止，集成工作还只是用于ORC。 事务默认为关闭的。 表必须要分桶才能支持事务。因为外部表不受分桶的控制，因而外部表并不支持事务。 从一个 non_ACID 表读写 ACID 表 是不允许的。事务管理器必须设置为：org.apache.hadoop.hive.ql.lockmgr.DbTxnManager 。 目前只支持快照级别的隔离。 现有的ZooKeeper和内存中的锁管理器与事务不兼容。 ACID表不支持使用ALTER TABLE的模式更改。 使用 ORACLE 作为元数据库，”datanucleus.connectionPoolingType=BONECP” 可能会出现：”No such lock..” 和 “No such transaction…”等错误。请设置为：”datanucleus.connectionPoolingType=DBCP” 。 事务表不支持 ：LOAD DATA… 语法。 流 APIs Hive 提供数据 流式插入和流式更新的 APIs: Hive HCatalog Streaming API HCatalog Streaming Mutation API (Hive 2.0.0 及以上可用) 语法修改 从Hive 0.14. 开始，INSERT…VALUES, UPDATE, and DELETE 已经添加进 SQL 语法。几个新命令已经添加进 Hive 的 DDL 支持 ACID 和 事务, 并修改一些已经存在的 DDL 。 新命令： SHOW TRANSACTIONS SHOW COMPACTIONS ABORT TRANSACTIONS 修改的命令： SHOW LOCKS :提供与事务相关的新锁的信息。如果正在使用 ZooKeeper 或者内存锁管理，命令的输出将有不同。 ALTER TABLE :添加新功能，请求表或分区的压缩。 一般来说，用户不需要请求压缩，因为系统将检测到对它们的需求并启动压缩。 然而，如果对一个表关闭了压缩，或者用户希望在系统不选择的时候压缩表, ALTER TABLE 可用于启动压缩。为了观察压缩的进度，用户可以使用 SHOW COMPACTIONS 。 基础设计 HDFS 不支持对文件进行就地修改。也不提供读的一致性，并且当有数据追加到文件，HDFS 不对读数据的用户提供一致性的。为了在 HDFS 上提供这些特性，我们遵循了其他数据仓库工具中使用的标准方法。 表或分区的数据存储在一组 base 文件中。 新的记录、更新和删除存储在 delta 文件中。每个改变表或分区的事务产生一组新的 delta 文件 。读的时候，合并 base 和 delta 文件, 应用所有的更新和删除。 Base 和 Delta 目录一个分区或一个非分区表的所有文件都在同一个目录下。有更新的时候，任何 ACID 的分区（或非分区表）都有一个 base 文件目录，和一个 delta 文件目录。 1234567hive&gt; dfs -ls -R /user/hive/warehouse/t;drwxr-xr-x - ekoifman staff 0 2016-06-09 17:03 /user/hive/warehouse/t/base_0000022-rw-r--r-- 1 ekoifman staff 602 2016-06-09 17:03 /user/hive/warehouse/t/base_0000022/bucket_00000drwxr-xr-x - ekoifman staff 0 2016-06-09 17:06 /user/hive/warehouse/t/delta_0000023_0000023_0000-rw-r--r-- 1 ekoifman staff 611 2016-06-09 17:06 /user/hive/warehouse/t/delta_0000023_0000023_0000/bucket_00000drwxr-xr-x - ekoifman staff 0 2016-06-09 17:07 /user/hive/warehouse/t/delta_0000024_0000024_0000-rw-r--r-- 1 ekoifman staff 610 2016-06-09 17:07 /user/hive/warehouse/t/delta_0000024_0000024_0000/bucket_00000 合并合并是一组运行在 Metastore中支持 ACID 系统的后台程序。包含 Initiator, Worker, Cleaner, AcidHouseKeeperServiceis 和一些其他的。 Delta 文件合并随着修改的操作，越来越多的delta文件被创建，需要合并以保持足够的性能。有两种类型的合并，minor和major。 Minor 合并 ：在每一个 bucket ，将一组已经存在的 delta 文件合并重写到一个单独的 delta 文件中。 Major 合并 ：在每一个 bucket ，将一个或多个 delta 文件和 bucket 的 base 文件合并重写到一个新的 base 文件中. Major 合并效率高但花销大。 所有的合并都在后台完成，并且不妨碍对数据当前的读和写。 合并完所有的旧文件之后，就删除掉这些旧文件。 Initiator 初始化器这个模块负责发现哪些表或分区应该被合并。 通过设置：hive.compactor.initiator.on 开启。每个合并任务处理一个分区 (或一个非分区表). 如果连续合并失败次数超过 hive.compactor.initiator.failed.compacts.threshold 设定的值，该分区的自动合并调度将会被停止。 Worker 工作执行器每个 worker 处理一个单独的合并任务. 合并是 MapReduce job，名字是: -compactor-... 每一个worker 提交 job 到集群上 (通过定义的 hive.compactor.job.queue) 并等着任务完成。hive.compactor.worker.threads 决定了每个 Metastore 中 Workers 的数量。Hive 仓库中的 Workers 的总数决定了当前合并任务的最大值。 Cleaner 清除器该程序的职责：删除合并后不再需要的 delta 文件. AcidHouseKeeperService ACID管家服务寻找在 hive.txn.timeout 时间内没有心跳的事务，并将其终止。该系统假定发起事务的客户机停止了心跳，而锁定的资源应该被释放。 SHOW COMPACTIONS 查看合并这个命令显示目前正在运行的合并信息，和最近的合并历史 (配置的时间范围内)。 从 HIV-12353 开始支持历史显示。 事务／锁 管理器添加了一个名为“事务管理器”的新逻辑实体，它包含了以前的“数据库/表/分区锁管理器”概念。(hive.lock.manager with default of org.apache.hadoop.hive.ql.lockmgr.zookeeper.ZooKeeperHiveLockManager). 事务管理器现在还负责管理事务锁。默认的 DummyTxnManager 模拟了老版本 Hive 的行为: 没有事务和使用 hive.lock.manager 属性用来为表，分区，数据库创建锁管理器。在 Hive metastore 中新添加的 DbTxnManager 管理所有的锁/事务和 DbLockManager (在服务器出现故障时，事务和锁是持久的). 这意味着在启用事务时，以前锁定ZooKeeper的行为不再存在。 从 lock 持有者和事务 initiators 到 metastore 的心跳连接，如果心跳超时，则这个锁或事务将被舍弃。 从hive 1.30起，DbLockManger 持续获取锁的周期可以通过 hive.lock.numretires 和 hive.lock.sleep.between.retries. 两个属性设置。如果DbLockManger 获取锁失败，过一段时间之后会进行重试。为了支持短查询同时不对metastore造成负担，DbLockManger 在每次重试后加倍等待时长。 注意：DbTxnManager 可以获取所有的表的锁，即便那些没有设置transactional=true属性的表。默认对一个非事务表的插入操会获取一个排他锁从而阻止其他的插入和读取。技术上正确的，但是这背离了hive之前的工作方式。为了向后兼容，可以设置hive.txn.strict.locking.mode 属性来使锁管理器在对非事务表的插入操作时，获取共享锁。保留之前的语义，还有一个好处就是能防止表在读取是被删除。而对于事务表，插入总是获取的共享锁。是因为这些表实现了MVCC的架构，在存储的底层实现了很强的读一致性（快照隔离的方式），甚至能应对并发的修改操作。 共享锁【S锁】:又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 排他锁【X锁】:又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。） 配置信息 为了开启hive的事务支持，以下是需要开启的最少的hive配置： 客户端： 1234hive.support.concurrency – truehive.enforce.bucketing – true (Not required as of Hive 2.0)hive.exec.dynamic.partition.mode – nonstricthive.txn.manager – org.apache.hadoop.hive.ql.lockmgr.DbTxnManager 服务端： (Metastore) 12hive.compactor.initiator.on – true (See table below for more details)hive.compactor.worker.threads – a positive number on at least one instance of the Thrift metastore service 详细配置信息请看：hive事务配置信息 表属性 如果表要使用 ACID ，则必须指定： &quot;transactional=true&quot; 。如果该表被设置为 ACID 表，则不能转换为非 ACID 表，设置 &quot;transactional&quot;=&quot;false&quot; 也是不行的。在 hive-site.xml 中必须设置：hive.txn.manager = org.apache.hadoop.hive.ql.lockmgr.DbTxnManager 如果需希望系统自动进行合并，则可以设置： &quot;NO_AUTO_COMPACTION&quot; ,也可以通过Alter Table/Partition Compact 语法来设置。 Example: Set compaction options in TBLPROPERTIES at table level1234567891011CREATE TABLE table_name ( id int, name string)CLUSTERED BY (id) INTO 2 BUCKETS STORED AS ORCTBLPROPERTIES (\"transactional\"=\"true\", \"compactor.mapreduce.map.memory.mb\"=\"2048\", -- specify compaction map job properties \"compactorthreshold.hive.compactor.delta.num.threshold\"=\"4\", -- trigger minor compaction if there are more than 4 delta directories \"compactorthreshold.hive.compactor.delta.pct.threshold\"=\"0.5\" -- trigger major compaction if the ratio of size of delta files to -- size of base files is greater than 50%); Example: Set compaction options in TBLPROPERTIES at request level1234ALTER TABLE table_name COMPACT 'minor' WITH OVERWRITE TBLPROPERTIES (\"compactor.mapreduce.map.memory.mb\"=\"3072\"); -- specify compaction map job propertiesALTER TABLE table_name COMPACT 'major' WITH OVERWRITE TBLPROPERTIES (\"tblprops.orc.compress.size\"=\"8192\"); -- change any other Hive table properties","raw":null,"content":null,"categories":[{"name":"hive","slug":"hive","permalink":"https://freehubs.github.io/categories/hive/"}],"tags":[{"name":"hive","slug":"hive","permalink":"https://freehubs.github.io/tags/hive/"}]},{"title":"GitHub使用指南","slug":"GitHub使用指南","date":"2017-12-13T10:38:05.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/12/13/GitHub使用指南/","link":"","permalink":"https://freehubs.github.io/2017/12/13/GitHub使用指南/","excerpt":"\n            前言\n          \n学习 GitHub 的使用规则，记录遇到的问题。\n            watch , star , fork 的含义\n          刚使用 GitHub 的时候，看到每一个项目页面右上角都有如下图所示的字样：","text":"前言 学习 GitHub 的使用规则，记录遇到的问题。 watch , star , fork 的含义 刚使用 GitHub 的时候，看到每一个项目页面右上角都有如下图所示的字样：点击 watch 按钮 会出现如下所示： watch watch 的功能是观察跟踪这个项目，如果项目有任何更新，如果选择了 watching 该项目，都会在邮箱中接收到相关的更新信息。 not watching 表示不关注这个项目的更新情况，但你被提及的时候也会发邮件通知。 ignoring 表示不接收任何通知。 如果你想持续跟进该项目的任何更新情况，则可以选择 watching 。 starstar 类似于社交软件中的关注。如果选择了 star ， 则可以在自己的 star 页面查看到曾经 star 过的项目。点击右上角自己的头像，选择 your stars ：然后就会看到曾经所有 star 过的项目：如果你只想关注这个项目，但不需要接收任何更新通知，也不需要对该项目进行操作，则可以选择 star ，在需要的时候可以快捷查看该项目。 forkfork 的目的是将该项目克隆到自己的 GitHub 中，自己可以对该项目进行编辑修改，在 fork 的时候会在该项目中新添一个分支，可以选择 pull-requests 对该项目进行修改后并提交。 如果你想参与维护这个项目，可以使用 fork 功能，并提交自己的代码（当然用自己的分支提交项目的时候，需要项目其他分支的人员审核）。刚开始不知道 fork 的功能，导致我将很多项目都 fork 下来，其实很没有必要。根据自己的实际需求选择就好。 查看都有哪些人进行了操作如果想要知道都有哪些人进行了这些操作呢？比如我想知道都有谁对这个项目进行了 star 操作，可以看见每个功能旁边都有一个数字，该数字表示对这个项目进行该操作的人数，点击该数字，就可以知道具体是哪些人进行了操作：","raw":null,"content":null,"categories":[{"name":"GitHub","slug":"GitHub","permalink":"https://freehubs.github.io/categories/GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://freehubs.github.io/tags/GitHub/"}]},{"title":"spark取样函数分析","slug":"Spark sample 取样函数","date":"2017-12-12T17:30:25.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/12/12/Spark sample 取样函数/","link":"","permalink":"https://freehubs.github.io/2017/12/12/Spark sample 取样函数/","excerpt":"\n\n            背景\n          \nSpark取样操作，无法获取随机样本的解决方案。Dataset中sample函数源码如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445/**  * Returns a new [[Dataset]] by sampling a fraction of rows, using a user-supplied seed.  *  * 通过使用用户提供的种子，通过抽样的方式返回一个新的[[Dataset]]。  *  * @param withReplacement Sample with replacement or not.  *                        如果withReplacement=true的话表示有放回的抽样，采用泊松抽样算法实现.  *                        如果withReplacement=false的话表示无放回的抽样，采用伯努利抽样算法实现.  * @param fraction        Fraction of rows to generate.  *                        每一行数据被取样的概率.服从二项分布.当withReplacement=true的时候fraction&gt;=0,当withReplacement=false的时候 0 &lt; fraction &lt; 1.  * @param seed            Seed for sampling.  *                        取样种子（与随机数生成有关）  * @note This is NOT guaranteed to provide exactly the fraction of the count  *       of the given [[Dataset]].  *       不能保证准确的按照给定的分数取样。（一般结果会在概率值*总数左右）  * @group typedrel  * @since 1.6.0  */def sample(withReplacement: Boolean, fraction: Double, seed: Long): Dataset[T] = &#123;  require(fraction &gt;= 0,    s\"Fraction must be nonnegative, but got $&#123;fraction&#125;\")  withTypedPlan &#123;    Sample(0.0, fraction, withReplacement, seed, logicalPlan)()  &#125;&#125;/**  * Returns a new [[Dataset]] by sampling a fraction of rows, using a random seed.  *  * 通过程序随机的种子，抽样返回新的DataSet  *  * @param withReplacement Sample with replacement or not.  *                        取样结果是否放回  * @param fraction        Fraction of rows to generate.  *                        每行数据被取样的概率  * @note This is NOT guaranteed to provide exactly the fraction of the total count  *       of the given [[Dataset]].  *       不能保证准确的按照给定的分数取样。（一般结果会在概率值*总数左右）  * @group typedrel  * @since 1.6.0  */def sample(withReplacement: Boolean, fraction: Double): Dataset[T] = &#123;  sample(withReplacement, fraction, Utils.random.nextLong)&#125;","text":"背景 Spark取样操作，无法获取随机样本的解决方案。Dataset中sample函数源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Returns a new [[Dataset]] by sampling a fraction of rows, using a user-supplied seed. * * 通过使用用户提供的种子，通过抽样的方式返回一个新的[[Dataset]]。 * * @param withReplacement Sample with replacement or not. * 如果withReplacement=true的话表示有放回的抽样，采用泊松抽样算法实现. * 如果withReplacement=false的话表示无放回的抽样，采用伯努利抽样算法实现. * @param fraction Fraction of rows to generate. * 每一行数据被取样的概率.服从二项分布.当withReplacement=true的时候fraction&gt;=0,当withReplacement=false的时候 0 &lt; fraction &lt; 1. * @param seed Seed for sampling. * 取样种子（与随机数生成有关） * @note This is NOT guaranteed to provide exactly the fraction of the count * of the given [[Dataset]]. * 不能保证准确的按照给定的分数取样。（一般结果会在概率值*总数左右） * @group typedrel * @since 1.6.0 */def sample(withReplacement: Boolean, fraction: Double, seed: Long): Dataset[T] = &#123; require(fraction &gt;= 0, s\"Fraction must be nonnegative, but got $&#123;fraction&#125;\") withTypedPlan &#123; Sample(0.0, fraction, withReplacement, seed, logicalPlan)() &#125;&#125;/** * Returns a new [[Dataset]] by sampling a fraction of rows, using a random seed. * * 通过程序随机的种子，抽样返回新的DataSet * * @param withReplacement Sample with replacement or not. * 取样结果是否放回 * @param fraction Fraction of rows to generate. * 每行数据被取样的概率 * @note This is NOT guaranteed to provide exactly the fraction of the total count * of the given [[Dataset]]. * 不能保证准确的按照给定的分数取样。（一般结果会在概率值*总数左右） * @group typedrel * @since 1.6.0 */def sample(withReplacement: Boolean, fraction: Double): Dataset[T] = &#123; sample(withReplacement, fraction, Utils.random.nextLong)&#125; 问题 结果数据的行数一般在（fraction*总数）左右。没有一个固定的值，如果需要得到固定行数的随机数据的话不建议采用该方法。 办法 获取随机取样的替代方法： 123456df.createOrReplaceTempView(\"test_sample\"); // 生成临时表df.sqlContext() // 添加随机数列，并根据其进行排序 .sql(\"select * ,rand() as random from test_sample order by random\") .limit(2) // 根据参数的fraction计算需要获取的取样结果 .drop(\"random\") // 删除掉添加的随机列 .show();","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"}]},{"title":"Hive报错集","slug":"Hive报错集","date":"2017-12-11T13:58:58.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/12/11/Hive报错集/","link":"","permalink":"https://freehubs.github.io/2017/12/11/Hive报错集/","excerpt":"\n            前言\n          \n针对一个老毛病：有些错误屡犯屡改，屡改屡犯，没有引起根本上的注意，或者没有从源头理解错误发生的底层原理，导致做很多无用功。\n总结历史，并从中吸取教训，减少无用功造成的时间浪费。特此将从目前遇到的 hive 问题全部记录在这里，搞清楚问题，自信向前。","text":"前言 针对一个老毛病：有些错误屡犯屡改，屡改屡犯，没有引起根本上的注意，或者没有从源头理解错误发生的底层原理，导致做很多无用功。 总结历史，并从中吸取教训，减少无用功造成的时间浪费。特此将从目前遇到的 hive 问题全部记录在这里，搞清楚问题，自信向前。 报错集 问题1：Error rolling back详情：Error rolling back: Can&#39;t call rollback when autocommit=true 解决方案：vim conf/hive-site.xml 不要加这个配置！！！！ 1234&lt;property&gt;&lt;name&gt;hive.in.test&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;","raw":null,"content":null,"categories":[{"name":"hive","slug":"hive","permalink":"https://freehubs.github.io/categories/hive/"}],"tags":[{"name":"hive","slug":"hive","permalink":"https://freehubs.github.io/tags/hive/"}]},{"title":"Hive锁介绍-翻译自官方文档","slug":"Hive锁介绍-翻译自官方文档","date":"2017-12-11T09:58:58.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/12/11/Hive锁介绍-翻译自官方文档/","link":"","permalink":"https://freehubs.github.io/2017/12/11/Hive锁介绍-翻译自官方文档/","excerpt":"在数据库中，并发性支持是必须的，而且它们的用例也很容易理解。至少，我们希望尽可能支持并发的读和写。添加一个机制来发现已获得的当前锁是很有用的。没有立即添加API来显式获取任何锁的需求，因此所有锁都是隐式获得的。以下锁定模式将在hive中定义(注意，不需要意图锁)。\n12共享(S)独占(X)\n顾名思义，可以同时获得多个共享锁，而X锁可以阻止所有其他锁。兼容性矩阵如下:对于某些操作，锁在本质上是分层的——例如，对于某些分区操作，表也被锁定(以确保在创建新分区时不能删除表)。","text":"在数据库中，并发性支持是必须的，而且它们的用例也很容易理解。至少，我们希望尽可能支持并发的读和写。添加一个机制来发现已获得的当前锁是很有用的。没有立即添加API来显式获取任何锁的需求，因此所有锁都是隐式获得的。以下锁定模式将在hive中定义(注意，不需要意图锁)。 12共享(S)独占(X) 顾名思义，可以同时获得多个共享锁，而X锁可以阻止所有其他锁。兼容性矩阵如下:对于某些操作，锁在本质上是分层的——例如，对于某些分区操作，表也被锁定(以确保在创建新分区时不能删除表)。锁定模式下获取的合理性如下: 对于非分区表，锁模式非常直观。读取表时，获取一个S锁，而所有其他操作(插入表、alter table等其他操作)获得一个X锁。 对于分区表，其思想如下: 在执行读操作时，获取表和相关分区的 ‘S’ 锁。对于所有其他操作，在分区上执行“X”锁。但是，如果更改只适用于较新的分区，则在表上获得“S”锁，而如果更改适用于所有分区，则在表上获得“X”锁。因此，旧分区可以被读取和写入，而新的分区则被转换为RCFile。每当一个分区被锁定在任何模式时，它的所有父级都被锁在“S”模式中。 基于此，为操作获得的锁如下: 为了避免死锁，这里提出了一个非常简单的方案。所有要锁定的对象都是按字母顺序排序的，然后获取所需的模式锁。请注意，在某些情况下，可能不知道对象列表——例如，在动态分区的情况下，正在修改的分区列表在编译时是未知的——因此，列表的生成是保守的。由于分区的数量可能不知道，所以应该将一个专用锁(但目前不是由于hive -3509 bug)放在表上，或者是已知的前缀。 将添加两个新的可配置参数来决定锁的重试次数和每次重试之间的等待时间。如果重试的次数真的很高，它会导致一个活锁。看看ZooKeeper，看看如何使用ZooKeeper api实现读写锁。请注意，锁请求将被拒绝，而不是等待。现有的锁将被释放，所有的锁将在重试间隔后重试。 上面列出的不会按照指定的方式工作，因为锁的等级性。 表T的“S”锁指定如下: 调用create()创建具有路径名的节点“/ warehouse/T/ read—”。这是协议后面使用的锁节点。确保设置顺序和临时标志。 在锁定节点上调用getChildren()，而无需设置观察标志。 如果有一个以“write -”开头的路径名的孩子，以及一个较低的序列数，那么这个锁就不能被获取。删除第一步中创建的节点并返回。 否则，锁就被授予了。 表T的“X”锁定如下: 调用create()创建具有路径名的节点“/ warehouse/T/ write—”。这是协议后面使用的锁节点。确保设置顺序和临时标志。 在锁定节点上调用getChildren()，而无需设置观察标志。 如果有一个以“读-”或“写-”开头的路径名的孩子，并以较低的序列号开始，就不能获得锁。删除第一步中创建的节点并返回。 否则，锁就被授予了。 默认的Hive行为不会更改，并发也不受支持。您可以通过将以下变量设置为false来关闭并发性: hive.support.concurrency. 您可以通过发出以下命令查看表中的锁: 1234SHOW LOCKS &lt;TABLE_NAME&gt;;SHOW LOCKS &lt;TABLE_NAME&gt; EXTENDED;SHOW LOCKS &lt;TABLE_NAME&gt; PARTITION (&lt;PARTITION_DESC&gt;);SHOW LOCKS &lt;TABLE_NAME&gt; PARTITION (&lt;PARTITION_DESC&gt;) EXTENDED; 点我了解Hive锁定的配置属性","raw":null,"content":null,"categories":[{"name":"hive","slug":"hive","permalink":"https://freehubs.github.io/categories/hive/"}],"tags":[{"name":"hive","slug":"hive","permalink":"https://freehubs.github.io/tags/hive/"}]},{"title":"Hexo + AppVeyor 持续集成","slug":"Hexo 优化-使用 AppVeyor 进行部署","date":"2017-12-07T11:30:06.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/12/07/Hexo 优化-使用 AppVeyor 进行部署/","link":"","permalink":"https://freehubs.github.io/2017/12/07/Hexo 优化-使用 AppVeyor 进行部署/","excerpt":"\n            前言\n          \n今天查看 Spark 源码的时候，无意发现了 AppVeyor ，才知道 持续集成（Continuous Integration，简称CI）,简单理解为可以自动化构建项目的工具。在 Spark 中，SparkR 的项目使用了 AppVeyor 持续集成工具。\n看到网络上一些大佬用 AppVeyor 联合 Hexo，作为博客代码的部署工具，一方面可以使部署代码更加简单（全自动化，虽然之前也只有 hexo -clean ,hexo -g ,hexo -d 三步，但现在完全在后台自动部署），另一方面也可以解决博客源码多电脑书写的局限性（之前只能在一台电脑上进行博客的创作，面临着项目备份的问题），现在将项目完全托管在 GitHub上，无需担心电脑换了，或是磁盘损坏造成的数据丢失，也无需使用云备份工具费时费力的维护项目。\n            核心步骤\n          \n新建代码仓库首先我们先确定，将项目托管在 GitHub 上，这里有两种方案，一种是在存放博客静态代码的仓库（如：xxx.github.io）中新添加分支;另一种则是新建一个仓库用于存放项目。我这里使用的第二种方式，新建了一个仓库：hexo-github-source 。","text":"前言 今天查看 Spark 源码的时候，无意发现了 AppVeyor ，才知道 持续集成（Continuous Integration，简称CI）,简单理解为可以自动化构建项目的工具。在 Spark 中，SparkR 的项目使用了 AppVeyor 持续集成工具。 看到网络上一些大佬用 AppVeyor 联合 Hexo，作为博客代码的部署工具，一方面可以使部署代码更加简单（全自动化，虽然之前也只有 hexo -clean ,hexo -g ,hexo -d 三步，但现在完全在后台自动部署），另一方面也可以解决博客源码多电脑书写的局限性（之前只能在一台电脑上进行博客的创作，面临着项目备份的问题），现在将项目完全托管在 GitHub上，无需担心电脑换了，或是磁盘损坏造成的数据丢失，也无需使用云备份工具费时费力的维护项目。 核心步骤 新建代码仓库首先我们先确定，将项目托管在 GitHub 上，这里有两种方案，一种是在存放博客静态代码的仓库（如：xxx.github.io）中新添加分支;另一种则是新建一个仓库用于存放项目。我这里使用的第二种方式，新建了一个仓库：hexo-github-source 。 配置 AppVeyor点我进入AppVeyor官网添加你的GitHub项目，这里要注意添加的是你的Source Repo（hexo-github-source），而不是Content Repo（xxx.github.io.git）。 配置 appveyor.yml回到 GitHub 页面，在新建的 hexo-github-source 仓库的根目录下面新建 appveyor.yml 文件。配置如下： 1234567891011121314151617181920212223242526272829303132clone_depth: 5 environment: nodejs_version: &quot;6&quot; access_token: secure: [这里需要改为自己的密匙，获取方法见下] install: - ps: Install-Product node $env:nodejs_version - node --version - npm --version - npm install - npm install hexo-cli -g build_script: - hexo generate artifacts: - path: public on_success: - git config --global credential.helper store - ps: Add-Content &quot;$env:USERPROFILE\\.git-credentials&quot; &quot;https://$($env:access_token):x-oauth-basic@github.com`n&quot; - git config --global user.email &quot;%GIT_USER_EMAIL%&quot; - git config --global user.name &quot;%GIT_USER_NAME%&quot; - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site - cd %TEMP%\\static-site - del * /f /q - for /d %%p IN (*) do rmdir &quot;%%p&quot; /s /q - SETLOCAL EnableDelayedExpansion &amp; robocopy &quot;%APPVEYOR_BUILD_FOLDER%\\public&quot; &quot;%TEMP%\\static-site&quot; /e &amp; IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1)) - git add -A - if &quot;%APPVEYOR_REPO_BRANCH%&quot;==&quot;master&quot; if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m &quot;Update Static Site&quot; &amp;&amp; git push origin %TARGET_BRANCH% &amp;&amp; appveyor AddMessage &quot;Static Site Updated&quot;) 以上配置，只有 access_token 不一样（其余的都可以直接用），这个需要去 GitHub 生成，戳我了解怎么获取。在 GitHub 拿到 access_token 之后，还需要到 AppVeyor 加密页面 进行加密，最终得到类似这样一串东西MvjDPMTBE+hD5iZPRY2mIUuTl8quMhcEfhYe1rOti5g2GaTPQSDU/Mliff7NainM ，将该密匙 写入 appveyor.yml 中。 配置 Appveyor 环境变量回到 刚才的 Appveyor 页面，进入 settings 页面，选择 Environment ，点击 Add variable 添加环境变量，配置如下四个变量： GIT_USER_EMAIL ：GitHub邮箱 GIT_USER_NAME ：GitHub用户名 STATIC_SITE_REPO ：Content Repo地址（https://github.com/xxx/xxx.github.io.git） TARGET_BRANCH ：保留默认的 master如下图所示： 测试与问题 经过一番折腾，终于越过无数的坑之后，完美的运行成功。坑一：push 到仓库时提示空文件夹提示 themes/next 为空文件夹，提交失败（ GitHub 无法提交空文件夹），可问题是明明不是空文件啊，为什么会判定为空的？原来我这是 next 主题直接 git clone 下来的，因而在 next 文件夹的根目录下面有一个 .git 的隐藏文件，就是这导致的无法提交。既然找到了原因，那就好整了，直接删掉，完美解决问题。坑二： AppVeyor 提示 Bug将项目 push 到新建的仓库中，查看 AppVeyor 的运行日志，看是否提示 Bug ，我在测试的过程中很不幸，就出现过问题，原因是 hexo 的一个插件目录过长，导致程序失败，解决方法是不用把 hexo 文件夹备份到仓库中，因而完美的解决（避开）问题。备份到仓库的项目结构如下：（多余的都可去掉，仅保留核心）","raw":null,"content":null,"categories":[{"name":"hexo","slug":"hexo","permalink":"https://freehubs.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://freehubs.github.io/tags/hexo/"},{"name":"appveyor","slug":"appveyor","permalink":"https://freehubs.github.io/tags/appveyor/"}]},{"title":"Hive事务管理","slug":"Hive事务管理","date":"2017-12-01T11:30:06.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/12/01/Hive事务管理/","link":"","permalink":"https://freehubs.github.io/2017/12/01/Hive事务管理/","excerpt":"\n            简介\n          \nHive作为Hadoop家族历史最悠久的组件之一，一直以其优秀的兼容性支持和稳定性而著称，越来越多的企业将业务数据从传统数据库迁移至Hadoop平台，并通过Hive来进行数据分析。但是我们在迁移的过程中难免会碰到如何将传统数据库的功能也迁移到Hadoop的问题，比如说事务。事务作为传统数据库很重要的一个功能，在Hive中是如何实现的呢？Hive的实现有什么不一样的地方呢？我们将传统数据库的应用迁移到Hive如果有事务相关的场景我们该如何去转换并要注意什么问题呢？\n本文会通过很多真实测试案例来比较Hive与传统数据库事务的区别，并在文末给出一些在Hive平台上使用事务相关的功能时的指导和建议。\n            ACID与实现原理\n          为了方便解释和说明后面的一些问题，这里重提传统数据库事务相关的概念，以下内容来源于网络。","text":"简介 Hive作为Hadoop家族历史最悠久的组件之一，一直以其优秀的兼容性支持和稳定性而著称，越来越多的企业将业务数据从传统数据库迁移至Hadoop平台，并通过Hive来进行数据分析。但是我们在迁移的过程中难免会碰到如何将传统数据库的功能也迁移到Hadoop的问题，比如说事务。事务作为传统数据库很重要的一个功能，在Hive中是如何实现的呢？Hive的实现有什么不一样的地方呢？我们将传统数据库的应用迁移到Hive如果有事务相关的场景我们该如何去转换并要注意什么问题呢？ 本文会通过很多真实测试案例来比较Hive与传统数据库事务的区别，并在文末给出一些在Hive平台上使用事务相关的功能时的指导和建议。 ACID与实现原理 为了方便解释和说明后面的一些问题，这里重提传统数据库事务相关的概念，以下内容来源于网络。 ACID说明何为事务？就是一组单元化操作，这些操作要么都执行，要么都不执行，是一个不可分割的工作单位。 事务（transaction）所应该具有的四个要素：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。这四个基本要素通常称为ACID特性。 原子性（Atomicity）:一个事务是一个不可再分割的工作单位，事务中的所有操作要么都发生，要么都不发生。 一致性（Consistency）:事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。 隔离性（Isolation）:多个事务并发访问，事务之间是隔离的，一个事务不影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操作相同的数据时，每个事务都有各自完整的数据空间。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改后的状态，事务不会查看到中间状态的数据。事务之间的相应影响，分别为：脏读、不可重复读、幻读、丢失更新。 持久性（Durability）:意味着在事务完成以后，该事务锁对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 ACID的实现原理事务可以保证ACID原则的操作，那么事务是如何保证这些原则的？解决ACID问题的两大技术点是： 预写日志（Write-ahead logging）保证原子性和持久性 锁（locking）保证隔离性 这里并没有提到一致性，是因为一致性是应用相关的话题，它的定义一个由业务系统来定义，什么样的状态才是一致？而实现一致性的代码通常在业务逻辑的代码中得以体现。 注：锁是指在并发环境中通过读写锁来保证操作的互斥性。根据隔离程度不同，锁的运用也不同。 测试环境 操作系统 CentOS 6.5 JDK jdk1.7.0_67 CDH 5.9 Hadoop 2.6.0 Hive 1.1.0 Hive的ACID测试 Hive中的锁（不开启事务）Hive中定义了两种锁的模式：共享锁（S）和排它锁（X），顾名思义，多个共享锁(S)可以同时获取，但是排它锁(X)会阻塞其它所有锁。在本次测试中，CDH5.9的Concurrency参数是默认开启的（hive.support.concurrency=true），以下分别对开启Concurrency和关闭进行相关测试。 首先在测试之前，创建一个普通的hive表： 1create table test_notransaction(user_id Int,name String); 向test_transaction表中插入测试数据： 1insert into test_notransaction values(1,'peach1'),(2,'peach2'),(3, 'peach3'),(4, 'peach4'); 查看插入的数据： 开启Concurrency1、对catalog_sales表进行并发select操作 执行的sql语句：select count(*) from catalog_sales; 执行单条sql查询时，获取一个共享锁（S），sql语句正常执行 同时执行两条sql查询是，获取两个共享锁，并且sql语句均正常执行 分析：由此对比可得出hive在执行sql查询时获取Share锁，在并发的情况下可获取多个共享锁。 2、对test表进行并发Insert操作 创建表： 1create table test(name string, id int); 执行sql语句： 12insert into test values('test11aaa1',1252); insert into test values('test1',52); 执行单条insert语句时，获取一个X锁，sql语句正常执行 同时执行两条insert语句时，只能获取一个test表X锁，第一条insert语句正常执行，第二条insert语句处于等待状态，在第一条insert语句释放test表的X锁，第二条sql语句正常执行. 分析：由此对比可得出hive在执行insert操作时，只能获取一个X锁且锁不能共享，只能在sql执行完成释放锁后，后续sql方可继续执行。 3、对test表执行select的同时执行insert操作 执行sql语句： 12select count(*) from test; insert into test values(&quot;test123&quot;,123); 步骤： 1) 执行select语句，在select未运行完时，在新的窗口同时执行insert语句观察两条sql执行情况，select语句正常执行，insert语句处于等待状态。 2) 此时查看test表锁状态 在步骤1的执行过程中，获取到test表的锁为共享锁（S） 3) 在select语句执行完成后，观察insert语句开始正常执行，此时获取test表锁为排它锁（X）。注意：在select语句执行完成后，大概过40s左右insert语句才正常执行，这是由hive.lock.sleep.between.retries参数控制，默认60 分析： 由上述操作可得出，hive中一个表只能有一个排它锁(X)且锁不能共享，在获取排它锁时，表上不能有其它锁包括共享锁(S)，只有在表上所有的锁都释放后，insert操作才能继续，否则处于等待状态。 对注意部分进行参数调整，将hive.lock.sleep.between.retries设置为10s，再次进行测试发现，在select语句执行完成后，大概过6s左右insert语句开始执行,通过两次测试发现，等待时间均在10s以内，由此可以得出此参数影响sql操作获取锁的间隔（在未获取到锁的情况下），如果此时未到获取锁触发周期，执行其它sql则，该sql会优于等待的sql执行。 4、对test表执行insert的同时执行select操作 执行sql语句： 12insert into test values(&quot;test123&quot;,123); select count(*) from test; 操作步骤： 1) 在命令窗口执行insert语句，在insert操作未执行完成时，在新的命令窗口执行select语句，观察两个窗口的sql执行情况，insert语句正常执行，select语句处于等待状态。 2) 此时查看test表锁状态，只有insert操作获取的排它锁（X） 3) 在insert语句执行完成后，观察select语句开始正常执行，此时查看test表锁状态为共享锁（S），之前的insert操作获取的排它锁（X）已被释放 分析：在test表锁状态为排它锁(X)时，所有的操作均被阻塞处于等待状态，只有在排它锁(X)释放其它操作可继续进行。 5、测试update和delete修改test表数据 sql语句： 12update test set name=&apos;aaaa&apos; where id=1252; delete test set name=&apos;bbbb&apos; where id=123; 1) 表中数据，更新前 2) 在beeline窗口执行update操作 执行update操作报错，异常提示“Attempt to do update or delete using transaction manager that does not support these operations”，在非事务模式下不支持update 和 delete。 关闭Concurrency1、执行insert操作的同时执行select操作 sql语句： 12insert into test_notransaction values(1,&apos;peach1&apos;),(2,&apos;peach2&apos;),(3, &apos;peach3&apos;),(4, &apos;peach4&apos;); select count(*) from test_notransaction; 操作sql前，查看表数据 查看test_notransaction表获取情况，show locks; hive在未开启concurrency 的情况下,show locks不能正常获取表的锁，同时对同一张表执行insert和select操作时并发执行，获取数据取决于sql执行速度，因此在select 的时候未获取到插入数据。 2、执行select操作的同时执行insert操作 sql语句： 12select count(*) from test_notransaction; insert into test_notransaction values(1,&apos;peach1&apos;),(2,&apos;peach2&apos;),(3, &apos;peach3&apos;),(4, &apos;peach4&apos;); 在执行select的同时执行insert操作，操作可以同时并行操作，未产生阻塞等待的过程。 3、同时执行多条insert操作 sql语句： 12insert into test_notransaction values(1,&apos;peach1&apos;),(2,&apos;peach2&apos;),(3, &apos;peach3&apos;),(4, &apos;peach4&apos;); insert into test_notransaction values(1,&apos;peach1&apos;),(2,&apos;peach2&apos;),(3, &apos;peach3&apos;),(4, &apos;peach4&apos;); 同时执行insert操作时，可同时执行未产生阻塞等待的过程。 4、执行update操作，将表中user_id为2的用户名修改为peach22 sql语句： 1update test_notransaction set name=&apos;peach22&apos; where user_id=2; 执行update操作，执行结果如下： 在未配置hive的Transaction和ACID时，不支持update操作。 5、执行delete操作，将表中user_id为1信息删除 sql语句： 1delete from test_notransaction where user_id=1; 执行delete操作，执行结果如下： hive未配置Transaction和ACID，不支持delete操作。 6、查看表获取锁类型 1show locks; 无法正常执行； Hive的事务Hive的事务配置Hive从0.13开始加入了事务支持，在行级别提供完整的ACID特性，Hive在0.14时加入了对INSERT…VALUES,UPDATE,and DELETE的支持。对于在Hive中使用ACID和Transactions，主要有以下限制： 不支持BEGIN,COMMIT和ROLLBACK 只支持ORC文件格式 表必须分桶 不允许从一个非ACID连接写入/读取ACID表 为了使Hive支持事务操作，需将以下参数加入到hive-site.xml文件中。 123456789101112131415161718192021222324&lt;property&gt;&lt;name&gt;hive.support.concurrency&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hive.enforce.bucketing&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hive.exec.dynamic.partition.mode&lt;/name&gt;&lt;value&gt;nonstrict&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hive.txn.manager&lt;/name&gt;&lt;value&gt;org.apache.hadoop.hive.ql.lockmgr.DbTxnManager&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hive.compactor.initiator.on&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hive.compactor.worker.threads &lt;/name&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt; 可以在Cloudera Manager进行以下配置： 为了让beeline支持还需要配置： Hive事务测试环境准备1、创建一个支持ACID的表 建表语句： 123create table test_trancaction (user_id Int,name String) clustered by (user_id) into 3 buckets stored as orc TBLPROPERTIES ('transactional'='true'); 将表名修改为test_transaction 1alter table test_trancaction rename to test_transaction; 2、准备测试数据，向数据库中插入数据 1insert into test_transaction values(1,'peach'),(2,'peach2'),(3,'peach3'),(4,'peach4'),(5,'peach5'); 用例测试1、执行update操作，将user_id的name修改为peach_update sql语句： 1update test_transaction set name='peach_update' where user_id=1; 执行修改操作，查看表获取锁类型 数据修改成功，且不影响其它数据。 2、同时修改同一条数据，将user_id为1的用户名字修改为peach，另一条sql将名字修改为peach_ sql语句： 12update test_transaction set name='peach' where user_id=1;update test_transaction set name='peach_' where user_id=1; sql执行顺序为peach，其次为peach_ 此时查看表获取到的锁 通过获取到锁分析，在同时修改同一条数据时，优先执行的sql获取到了SHARED_WRITE，而后执行的sql获取锁的状态为WAITING状态，表示还未获取到SHARED_WRITE锁，等待第一条sql执行结束后方可获取到锁对数据进行操作。 通过上不执行操作分析，数据user_id为1的用户名字应被修改为peach_ 3、同时修改不同数据，修改id为2的name为peachtest，修改id为3的name为peach_test sql语句： 12update test_transaction set name='peachtest' where user_id=2; update test_transaction set name='peach_test' where user_id=3; sql执行顺序为peachtest，其次为peach_test 此时查看表获取到的锁 通过sql操作获取锁分析，在同时修改不同数据时，优先执行的sql获取到了SHARED_WRITE，而后执行的sql获取锁的状态为WAITING状态，表示还未获取到SHARED_WRITE锁，等待第一条sql执行结束后方可获取到锁对数据进行操作。 4、执行select操作的同时执行insert操作 sql语句： 12select count(*) from test_transaction; insert into test_transaction values(3,'peach3'); 步骤： 先执行select操作，再执行insert操作，执行完成后查看表获取到的锁 由于select和insert操作均获取的是SHARED_READ锁，读锁为并行，所以select查询和insert同时执行，互不影响。 5、update同一条数据的同时select该条数据 sql语句： 12update test_transaction set name='peach_update' where user_id=1; select * from test_transaction where user_id=1; 步骤： 先执行update操作，再执行select操作，获取此时表获取到的锁 通过获取锁的情况分析， 在update操作时，获取到SHARED_WRITE锁，执行select操作时获取到SHARED_READ锁，在进行修改数据时未阻塞select查询操作，update未执行完成时，select查询到的数据为未修改的数据。 6、执行delete操作，将user_id为3的数据删除 sql语句： 1delete from test_transaction where user_id=3; 步骤： 执行delete操作，获取此时表获取到的锁 删除操作获取到的是SHARED_WRITE锁 执行成功后数据 7、同时delete同一条数据 sql语句： 12delete from test_transaction where user_id=3;delete from test_transaction where user_id=3; 步骤： 按顺序执行两条delete操作，查看此时表获取到的锁： 通过查看delete操作获取到的锁，优先执行的操作获取到SHARED_WRITE锁，后执行的delete操作未获取到SHARED_WRITE锁，处于WAITING状态。 执行删除后结果 8、同时delete两条不同的数据 sql语句： 12delete from test_transaction where user_id=1; delete from test_transaction where user_id=5; 步骤： 按顺序执行两条delete操作，查看此时表获取到的锁： 通过查看delete操作获取到的锁，优先执行的操作获取到SHARED_WRITE锁，后执行的delete操作未获取到SHARED_WRITE锁，处于WAITING状态。 执行删除后结果 9、执行delete的同时对删除的数据进行update操作 sql语句： 12delete from test_transaction where user_id=3; update test_transaction set name='test' where user_id=3; 步骤： 按顺序执行两条sql，查看此时获取到表的锁： 通过查看delete和update操作获取到的锁，优先执行的操作获取到SHARED_WRITE锁，后执行的操作未获取到SHARED_WRITE锁，处于WAITING状态。 执行delete和update后结果 注意：此处在delete优先于update执行，但执行结果为update的结果，执行异常。 10、执行delete的同时对不同的数据进行update操作 sql语句： 12delete from test_transaction where user_id=2; update test_transaction set name='test' where user_id=4; 步骤： 按顺序执行上面两条sql，查看表锁获取情况 通过查看delete和update操作获取到的锁，优先执行的操作获取到SHARED_WRITE锁，后执行的操作未获取到SHARED_WRITE锁，处于WAITING状态。 执行delete和update后结果,执行结果正常 11、执行delete的同时执行select操作 sql语句： 12delete from test_transaction where user_id=4; select count(*) from test_transaction; 步骤： 按顺序执行上面两条sql，查看表锁获取情况 在操作delete的同时执行select操作，两个操作均同时获取到SHARED_RED和SHARED_WRITE锁，操作并行进行未出现阻塞。 总结对比 Hive事务使用建议 传统数据库中有三种模型隐式事务、显示事务和自动事务。在目前Hive对事务仅支持自动事务，因此Hive无法通过显示事务的方式对一个操作序列进行事务控制。 传统数据库事务在遇到异常情况可自动进行回滚，目前Hive无法支持ROLLBACK。 传统数据库中支持事务并发，而Hive对事务无法做到完全并发控制,多个操作均需要获取WRITE的时候则这些操作为串行模式执行（在测试用例中”delete同一条数据的同时update该数据”，操作是串行的且操作完成后数据未被删除且数据被修改）未保证数据一致性。 Hive的事务功能尚属于实验室功能，并不建议用户直接上生产系统，因为目前它还有诸多的限制，如只支持ORC文件格式，建表必须分桶等，使用起来没有那么方便，另外该功能的稳定性还有待进一步验证。 CDH默认开启了Hive的Concurrency功能，主要是对并发读写的的时候通过锁进行了控制。所以为了防止用户在使用Hive的时候，报错提示该表已经被lock，对于用户来说不友好，建议在业务侧控制一下写入和读取，比如写入同一个table或者partition的时候保证是单任务写入，其他写入需控制写完第一个任务了，后面才继续写，并且控制在写的时候不让用户进行查询。另外需要控制在查询的时候不要允许有写入操作。 如果对于数据一致性不在乎，可以完全关闭Hive的Concurrency功能关闭，即设置hive.support.concurrency为false，这样Hive的并发读写将没有任何限制。","raw":null,"content":null,"categories":[{"name":"hive","slug":"hive","permalink":"https://freehubs.github.io/categories/hive/"}],"tags":[{"name":"hive","slug":"hive","permalink":"https://freehubs.github.io/tags/hive/"},{"name":"acid","slug":"acid","permalink":"https://freehubs.github.io/tags/acid/"}]},{"title":"SparkSQL-Catalyst优化理解","slug":"SparkSQL-Catalyst优化理解","date":"2017-11-30T11:32:26.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/11/30/SparkSQL-Catalyst优化理解/","link":"","permalink":"https://freehubs.github.io/2017/11/30/SparkSQL-Catalyst优化理解/","excerpt":"\n            前言\n          \n本文主要介绍SparkSQL的优化器系统Catalyst，其设计思路基本都来自于传统型数据库，而且和大多数当前的大数据SQL处理引擎设计基本相同（Impala、Presto、Hive（Calcite）等）。\nSQL优化器核心执行策略主要分为两个大的方向：\n\n基于规则优化（RBO）：是一种经验式、启发式地优化思路，更多地依靠前辈总结出来的优化规则，简单易行且能够覆盖到大部分优化逻辑，但是对于核心优化算子Join却显得有点力不从心。\n基于代价优化 (CBO)：根据代价估算确定一种代价最小的方案。\n\n举个简单的例子，两个表执行Join到底应该使用BroadcastHashJoin还是SortMergeJoin？当前SparkSQL的方式是通过手工设定参数来确定，如果一个表的数据量小于这个值就使用BroadcastHashJoin，但是这种方案显得很不优雅，很不灵活。基于代价优化就是为了解决这类问题，它会针对每个Join评估当前两张表使用每种Join策略的代价，根据代价估算确定一种代价最小的方案。","text":"前言 本文主要介绍SparkSQL的优化器系统Catalyst，其设计思路基本都来自于传统型数据库，而且和大多数当前的大数据SQL处理引擎设计基本相同（Impala、Presto、Hive（Calcite）等）。 SQL优化器核心执行策略主要分为两个大的方向： 基于规则优化（RBO）：是一种经验式、启发式地优化思路，更多地依靠前辈总结出来的优化规则，简单易行且能够覆盖到大部分优化逻辑，但是对于核心优化算子Join却显得有点力不从心。 基于代价优化 (CBO)：根据代价估算确定一种代价最小的方案。 举个简单的例子，两个表执行Join到底应该使用BroadcastHashJoin还是SortMergeJoin？当前SparkSQL的方式是通过手工设定参数来确定，如果一个表的数据量小于这个值就使用BroadcastHashJoin，但是这种方案显得很不优雅，很不灵活。基于代价优化就是为了解决这类问题，它会针对每个Join评估当前两张表使用每种Join策略的代价，根据代价估算确定一种代价最小的方案。 Tree&amp;Rule 在介绍SQL优化器工作原理之前，有必要首先介绍两个重要的数据结构：Tree和Rule。SQL语法树就是SQL语句通过编译器之后会被解析成一棵树状结构。这棵树会包含很多节点对象，每个节点都拥有特定的数据类型，同时会有0个或多个孩子节点（节点对象在代码中定义为TreeNode对象），下图是个简单的示例：如上图所示，箭头左边表达式有3种数据类型（Literal表示常量、Attribute表示变量、Add表示动作），表示x+(1+2)。映射到右边树状结构后，每一种数据类型就会变成一个节点。另外，Tree还有一个非常重要的特性，可以通过一定的规则进行等价变换，如下图： 上图定义了一个等价变换规则(Rule)：两个Integer类型的常量相加可以等价转换为一个Integer常量，这个规则其实很简单，对于上文中提到的表达式x+(1+2)来说就可以转变为x+3。对于程序来讲，如何找到两个Integer常量呢？其实就是简单的二叉树遍历算法，每遍历到一个节点，就模式匹配当前节点为Add、左右子节点是Integer常量的结构，定位到之后将此三个节点替换为一个Literal类型的节点。 上面用一个最简单的示例来说明等价变换规则以及如何将规则应用于语法树。在任何一个SQL优化器中，通常会定义大量的Rule（后面会讲到），SQL优化器会遍历语法树中每个节点，针对遍历到的节点模式匹配所有给定规则（Rule），如果有匹配成功的，就进行相应转换，如果所有规则都匹配失败，就继续遍历下一个节点。 Catalyst工作流程 任何一个优化器工作原理都大同小异：SQL语句首先通过Parser模块被解析为语法树，此棵树称为Unresolved Logical Plan；Unresolved Logical Plan通过Analyzer模块借助于数据元数据解析为Logical Plan；此时再通过各种基于规则的优化策略进行深入优化，得到Optimized Logical Plan；优化后的逻辑执行计划依然是逻辑的，并不能被Spark系统理解，此时需要将此逻辑执行计划转换为Physical Plan；为了更好的对整个过程进行理解，下文通过一个简单示例进行解释。 ParserParser简单来说是将SQL字符串切分成一个一个Token，再根据一定语义规则解析为一棵语法树。Parser模块目前基本都使用第三方类库ANTLR进行实现，比如Hive、 Presto、SparkSQL等。下图是一个示例性的SQL语句（有两张表，其中people表主要存储用户基本信息，score表存储用户的各种成绩），通过Parser解析后的AST语法树如图所示： Analyzer通过解析后的逻辑执行计划基本有了骨架，但是系统并不知道score、sum这些都是些什么鬼，此时需要基本的元数据信息来表达这些词素，最重要的元数据信息主要包括两部分：表的Scheme和基本函数信息，表的scheme主要包括表的基本定义（列名、数据类型）、表的数据格式（Json、Text）、表的物理位置等，基本函数信息主要指类信息。 Analyzer会再次遍历整个语法树，对树上的每个节点进行数据类型绑定以及函数绑定，比如people词素会根据元数据表信息解析为包含age、id以及name三列的表，people.age会被解析为数据类型为int的变量，sum会被解析为特定的聚合函数，如下图所示： SparkSQL中Analyzer定义了各种解析规则，可以查看Analyzer类，其中定义了基本的解析规则，如下： Optimizer优化器是整个Catalyst的核心，上文提到优化器分为基于规则优化和基于代价优化两种，当前SparkSQL 2.1依然没有很好的支持基于代价优化，此处只介绍基于规则的优化策略，基于规则的优化策略实际上就是对语法树进行一次遍历，模式匹配能够满足特定规则的节点，再进行相应的等价转换。因此，基于规则优化说到底就是一棵树等价地转换为另一棵树。SQL中经典的优化规则有很多，下文结合示例介绍三种比较常见的规则： 谓词下推（Predicate Pushdown） 常量累加（Constant Folding） 列值裁剪（Column Pruning） 上图左边是经过Analyzer解析后的语法树，语法树中两个表先做join，之后再使用age&gt;10对结果进行过滤。大家知道join算子通常是一个非常耗时的算子，耗时多少一般取决于参与join的两个表的大小，如果能够减少参与join两表的大小，就可以大大降低join算子所需时间。谓词下推就是这样一种功能，它会将过滤操作下推到join之前进行，上图中过滤条件age&gt;0以及id!=null两个条件就分别下推到了join之前。这样，系统在扫描数据的时候就对数据进行了过滤，参与join的数据量将会得到显著的减少，join耗时必然也会降低。 常量累加其实很简单，就是上文中提到的规则 x+(1+2) -&gt; x+3，虽然是一个很小的改动，但是意义巨大。示例如果没有进行优化的话，每一条结果都需要执行一次100+80的操作，然后再与变量math_score以及english_score相加，而优化后就不需要再执行100+80操作。 列值裁剪是另一个经典的规则，示例中对于people表来说，并不需要扫描它的所有列值，而只需要列值id，所以在扫描people之后需要将其他列进行裁剪，只留下列id。这个优化一方面大幅度减少了网络、内存数据量消耗，另一方面对于列存数据库（Parquet）来说大大提高了扫描效率。 除此之外，Catalyst还定义了很多其他优化规则，可以查看Optimizer类，下图简单的截取一部分规则： 至此，逻辑执行计划已经得到了比较完善的优化，然而，逻辑执行计划依然没办法真正执行，他们只是逻辑上可行，实际上Spark并不知道如何去执行这个东西。比如Join只是一个抽象概念，代表两个表根据相同的id进行合并，然而具体怎么实现这个合并，逻辑执行计划并没有说明。 此时就需要将逻辑执行计划转换为物理执行计划，将逻辑上可行的执行计划变为Spark可以真正执行的计划。比如Join算子，Spark根据不同场景为该算子制定了不同的算法策略，有BroadcastHashJoin、ShuffleHashJoin以及SortMergeJoin等（可以将Join理解为一个接口，BroadcastHashJoin是其中一个具体实现），物理执行计划实际上就是在这些具体实现中挑选一个耗时最小的算法实现，这个过程涉及到基于代价优化策略。 查看SparkSQL执行计划 至此，通过一个简单的示例完整的介绍了Catalyst的整个工作流程，包括Parser阶段、Analyzer阶段、Optimize阶段以及Physical Planning阶段。有同学可能会比较感兴趣Spark环境下如何查看一条具体的SQL的整个过程，在此介绍两种方法： 查看逻辑执行计划使用queryExecution方法查看逻辑执行计划，如下所示： 查看物理执行计划使用explain方法查看物理执行计划： Spark WebUI进行查看","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"},{"name":"sparkSQL","slug":"sparkSQL","permalink":"https://freehubs.github.io/tags/sparkSQL/"},{"name":"catalyst","slug":"catalyst","permalink":"https://freehubs.github.io/tags/catalyst/"}]},{"title":"spark容错机制","slug":"spark容错机制","date":"2017-11-29T17:16:32.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/11/29/spark容错机制/","link":"","permalink":"https://freehubs.github.io/2017/11/29/spark容错机制/","excerpt":"\n            引言\n          \n一般来说，分布式数据集的容错性有两种方式： 数据检查点 和 记录数据的更新 。面向大规模数据分析，数据检查点操作成本很高，需要通过数据中心的网络连接在机器之间复制庞大的数据集，而网络带宽往往比内存带宽低得多，同时还需要消耗更多的存储资源。因此，Spark选择记录更新的方式。\n但是，如果更新粒度太细太多，那么记录更新成本也不低。因此，RDD只支持粗粒度转换，即只记录单个块上执行的单个操作，然后将创建RDD的一系列变换序列（每个RDD都包含了他是如何由其他RDD变换过来的以及如何重建某一块数据的信息。因此RDD的容错机制又称“血统(Lineage)”容错）记录下来，以便恢复丢失的分区。 \nLineage本质上很类似于数据库中的重做日志（Redo Log），只不过这个重做日志粒度很大，是对全局数据做同样的重做进而恢复数据。\n            Lineage机制\n          \nLineage简介相比其他系统的细颗粒度的内存数据更新级别的备份或者LOG机制，RDD的Lineage记录的是粗颗粒度的特定数据Transformation操作（如filter、map、join等）行为。当这个RDD的部分分区数据丢失时，它可以通过Lineage获取足够的信息来重新运算和恢复丢失的数据分区。因为这种粗颗粒的数据模型，限制了Spark的运用场合，所以Spark并不适用于所有高性能要求的场景，但同时相比细颗粒度的数据模型，也带来了性能的提升。","text":"引言 一般来说，分布式数据集的容错性有两种方式： 数据检查点 和 记录数据的更新 。面向大规模数据分析，数据检查点操作成本很高，需要通过数据中心的网络连接在机器之间复制庞大的数据集，而网络带宽往往比内存带宽低得多，同时还需要消耗更多的存储资源。因此，Spark选择记录更新的方式。 但是，如果更新粒度太细太多，那么记录更新成本也不低。因此，RDD只支持粗粒度转换，即只记录单个块上执行的单个操作，然后将创建RDD的一系列变换序列（每个RDD都包含了他是如何由其他RDD变换过来的以及如何重建某一块数据的信息。因此RDD的容错机制又称“血统(Lineage)”容错）记录下来，以便恢复丢失的分区。 Lineage本质上很类似于数据库中的重做日志（Redo Log），只不过这个重做日志粒度很大，是对全局数据做同样的重做进而恢复数据。 Lineage机制 Lineage简介相比其他系统的细颗粒度的内存数据更新级别的备份或者LOG机制，RDD的Lineage记录的是粗颗粒度的特定数据Transformation操作（如filter、map、join等）行为。当这个RDD的部分分区数据丢失时，它可以通过Lineage获取足够的信息来重新运算和恢复丢失的数据分区。因为这种粗颗粒的数据模型，限制了Spark的运用场合，所以Spark并不适用于所有高性能要求的场景，但同时相比细颗粒度的数据模型，也带来了性能的提升。 两种依赖关系RDD在Lineage依赖方面分为两种：窄依赖(Narrow Dependencies)与宽依赖(Wide Dependencies,源码中称为Shuffle Dependencies)，用来解决数据容错的高效性。 窄依赖：是指父RDD的每一个分区最多被一个子RDD的分区所用，表现为一个父RDD的分区对应于一个子RDD的分区，或多个父RDD的分区对应于一个子RDD的分区，也就是说一个父RDD的一个分区不可能对应一个子RDD的多个分区。 1个父RDD分区对应1个子RDD分区，这其中又分两种情况：1个子RDD分区对应1个父RDD分区（如map、filter等算子），1个子RDD分区对应N个父RDD分区（如co-paritioned（协同划分）过的Join）。 宽依赖：是指子RDD的分区依赖于父RDD的多个分区或所有分区，即存在一个父RDD的一个分区对应一个子RDD的多个分区。 1个父RDD分区对应多个子RDD分区，这其中又分两种情况：1个父RDD对应所有子RDD分区（未经协同划分的Join）或者1个父RDD对应非全部的多个RDD分区（如groupByKey）。 本质理解根据父RDD分区是对应1个还是多个子RDD分区来区分窄依赖（父分区对应一个子分区，多个父分区对应一个子分区）和宽依赖（父分区对应多个子分区）。如果对应多个，则当容错重算分区时，因为父分区数据只有一部分是需要重算子分区的，其余数据重算就造成了冗余计算。 对于宽依赖，Stage计算的输入和输出在不同的节点上，对于输入节点完好，而输出节点死机的情况，通过重新计算恢复数据这种情况下，这种方法容错是有效的，否则无效，因为无法重试，需要向上追溯其祖先看是否可以重试（这就是lineage，血统的意思），窄依赖对于数据的重算开销要远小于宽依赖的数据重算开销。 窄依赖和宽依赖的概念主要用在两个地方：一个是容错中相当于Redo日志的功能；另一个是在调度中构建DAG作为不同Stage的划分点。 依赖关系的特性第一，窄依赖可以在某个计算节点上直接通过计算父RDD的某块数据计算得到子RDD对应的某块数据；宽依赖则要等到父RDD所有数据都计算完成之后，并且父RDD的计算结果进行hash并传到对应节点上之后才能计算子RDD。 第二，数据丢失时，对于窄依赖只需要重新计算丢失的那一块数据来恢复；对于宽依赖则要将祖先RDD中的所有数据块全部重新计算来恢复。所以在长“血统”链特别是有宽依赖的时候，需要在适当的时机设置数据检查点。也是这两个特性要求对于不同依赖关系要采取不同的任务调度机制和容错恢复机制。 容错原理在容错机制中，如果一个节点死机了，而且运算窄依赖，则只要把丢失的父RDD分区重算即可，不依赖于其他节点。而宽依赖需要父RDD的所有分区都存在，重算就很昂贵了。 可以这样理解开销的经济与否：在窄依赖中，在子RDD的分区丢失、重算父RDD分区时，父RDD相应分区的所有数据都是子RDD分区的数据，并不存在冗余计算。在宽依赖情况下，丢失一个子RDD分区重算的每个父RDD的每个分区的所有数据并不是都给丢失的子RDD分区用的，会有一部分数据相当于对应的是未丢失的子RDD分区中需要的数据，这样就会产生冗余计算开销，这也是宽依赖开销更大的原因。 因此如果使用Checkpoint算子来做检查点，不仅要考虑Lineage是否足够长，也要考虑是否有宽依赖，对宽依赖加Checkpoint是最物有所值的。 Checkpoint机制 通过上述分析可以看出在以下两种情况下，RDD需要加检查点。 DAG中的Lineage过长，如果重算，则开销太大（如在PageRank中）。 在宽依赖上做Checkpoint获得的收益更大。 由于RDD是只读的，所以Spark的RDD计算中一致性不是主要关心的内容，内存相对容易管理，这也是设计者很有远见的地方，这样减少了框架的复杂性，提升了性能和可扩展性，为以后上层框架的丰富奠定了强有力的基础。 在RDD计算中，通过检查点机制进行容错，传统做检查点有两种方式：通过冗余数据和日志记录更新操作。在RDD中的doCheckPoint方法相当于通过冗余数据来缓存数据，而之前介绍的血统就是通过相当粗粒度的记录更新操作来实现容错的。 检查点（本质是通过将RDD写入Disk做检查点）是为了通过lineage做容错的辅助，lineage过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果之后有节点出现问题而丢失分区，从做检查点的RDD开始重做Lineage，就会减少开销。","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"},{"name":"原理","slug":"原理","permalink":"https://freehubs.github.io/tags/原理/"}]},{"title":"ORC与PARQUET文件类型的比较","slug":"ORC与PARQUET文件类型的比较","date":"2017-11-29T10:29:04.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/11/29/ORC与PARQUET文件类型的比较/","link":"","permalink":"https://freehubs.github.io/2017/11/29/ORC与PARQUET文件类型的比较/","excerpt":"列式存储由于OLAP查询的特点，列式存储可以提升其查询性能，但是它是如何做到的呢？这就要从列式存储的原理说起，从图1中可以看到，相对于关系数据库中通常使用的行式存储，在使用列式存储时每一列的所有元素都是顺序存储的。由此特点可以给查询带来如下的优化：\n123查询的时候不需要扫描全部的数据，而只需要读取每次查询涉及的列，这样可以将I/O消耗降低N倍，另外可以保存每一列的统计信息(min、max、sum等)，实现部分的谓词下推。由于每一列的成员都是同构的，可以针对不同的数据类型使用更高效的数据压缩算法，进一步减小I/O。由于每一列的成员的同构性，可以使用更加适合CPU pipeline的编码方式，减小CPU的缓存失效。\n图1 行式存储VS列式存储","text":"列式存储由于OLAP查询的特点，列式存储可以提升其查询性能，但是它是如何做到的呢？这就要从列式存储的原理说起，从图1中可以看到，相对于关系数据库中通常使用的行式存储，在使用列式存储时每一列的所有元素都是顺序存储的。由此特点可以给查询带来如下的优化： 123查询的时候不需要扫描全部的数据，而只需要读取每次查询涉及的列，这样可以将I/O消耗降低N倍，另外可以保存每一列的统计信息(min、max、sum等)，实现部分的谓词下推。由于每一列的成员都是同构的，可以针对不同的数据类型使用更高效的数据压缩算法，进一步减小I/O。由于每一列的成员的同构性，可以使用更加适合CPU pipeline的编码方式，减小CPU的缓存失效。 图1 行式存储VS列式存储 嵌套数据格式通常我们使用关系数据库存储结构化数据，而关系数据库支持的数据模型都是扁平式的，而遇到诸如List、Map和自定义Struct的时候就需要用户自己解析，但是在大数据环境下，数据的来源多种多样，例如埋点数据，很可能需要把程序中的某些对象内容作为输出的一部分，而每一个对象都可能是嵌套的，所以如果能够原生的支持这种数据，查询的时候就不需要额外的解析便能获得想要的结果。例如在Twitter，他们一个典型的日志对象（一条记录）有87个字段，其中嵌套了7层，如下图。 图2 嵌套数据模型 随着嵌套格式的数据的需求日益增加，目前Hadoop生态圈中主流的查询引擎都支持更丰富的数据类型，例如Hive、SparkSQL、Impala等都原生的支持诸如struct、map、array这样的复杂数据类型，这样促使各种存储格式都需要支持嵌套数据格式。 Parquet存储格式Apache Parquet是Hadoop生态圈中一种新型列式存储格式，它可以兼容Hadoop生态圈中大多数计算框架(Mapreduce、Spark等)，被多种查询引擎支持（Hive、Impala、Drill等），并且它是语言和平台无关的。Parquet最初是由Twitter和Cloudera合作开发完成并开源，2015年5月从Apache的孵化器里毕业成为Apache顶级项目。 Parquet最初的灵感来自Google于2010年发表的Dremel论文，文中介绍了一种支持嵌套结构的存储格式，并且使用了列式存储的方式提升查询性能，在Dremel论文中还介绍了Google如何使用这种存储格式实现并行查询的，如果对此感兴趣可以参考论文和开源实现Drill。 数据模型Parquet支持嵌套的数据模型，类似于Protocol Buffers，每一个数据模型的schema包含多个字段，每一个字段有三个属性：重复次数、数据类型和字段名，重复次数可以是以下三种：required(只出现1次)，repeated(出现0次或多次)，optional(出现0次或1次)。每一个字段的数据类型可以分成两种：group(复杂类型)和primitive(基本类型)。例如Dremel中提供的Document的schema示例，它的定义如下： 1234567891011121314message Document &#123; required int64 DocId; optional group Links &#123; repeated int64 Backward; repeated int64 Forward; &#125; repeated group Name &#123; repeated group Language &#123; required string Code; optional string Country; &#125; optional string Url; &#125;&#125; 可以把这个Schema转换成树状结构，根节点可以理解为repeated类型，如图3。 图3 Parquet的schema结构 可以看出在Schema中所有的基本类型字段都是叶子节点，在这个Schema中一共存在6个叶子节点，如果把这样的Schema转换成扁平式的关系模型，就可以理解为该表包含六个列。Parquet中没有Map、Array这样的复杂数据结构，但是可以通过repeated和group组合来实现的。由于一条记录中某一列可能出现零次或者多次，需要标示出哪些列的值构成一条完整的记录。这是由Striping/Assembly算法实现的。 由于Parquet支持的数据模型比较松散，可能一条记录中存在比较深的嵌套关系，如果为每一条记录都维护一个类似的树状结可能会占用较大的存储空间，因此Dremel论文中提出了一种高效的对于嵌套数据格式的压缩算法：Striping/Assembly算法。它的原理是每一个记录中的每一个成员值有三部分组成：Value、Repetition level和Definition level。value记录了该成员的原始值，可以根据特定类型的压缩算法进行压缩，两个level值用于记录该值在整个记录中的位置。对于repeated类型的列，Repetition level值记录了当前值属于哪一条记录以及它处于该记录的什么位置；对于repeated和optional类型的列，可能一条记录中某一列是没有值的，假设我们不记录这样的值就会导致本该属于下一条记录的值被当做当前记录的一部分，从而造成数据的错误，因此对于这种情况需要一个占位符标示这种情况。 通过Striping/Assembly算法，parquet可以使用较少的存储空间表示复杂的嵌套格式，并且通常Repetition level和Definition level都是较小的整数值，可以通过RLE算法对其进行压缩，进一步降低存储空间。 文件结构Parquet文件是以二进制方式存储的，是不可以直接读取和修改的，Parquet文件是自解析的，文件中包括该文件的数据和元数据。在HDFS文件系统和Parquet文件中存在如下几个概念： HDFS块(Block)：它是HDFS上的最小的副本单位，HDFS会把一个Block存储在本地的一个文件并且维护分散在不同的机器上的多个副本，通常情况下一个Block的大小为256M、512M等。 HDFS文件(File)：一个HDFS的文件，包括数据和元数据，数据分散存储在多个Block中。 行组(Row Group)：按照行将数据物理上划分为多个单元，每一个行组包含一定的行数，在一个HDFS文件中至少存储一个行组，Parquet读写的时候会将整个行组缓存在内存中，所以如果每一个行组的大小是由内存大的小决定的。 列块(Column Chunk)：在一个行组中每一列保存在一个列块中，行组中的所有列连续的存储在这个行组文件中。不同的列块可能使用不同的算法进行压缩。 页(Page)：每一个列块划分为多个页，一个页是最小的编码的单位，在同一个列块的不同页可能使用不同的编码方式。 通常情况下，在存储Parquet数据的时候会按照HDFS的Block大小设置行组的大小，由于一般情况下每一个Mapper任务处理数据的最小单位是一个Block，这样可以把每一个行组由一个Mapper任务处理，增大任务执行并行度。Parquet文件的格式如下图所示。 图4 Parquet文件结构 上图展示了一个Parquet文件的结构，一个文件中可以存储多个行组，文件的首位都是该文件的Magic Code，用于校验它是否是一个Parquet文件，Footer length存储了文件元数据的大小，通过该值和文件长度可以计算出元数据的偏移量，文件的元数据中包括每一个行组的元数据信息和当前文件的Schema信息。除了文件中每一个行组的元数据，每一页的开始都会存储该页的元数据，在Parquet中，有三种类型的页：数据页、字典页和索引页。数据页用于存储当前行组中该列的值，字典页存储该列值的编码字典，每一个列块中最多包含一个字典页，索引页用来存储当前行组下该列的索引，目前Parquet中还不支持索引页，但是在后面的版本中增加。 数据访问说到列式存储的优势，Project下推是无疑最突出的，它意味着在获取表中原始数据时只需要扫描查询中需要的列，由于每一列的所有值都是连续存储的，避免扫描整个表文件内容。 在Parquet中原生就支持Project下推，执行查询的时候可以通过Configuration传递需要读取的列的信息，这些列必须是Schema的子集，Parquet每次会扫描一个Row Group的数据，然后一次性得将该Row Group里所有需要的列的Cloumn Chunk都读取到内存中，每次读取一个Row Group的数据能够大大降低随机读的次数，除此之外，Parquet在读取的时候会考虑列是否连续，如果某些需要的列是存储位置是连续的，那么一次读操作就可以把多个列的数据读取到内存。 在数据访问的过程中，Parquet还可以利用每一个row group生成的统计信息进行谓词下推，这部分信息包括该Column Chunk的最大值、最小值和空值个数。通过这些统计值和该列的过滤条件可以判断该Row Group是否需要扫描。另外Parquet未来还会增加诸如Bloom Filter和Index等优化数据，更加有效的完成谓词下推。 ORC文件格式ORC文件格式是一种Hadoop生态圈中的列式存储格式，它的产生早在2013年初，最初产生自Apache Hive，用于降低Hadoop数据存储空间和加速Hive查询速度。和Parquet类似，它并不是一个单纯的列式存储格式，仍然是首先根据行组分割整个表，在每一个行组内进行按列存储。ORC文件是自描述的，它的元数据使用Protocol Buffers序列化，并且文件中的数据尽可能的压缩以降低存储空间的消耗，目前也被Spark SQL、Presto等查询引擎支持，但是Impala对于ORC目前没有支持，仍然使用Parquet作为主要的列式存储格式。2015年ORC项目被Apache项目基金会提升为Apache顶级项目。 数据模型和Parquet不同，ORC原生是不支持嵌套数据格式的，而是通过对复杂数据类型特殊处理的方式实现嵌套格式的支持，例如对于如下的hive表： 12345CREATE TABLE `orcStructTable`( `name` string, `course` struct&lt;course:string,score:int&gt;, `score` map&lt;string,int&gt;, `work_locations` array&lt;string&gt;) 图5 ORC的schema结构 在ORC的结构中这个schema包含10个column，其中包含了复杂类型列和原始类型的列，前者包括LIST、STRUCT、MAP和UNION类型，后者包括BOOLEAN、整数、浮点数、字符串类型等，其中STRUCT的孩子节点包括它的成员变量，可能有多个孩子节点，MAP有两个孩子节点，分别为key和value，LIST包含一个孩子节点，类型为该LIST的成员类型，UNION一般不怎么用得到。每一个Schema树的根节点为一个Struct类型，所有的column按照树的中序遍历顺序编号。 ORC只需要存储schema树中叶子节点的值，而中间的非叶子节点只是做一层代理，它们只需要负责孩子节点值得读取，只有真正的叶子节点才会读取数据，然后交由父节点封装成对应的数据结构返回。 文件结构和Parquet类似，ORC文件也是以二进制方式存储的，所以是不可以直接读取，ORC文件也是自解析的，它包含许多的元数据，这些元数据都是同构ProtoBuffer进行序列化的。ORC的文件结构入图6，其中涉及到如下的概念： ORC文件：保存在文件系统上的普通二进制文件，一个ORC文件中可以包含多个stripe，每一个stripe包含多条记录，这些记录按照列进行独立存储，对应到Parquet中的row group的概念。 文件级元数据：包括文件的描述信息PostScript、文件meta信息（包括整个文件的统计信息）、所有stripe的信息和文件schema信息。 stripe：一组行形成一个stripe，每次读取文件是以行组为单位的，一般为HDFS的块大小，保存了每一列的索引和数据。 stripe元数据：保存stripe的位置、每一个列的在该stripe的统计信息以及所有的stream类型和位置。 row group：索引的最小单位，一个stripe中包含多个row group，默认为10000个值组成。 stream：一个stream表示文件中一段有效的数据，包括索引和数据两类。索引stream保存每一个row group的位置和统计信息，数据stream包括多种类型的数据，具体需要哪几种是由该列类型和编码方式决定。 图6 ORC文件结构 在ORC文件中保存了三个层级的统计信息，分别为文件级别、stripe级别和row group级别的，他们都可以用来根据Search ARGuments（谓词下推条件）判断是否可以跳过某些数据，在统计信息中都包含成员数和是否有null值，并且对于不同类型的数据设置一些特定的统计信息。 数据访问读取ORC文件是从尾部开始的，第一次读取16KB的大小，尽可能的将Postscript和Footer数据都读入内存。文件的最后一个字节保存着PostScript的长度，它的长度不会超过256字节，PostScript中保存着整个文件的元数据信息，它包括文件的压缩格式、文件内部每一个压缩块的最大长度(每次分配内存的大小)、Footer长度，以及一些版本信息。在Postscript和Footer之间存储着整个文件的统计信息(上图中未画出)，这部分的统计信息包括每一个stripe中每一列的信息，主要统计成员数、最大值、最小值、是否有空值等。 接下来读取文件的Footer信息，它包含了每一个stripe的长度和偏移量，该文件的schema信息(将schema树按照schema中的编号保存在数组中)、整个文件的统计信息以及每一个row group的行数。 处理stripe时首先从Footer中获取每一个stripe的其实位置和长度、每一个stripe的Footer数据(元数据，记录了index和data的的长度)，整个striper被分为index和data两部分，stripe内部是按照row group进行分块的(每一个row group中多少条记录在文件的Footer中存储)，row group内部按列存储。每一个row group由多个stream保存数据和索引信息。每一个stream的数据会根据该列的类型使用特定的压缩算法保存。在ORC中存在如下几种stream类型： PRESENT：每一个成员值在这个stream中保持一位(bit)用于标示该值是否为NULL，通过它可以只记录部位NULL的值 DATA：该列的中属于当前stripe的成员值。 LENGTH：每一个成员的长度，这个是针对string类型的列才有的。 DICTIONARY_DATA：对string类型数据编码之后字典的内容。 SECONDARY：存储Decimal、timestamp类型的小数或者纳秒数等。 ROW_INDEX：保存stripe中每一个row group的统计信息和每一个row group起始位置信息。 在初始化阶段获取全部的元数据之后，可以通过includes数组指定需要读取的列编号，它是一个boolean数组，如果不指定则读取全部的列，还可以通过传递SearchArgument参数指定过滤条件，根据元数据首先读取每一个stripe中的index信息，然后根据index中统计信息以及SearchArgument参数确定需要读取的row group编号，再根据includes数据决定需要从这些row group中读取的列，通过这两层的过滤需要读取的数据只是整个stripe多个小段的区间，然后ORC会尽可能合并多个离散的区间尽可能的减少I/O次数。然后再根据index中保存的下一个row group的位置信息调至该stripe中第一个需要读取的row group中。 由于ORC中使用了更加精确的索引信息，使得在读取数据时可以指定从任意一行开始读取，更细粒度的统计信息使得读取ORC文件跳过整个row group，ORC默认会对任何一块数据和索引信息使用ZLIB压缩，因此ORC文件占用的存储空间也更小，这点在后面的测试对比中也有所印证。 在新版本的ORC中也加入了对Bloom Filter的支持，它可以进一步提升谓词下推的效率，在Hive 1.2.0版本以后也加入了对此的支持。 性能测试为了对比测试两种存储格式，我选择使用TPC-DS数据集并且对它进行改造以生成宽表、嵌套和多层嵌套的数据。使用最常用的Hive作为SQL引擎进行测试。 测试环境 Hadoop集群：物理测试集群，四台DataNode/NodeManager机器，每个机器32core+128GB，测试时使用整个集群的资源。 Hive：Hive 1.2.1版本，使用hiveserver2启动，本机MySql作为元数据库，jdbc方式提交查询SQL 数据集：100GB TPC-DS数据集，选取其中的Store_Sales为事实表的模型作为测试数据 查询SQL：选择TPC-DS中涉及到上述模型的10条SQL并对其进行改造。 测试场景和结果整个测试设置了四种场景，每一种场景下对比测试数据占用的存储空间的大小和相同查询执行消耗的时间对比，除了场景一基于原始的TPC-DS数据集外，其余的数据都需要进行数据导入，同时对比这几个场景的数据导入时间。 场景一：一个事实表、多个维度表，复杂的join查询。基于原始的TPC-DS数据集。 Store_Sales表记录数：287,997,024，表大小为： 原始Text格式，未压缩 : 38.1 G ORC格式，默认压缩（ZLIB）,一共1800+个分区 : 11.5 G Parquet格式，默认压缩（Snappy），一共1800+个分区 ： 14.8 G 查询测试结果： 场景二：维度表和事实表join之后生成的宽表，只在一个表上做查询。整个测试设置了四种场景，每一种场景下对比测试数据占用的存储空间的大小和相同查询执行消耗的时间对比，除了场景一基于原始的TPC-DS数据集外，其余的数据都需要进行数据导入，同时对比这几个场景的数据导入时间。选取数据模型中的store_sales, household_demographics, customer_address, date_dim, store表生成一个扁平式宽表(store_sales_wide_table)，基于这个表执行查询，由于场景一种选择的query大多数不能完全match到这个宽表，所以对场景1中的SQL进行部分改造。 store_sales_wide_table表记录数：263,704,266，表大小为： 原始Text格式，未压缩 ： 149.0 G ORC格式，默认压缩 ： 10.6 G PARQUET格式，默认压缩 ： 12.5 G 查询测试结果： 场景三：复杂的数据结构组成的宽表，struct、list、map等（1层）整个测试设置了四种场景，每一种场景下对比测试数据占用的存储空间的大小和相同查询执行消耗的时间对比，除了场景一基于原始的TPC-DS数据集外，其余的数据都需要进行数据导入，同时对比这几个场景的数据导入时间。在场景二的基础上，将维度表（除了store_sales表）转换成一个struct或者map对象，源store_sales表中的字段保持不变。生成有一层嵌套的新表（store_sales_wide_table_one_nested），使用的查询逻辑相同。 store_sales_wide_table_one_nested表记录数：263,704,266，表大小为： 原始Text格式，未压缩 ： 245.3 G ORC格式，默认压缩 ： 10.9 G PARQUET格式，默认压缩 ： 29.8 G 查询测试结果： 场景四：复杂的数据结构，多层嵌套。（3层）整个测试设置了四种场景，每一种场景下对比测试数据占用的存储空间的大小和相同查询执行消耗的时间对比，除了场景一基于原始的TPC-DS数据集外，其余的数据都需要进行数据导入，同时对比这几个场景的数据导入时间。在场景三的基础上，将部分维度表的struct内的字段再转换成struct或者map对象，只存在struct中嵌套map的情况，最深的嵌套为三层。生成一个多层嵌套的新表（store_sales_wide_table_more_nested），使用的查询逻辑相同。 该场景中只涉及一个多层嵌套的宽表，没有任何分区字段，store_sales_wide_table_more_nested表记录数：263,704,266，表大小为： 原始Text格式，未压缩 ： 222.7 G ORC格式，默认压缩 ： 10.9 G PARQUET格式，默认压缩 ： 23.1 G 比一层嵌套表store_sales_wide_table_one_nested要小？ 查询测试结果： 结果分析从上述测试结果来看，星状模型对于数据分析场景并不是很合适，多个表的join会大大拖慢查询速度，并且不能很好的利用列式存储带来的性能提升，在使用宽表的情况下，列式存储的性能提升明显，ORC文件格式在存储空间上要远优于Text格式，较之于PARQUET格式有一倍的存储空间提升，在导数据（insert into table select 这样的方式）方面ORC格式也要优于PARQUET，在最终的查询性能上可以看到，无论是无嵌套的扁平式宽表，或是一层嵌套表，还是多层嵌套的宽表，两者的查询性能相差不多，较之于Text格式有2到3倍左右的提升。 另外，通过对比场景二和场景三的测试结果，可以发现扁平式的表结构要比嵌套式结构的查询性能有所提升，所以如果选择使用大宽表，则设计宽表的时候尽可能的将表设计的扁平化，减少嵌套数据。 通过这三种文件存储格式的测试对比，ORC文件存储格式无论是在空间存储、导数据速度还是查询速度上表现的都较好一些，并且ORC可以一定程度上支持ACID操作，社区的发展目前也是Hive中比较提倡使用的一种列式存储格式，另外，本次测试主要针对的是Hive引擎，所以不排除存在Hive与ORC的敏感度比PARQUET要高的可能性。 总结本文主要从数据模型、文件格式和数据访问流程等几个方面详细介绍了Hadoop生态圈中的两种列式存储格式——Parquet和ORC，并通过大数据量的测试对两者的存储和查询性能进行了对比。对于大数据场景下的数据分析需求，使用这两种存储格式总会带来存储和性能上的提升，但是在实际使用时还需要针对实际的数据进行选择。另外由于不同开源产品可能对不同的存储格式有特定的优化，所以选择时还需要考虑查询引擎的因素。 拓展阅读：spark关于parquet的优化","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"},{"name":"parquet","slug":"parquet","permalink":"https://freehubs.github.io/tags/parquet/"},{"name":"orc","slug":"orc","permalink":"https://freehubs.github.io/tags/orc/"}]},{"title":"spark分层取样","slug":"spark分层取样","date":"2017-11-27T16:57:10.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/11/27/spark分层取样/","link":"","permalink":"https://freehubs.github.io/2017/11/27/spark分层取样/","excerpt":"先将总体的单位按某种特征分为若干次级总体（层），然后再从每一层内进行单纯随机抽样，组成一个样本的统计学计算方法叫做分层抽样。在spark.mllib中，用key来分层。\n与存在于spark.mllib中的其它统计函数不同，分层采样方法sampleByKey和sampleByKeyExact可以在key-value对的RDD上执行。在分层采样中，可以认为key是一个标签，value是特定的属性。例如，key可以是男人或者女人或者文档id,它相应的value可能是一组年龄或者是文档中的词。sampleByKey方法通过掷硬币的方式决定是否采样一个观察数据，因此它需要我们传递（pass over）数据并且提供期望的数据大小(size)。sampleByKeyExact比每层使用sampleByKey随机抽样需要更多的有意义的资源，但是它能使样本大小的准确性达到了99.99%。\nsampleByKeyExact()允许用户准确抽取f_k * n_k个样本，这里f_k表示期望获取键为k的样本的比例，n_k表示键为k的键值对的数量。下面是一个使用的例子：","text":"先将总体的单位按某种特征分为若干次级总体（层），然后再从每一层内进行单纯随机抽样，组成一个样本的统计学计算方法叫做分层抽样。在spark.mllib中，用key来分层。 与存在于spark.mllib中的其它统计函数不同，分层采样方法sampleByKey和sampleByKeyExact可以在key-value对的RDD上执行。在分层采样中，可以认为key是一个标签，value是特定的属性。例如，key可以是男人或者女人或者文档id,它相应的value可能是一组年龄或者是文档中的词。sampleByKey方法通过掷硬币的方式决定是否采样一个观察数据，因此它需要我们传递（pass over）数据并且提供期望的数据大小(size)。sampleByKeyExact比每层使用sampleByKey随机抽样需要更多的有意义的资源，但是它能使样本大小的准确性达到了99.99%。 sampleByKeyExact()允许用户准确抽取f_k * n_k个样本，这里f_k表示期望获取键为k的样本的比例，n_k表示键为k的键值对的数量。下面是一个使用的例子： 123456789import org.apache.spark.SparkContextimport org.apache.spark.SparkContext._import org.apache.spark.rdd.PairRDDFunctionsval sc: SparkContext = ...val data = ... // an RDD[(K, V)] of any key value pairsval fractions: Map[K, Double] = ... // specify the exact fraction desired from each key// Get an exact sample from each stratumval approxSample = data.sampleByKey(withReplacement = false, fractions)val exactSample = data.sampleByKeyExact(withReplacement = false, fractions) 当withReplacement为true时，采用PoissonSampler取样器，当withReplacement为false使，采用BernoulliSampler取样器。 123456789101112131415161718192021def sampleByKey(withReplacement: Boolean, fractions: Map[K, Double], seed: Long = Utils.random.nextLong): RDD[(K, V)] = self.withScope &#123; val samplingFunc = if (withReplacement) &#123; StratifiedSamplingUtils.getPoissonSamplingFunction(self, fractions, false, seed) &#125; else &#123; StratifiedSamplingUtils.getBernoulliSamplingFunction(self, fractions, false, seed) &#125; self.mapPartitionsWithIndex(samplingFunc, preservesPartitioning = true) &#125;def sampleByKeyExact( withReplacement: Boolean, fractions: Map[K, Double], seed: Long = Utils.random.nextLong): RDD[(K, V)] = self.withScope &#123; val samplingFunc = if (withReplacement) &#123; StratifiedSamplingUtils.getPoissonSamplingFunction(self, fractions, true, seed) &#125; else &#123; StratifiedSamplingUtils.getBernoulliSamplingFunction(self, fractions, true, seed) &#125; self.mapPartitionsWithIndex(samplingFunc, preservesPartitioning = true) &#125; 下面我们分别来看sampleByKey和sampleByKeyExact的实现。 sampleByKey的实现当我们需要不重复抽样时，我们需要用泊松抽样器来抽样。当需要重复抽样时，用伯努利抽样器抽样。sampleByKey的实现比较简单，它就是统一的随机抽样。 泊松抽样器我们首先看泊松抽样器的实现。 12345678910111213141516171819def getPoissonSamplingFunction[K: ClassTag, V: ClassTag](rdd: RDD[(K, V)], fractions: Map[K, Double], exact: Boolean, seed: Long): (Int, Iterator[(K, V)]) =&gt; Iterator[(K, V)] = &#123; (idx: Int, iter: Iterator[(K, V)]) =&gt; &#123; //初始化随机生成器 val rng = new RandomDataGenerator() rng.reSeed(seed + idx) iter.flatMap &#123; item =&gt; //获得下一个泊松值 val count = rng.nextPoisson(fractions(item._1)) if (count == 0) &#123; Iterator.empty &#125; else &#123; Iterator.fill(count)(item) &#125; &#125; &#125;&#125; getPoissonSamplingFunction返回的是一个函数，传递给mapPartitionsWithIndex处理每个分区的数据。这里RandomDataGenerator是一个随机生成器，它用于同时生成均匀值(uniform values)和泊松值(Poisson values)。 伯努利抽样器1234567891011121314def getBernoulliSamplingFunction[K, V](rdd: RDD[(K, V)], fractions: Map[K, Double], exact: Boolean, seed: Long): (Int, Iterator[(K, V)]) =&gt; Iterator[(K, V)] = &#123; var samplingRateByKey = fractions (idx: Int, iter: Iterator[(K, V)]) =&gt; &#123; //初始化随机生成器 val rng = new RandomDataGenerator() rng.reSeed(seed + idx) // Must use the same invoke pattern on the rng as in getSeqOp for without replacement // in order to generate the same sequence of random numbers when creating the sample iter.filter(t =&gt; rng.nextUniform() &lt; samplingRateByKey(t._1)) &#125; &#125; sampleByKeyExact的实现sampleByKeyExact获取更准确的抽样结果，它的实现也分为两种情况，重复抽样和不重复抽样。前者使用泊松抽样器，后者使用伯努利抽样器。 泊松抽样器12345678910111213141516171819202122232425val counts = Some(rdd.countByKey())//计算立即接受的样本数量，并且为每层生成候选名单val finalResult = getAcceptanceResults(rdd, true, fractions, counts, seed)//决定接受样本的阈值，生成准确的样本大小val thresholdByKey = computeThresholdByKey(finalResult, fractions)(idx: Int, iter: Iterator[(K, V)]) =&gt; &#123; val rng = new RandomDataGenerator() rng.reSeed(seed + idx) iter.flatMap &#123; item =&gt; val key = item._1 val acceptBound = finalResult(key).acceptBound // Must use the same invoke pattern on the rng as in getSeqOp for with replacement // in order to generate the same sequence of random numbers when creating the sample val copiesAccepted = if (acceptBound == 0) 0L else rng.nextPoisson(acceptBound) //候选名单 val copiesWaitlisted = rng.nextPoisson(finalResult(key).waitListBound) val copiesInSample = copiesAccepted + (0 until copiesWaitlisted).count(i =&gt; rng.nextUniform() &lt; thresholdByKey(key)) if (copiesInSample &gt; 0) &#123; Iterator.fill(copiesInSample.toInt)(item) &#125; else &#123; Iterator.empty &#125; &#125;&#125; 伯努利抽样1234567891011121314151617def getBernoulliSamplingFunction[K, V](rdd: RDD[(K, V)], fractions: Map[K, Double], exact: Boolean, seed: Long): (Int, Iterator[(K, V)]) =&gt; Iterator[(K, V)] = &#123; var samplingRateByKey = fractions //计算立即接受的样本数量，并且为每层生成候选名单 val finalResult = getAcceptanceResults(rdd, false, fractions, None, seed) //决定接受样本的阈值，生成准确的样本大小 samplingRateByKey = computeThresholdByKey(finalResult, fractions) (idx: Int, iter: Iterator[(K, V)]) =&gt; &#123; val rng = new RandomDataGenerator() rng.reSeed(seed + idx) // Must use the same invoke pattern on the rng as in getSeqOp for without replacement // in order to generate the same sequence of random numbers when creating the sample iter.filter(t =&gt; rng.nextUniform() &lt; samplingRateByKey(t._1)) &#125; &#125;","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"},{"name":"取样","slug":"取样","permalink":"https://freehubs.github.io/tags/取样/"},{"name":"源码","slug":"源码","permalink":"https://freehubs.github.io/tags/源码/"}]},{"title":"Dataset.scala","slug":"Dataset-scala","date":"2017-11-23T09:34:44.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/11/23/Dataset-scala/","link":"","permalink":"https://freehubs.github.io/2017/11/23/Dataset-scala/","excerpt":"前言Dataset 是一种强类型的领域特定对象集合，可以在使用功能或关系操作的同时进行转换。每个 Dataset 也有一个名为 “DataFrame” 的无类型视图，它是 [[Row]] 的 Dataset。Dataset 上可用的操作分为转换和动作:\n\n转换：产生新的 Dataset ；包括 map, filter, select, and aggregate (groupBy).动作：触发计算并返回结果 ；包括 count, show, or 写数据到文件系统。\n\nDataset是懒加载的，例如：只有提交动作的时候才会触发计算。在内部，Datasets表示一个逻辑计划，它描述生成数据所需的计算。当提交动作时，Spark的查询优化器会优化逻辑计划，并以并行和分布式的方式生成有效执行的物理计划。请使用explain 功能，探索逻辑计划和优化的物理计划。\n为了有效地支持特定于领域的对象，需要[[Encoder]]。编码器将特定类型的“T”映射到Spark的内部类型系统。例如：给一个 Person 类，并带有两个属性：name (string) and age (int),编码器告诉Spark在运行时生成代码，序列化 Person 对象为二进制结构。\n通常有两种创建Dataset的方法:\n\n使用 SparkSession 上可用的 read 方法读取 Spark 指向的存储系统上的文件。用现存的 Datasets 转换而来。\n\nDataset操作也可以是无类型的，通过多种领域专用语言（DSL）方法定义：这些操作非常类似于 R或Python语言中的 数据框架抽象中可用的操作。","text":"前言Dataset 是一种强类型的领域特定对象集合，可以在使用功能或关系操作的同时进行转换。每个 Dataset 也有一个名为 “DataFrame” 的无类型视图，它是 [[Row]] 的 Dataset。Dataset 上可用的操作分为转换和动作: 转换：产生新的 Dataset ；包括 map, filter, select, and aggregate (groupBy).动作：触发计算并返回结果 ；包括 count, show, or 写数据到文件系统。 Dataset是懒加载的，例如：只有提交动作的时候才会触发计算。在内部，Datasets表示一个逻辑计划，它描述生成数据所需的计算。当提交动作时，Spark的查询优化器会优化逻辑计划，并以并行和分布式的方式生成有效执行的物理计划。请使用explain 功能，探索逻辑计划和优化的物理计划。 为了有效地支持特定于领域的对象，需要[[Encoder]]。编码器将特定类型的“T”映射到Spark的内部类型系统。例如：给一个 Person 类，并带有两个属性：name (string) and age (int),编码器告诉Spark在运行时生成代码，序列化 Person 对象为二进制结构。 通常有两种创建Dataset的方法: 使用 SparkSession 上可用的 read 方法读取 Spark 指向的存储系统上的文件。用现存的 Datasets 转换而来。 Dataset操作也可以是无类型的，通过多种领域专用语言（DSL）方法定义：这些操作非常类似于 R或Python语言中的 数据框架抽象中可用的操作。 basic-基础方法toDF123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Converts this strongly typed collection of data to generic Dataframe. In contrast to the * strongly typed objects that Dataset operations work on, a Dataframe returns generic [[Row]] * objects that allow fields to be accessed by ordinal or name. * 将这种强类型的数据集合转换为一般的Dataframe。 * 与Dataset操作所使用的强类型对象相反， * Dataframe返回泛型[[Row]]对象，这些对象允许通过序号或名称访问字段 * * @group basic * @since 1.6.0 */// This is declared with parentheses to prevent the Scala compiler from treating// `ds.toDF(\"1\")` as invoking this toDF and then apply on the returned DataFrame.// 这是用括号声明的，以防止Scala编译器处理ds.toDF(“1”)调用这个toDF，然后在返回的DataFrame上应用。def toDF(): DataFrame = new Dataset[Row](sparkSession, queryExecution, RowEncoder(schema)) /** * Converts this strongly typed collection of data to generic `DataFrame` with columns renamed. * This can be quite convenient in conversion from an RDD of tuples into a `DataFrame` with * meaningful names. For example: * * 将这种强类型的数据集合转换为通用的“DataFrame”，并将列重命名。 * 在将tuple的RDD转换为富有含义的名称的“DataFrame”时，这是非常方便的，如： * * &#123;&#123;&#123; * val rdd: RDD[(Int, String)] = ... * rdd.toDF() // 隐式转换创建了 DataFrame ，列名为： `_1` and `_2` * rdd.toDF(\"id\", \"name\") // 创建了 DataFrame ，列名为： \"id\" and \"name\" * &#125;&#125;&#125; * * @group basic * @since 2.0.0 */@scala.annotation.varargsdef toDF(colNames: String*): DataFrame = &#123; require(schema.size == colNames.size, \"The number of columns doesn't match.\\n\" + s\"Old column names ($&#123;schema.size&#125;): \" + schema.fields.map(_.name).mkString(\", \") + \"\\n\" + s\"New column names ($&#123;colNames.size&#125;): \" + colNames.mkString(\", \")) val newCols = logicalPlan.output.zip(colNames).map &#123; case (oldAttribute, newName) =&gt; Column(oldAttribute).as(newName) &#125; select(newCols: _*)&#125; as123456789101112131415161718192021222324252627282930313233/** * :: Experimental :: * Returns a new Dataset where each record has been mapped on to the specified type. The * method used to map columns depend on the type of `U`: * * 返回一个新的Dataset，其中每个记录都被映射到指定的类型。用于映射列的方法取决于“U”的类型: * * - When `U` is a class, fields for the class will be mapped to columns of the same name * (case sensitivity is determined by `spark.sql.caseSensitive`). * * 当“U”是类时：类的属性将映射到相同名称的列 * * - When `U` is a tuple, the columns will be be mapped by ordinal (i.e. the first column will * be assigned to `_1`). * * 当“U”是元组时：列将由序数映射 （例如，第一列将为 \"_1\"） * * - When `U` is a primitive type (i.e. String, Int, etc), then the first column of the * `DataFrame` will be used. * * 当“U”是 基本类型（如 String，Int等）：然后将使用“DataFrame”的第一列。 * * If the schema of the Dataset does not match the desired `U` type, you can use `select` * along with `alias` or `as` to rearrange or rename as required. * * 如果数据集的模式与所需的“U”类型不匹配，您可以使用“select”和“alias”或“as”来重新排列或重命名。 * * @group basic * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def as[U: Encoder]: Dataset[U] = Dataset[U](sparkSession, logicalPlan) schema12345678/** * Returns the schema of this Dataset. * 返回该Dataset的模版 * * @group basic * @since 1.6.0 */def schema: StructType = queryExecution.analyzed.schema printSchema12345678910/** * Prints the schema to the console in a nice tree format. * * 以一种漂亮的树格式将模式打印到控制台。 * * @group basic * @since 1.6.0 */// scalastyle:off printlndef printSchema(): Unit = println(schema.treeString) explain1234567891011121314151617181920212223242526/** * Prints the plans (logical and physical) to the console for debugging purposes. * * 将计划(逻辑和物理)打印到控制台以进行调试。 * 参数：extended = false 为物理计划 * * @group basic * @since 1.6.0 */def explain(extended: Boolean): Unit = &#123; val explain = ExplainCommand(queryExecution.logical, extended = extended) sparkSession.sessionState.executePlan(explain).executedPlan.executeCollect().foreach &#123; // scalastyle:off println r =&gt; println(r.getString(0)) // scalastyle:on println &#125;&#125; /** * Prints the physical plan to the console for debugging purposes. * 将物理计划打印到控制台以进行调试。 * * @group basic * @since 1.6.0 */def explain(): Unit = explain(extended = false) dtypes12345678910/** * Returns all column names and their data types as an array. * 以数组的形式返回所有列名称和它们的数据类型 * * @group basic * @since 1.6.0 */def dtypes: Array[(String, String)] = schema.fields.map &#123; field =&gt; (field.name, field.dataType.toString)&#125; columns12345678/** * Returns all column names as an array. * 以数组的形式返回 所有列名 * * @group basic * @since 1.6.0 */def columns: Array[String] = schema.fields.map(_.name) isLocal123456789/** * Returns true if the `collect` and `take` methods can be run locally * (without any Spark executors). * 如果`collect` and `take` 方法能在本地运行，则返回true * * @group basic * @since 1.6.0 */def isLocal: Boolean = logicalPlan.isInstanceOf[LocalRelation] checkpoint12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Eagerly checkpoint a Dataset and return the new Dataset. Checkpointing can be used to truncate * the logical plan of this Dataset, which is especially useful in iterative algorithms where the * plan may grow exponentially. It will be saved to files inside the checkpoint * directory set with `SparkContext#setCheckpointDir`. * * 急切地检查一个数据集并返回新的数据集。 * 检查点能用来清除Dataset的逻辑计划，尤其是在可能生成指数级别的迭代算法中尤其有用。 * 将会在检查点目录中保存检查文件。可以在`SparkContext#setCheckpointDir`中设置。 * * @group basic * @since 2.1.0 */@Experimental@InterfaceStability.Evolvingdef checkpoint(): Dataset[T] = checkpoint(eager = true) /** * Returns a checkpointed version of this Dataset. Checkpointing can be used to truncate the * logical plan of this Dataset, which is especially useful in iterative algorithms where the * plan may grow exponentially. It will be saved to files inside the checkpoint * directory set with `SparkContext#setCheckpointDir`. * 返回Dataset 之前检查过的版本。 * 检查点能用来清除Dataset的逻辑计划，尤其是在可能生成指数级别的迭代算法中尤其有用。 * 将会在检查点目录中保存检查文件。可以在`SparkContext#setCheckpointDir`中设置。 * * @group basic * @since 2.1.0 */@Experimental@InterfaceStability.Evolvingdef checkpoint(eager: Boolean): Dataset[T] = &#123; val internalRdd = queryExecution.toRdd.map(_.copy()) internalRdd.checkpoint() if (eager) &#123; internalRdd.count() &#125; val physicalPlan = queryExecution.executedPlan // Takes the first leaf partitioning whenever we see a `PartitioningCollection`. Otherwise the // size of `PartitioningCollection` may grow exponentially for queries involving deep inner // joins. // 每当我们看到“PartitioningCollection”时，就采用第一个叶子分区 // 否则，用于涉及深度内连接的查询，“PartitioningCollection”的大小可能会以指数形式增长。 def firstLeafPartitioning(partitioning: Partitioning): Partitioning = &#123; partitioning match &#123; case p: PartitioningCollection =&gt; firstLeafPartitioning(p.partitionings.head) case p =&gt; p &#125; &#125; val outputPartitioning = firstLeafPartitioning(physicalPlan.outputPartitioning) Dataset.ofRows( sparkSession, LogicalRDD( logicalPlan.output, internalRdd, outputPartitioning, physicalPlan.outputOrdering )(sparkSession)).as[T]&#125; persist1234567891011121314151617181920212223242526272829303132333435/** * Persist this Dataset with the default storage level (`MEMORY_AND_DISK`). * * 持久化。 * 根据默认的 存储级别 (`MEMORY_AND_DISK`) 持久化Dataset。 * * @group basic * @since 1.6.0 */def persist(): this.type = &#123; sparkSession.sharedState.cacheManager.cacheQuery(this) this&#125; /** * Persist this Dataset with the given storage level. * * 根据指定的 存储级别 持久化 Dataset。 * * @param newLevel One of: * `MEMORY_ONLY`, * `MEMORY_AND_DISK`, * `MEMORY_ONLY_SER`, * `MEMORY_AND_DISK_SER`, * `DISK_ONLY`, * `MEMORY_ONLY_2`, 与MEMORY_ONLY的区别是会备份数据到其他节点上 * `MEMORY_AND_DISK_2`, 与MEMORY_AND_DISK的区别是会备份数据到其他节点上 * etc. * @group basic * @since 1.6.0 */def persist(newLevel: StorageLevel): this.type = &#123; sparkSession.sharedState.cacheManager.cacheQuery(this, None, newLevel) this&#125; cache1234567891011/** * Persist this Dataset with the default storage level (`MEMORY_AND_DISK`). * * 持久化。 * 根据默认的 存储级别 (`MEMORY_AND_DISK`) 持久化Dataset。 * 和 persist 一致。 * * @group basic * @since 1.6.0 */def cache(): this.type = persist() storageLevel12345678910111213/** * Get the Dataset's current storage level, or StorageLevel.NONE if not persisted. * * 获取当前Dataset的当前存储级别。如果没有缓存则 StorageLevel.NONE。 * * @group basic * @since 2.1.0 */def storageLevel: StorageLevel = &#123; sparkSession.sharedState.cacheManager.lookupCachedData(this).map &#123; cachedData =&gt; cachedData.cachedRepresentation.storageLevel &#125;.getOrElse(StorageLevel.NONE)&#125; unpersist1234567891011121314151617181920212223242526/** * Mark the Dataset as non-persistent, and remove all blocks for it from memory and disk. * * 解除持久化。 * 将Dataset标记为非持久化，并从内存和磁盘中移除所有的块。 * * @param blocking Whether to block until all blocks are deleted. * 是否阻塞，直到删除所有的块。 * @group basic * @since 1.6.0 */def unpersist(blocking: Boolean): this.type = &#123; sparkSession.sharedState.cacheManager.uncacheQuery(this, blocking) this&#125; /** * Mark the Dataset as non-persistent, and remove all blocks for it from memory and disk. * * 解除持久化。 * 将Dataset标记为非持久化，并从内存和磁盘中移除所有的块。 * * @group basic * @since 1.6.0 */def unpersist(): this.type = unpersist(blocking = false) rdd123456789101112131415/** * Represents the content of the Dataset as an `RDD` of [[T]]. * * 转换为[[T]]的“RDD”，表示Dataset的内容 * * @group basic * @since 1.6.0 */lazy val rdd: RDD[T] = &#123; val objectType = exprEnc.deserializer.dataType val deserialized = CatalystSerde.deserialize[T](logicalPlan) sparkSession.sessionState.executePlan(deserialized).toRdd.mapPartitions &#123; rows =&gt; rows.map(_.get(0, objectType).asInstanceOf[T]) &#125;&#125; toJavaRDD12345678910111213141516171819/** * Returns the content of the Dataset as a `JavaRDD` of [[T]]s. * * 转换为JavaRDD * * @group basic * @since 1.6.0 */def toJavaRDD: JavaRDD[T] = rdd.toJavaRDD() /** * Returns the content of the Dataset as a `JavaRDD` of [[T]]s. * * 转换为JavaRDD * * @group basic * @since 1.6.0 */def javaRDD: JavaRDD[T] = toJavaRDD registerTempTable1234567891011121314/** * Registers this Dataset as a temporary table using the given name. The lifetime of this * temporary table is tied to the [[SparkSession]] that was used to create this Dataset. * * 根据指定的表名，注册临时表。 * 生命周期为[[SparkSession]]的生命周期。 * * @group basic * @since 1.6.0 */@deprecated(\"Use createOrReplaceTempView(viewName) instead.\", \"2.0.0\")def registerTempTable(tableName: String): Unit = &#123; createOrReplaceTempView(tableName)&#125; createTempView123456789101112131415161718192021/** * Creates a local temporary view using the given name. The lifetime of this * temporary view is tied to the [[SparkSession]] that was used to create this Dataset. * * 用指定的名字创建本地临时表。 * 与[[SparkSession]] 同生命周期。 * * Local temporary view is session-scoped. Its lifetime is the lifetime of the session that * created it, i.e. it will be automatically dropped when the session terminates. It's not * tied to any databases, i.e. we can't use `db1.view1` to reference a local temporary view. * * 本地临时表是 session范围内的。当创建它的session停止的时候，该表也随之停止。 * * @throws AnalysisException if the view name already exists * @group basic * @since 2.0.0 */@throws[AnalysisException]def createTempView(viewName: String): Unit = withPlan &#123; createTempViewCommand(viewName, replace = false, global = false)&#125; createOrReplaceTempView123456789101112/** * Creates a local temporary view using the given name. The lifetime of this * temporary view is tied to the [[SparkSession]] that was used to create this Dataset. * * 用指定的名字创建本地临时表。如果已经有了则替换。 * * @group basic * @since 2.0.0 */def createOrReplaceTempView(viewName: String): Unit = withPlan &#123; createTempViewCommand(viewName, replace = true, global = false)&#125; createGlobalTempView1234567891011121314151617181920212223/** * Creates a global temporary view using the given name. The lifetime of this * temporary view is tied to this Spark application. * * 创建全局临时表。 * 生命周期为整个Spark application. * * Global temporary view is cross-session. Its lifetime is the lifetime of the Spark application, * i.e. it will be automatically dropped when the application terminates. It's tied to a system * preserved database `_global_temp`, and we must use the qualified name to refer a global temp * view, e.g. `SELECT * FROM _global_temp.view1`. * * 全局临时表是跨session的。属于 _global_temp 数据库。e.g. `SELECT * FROM _global_temp.view1`. * * @throws AnalysisException if the view name already exists * 如果表已经存在，则报错。 * @group basic * @since 2.1.0 */@throws[AnalysisException]def createGlobalTempView(viewName: String): Unit = withPlan &#123; createTempViewCommand(viewName, replace = false, global = true)&#125; write123456789101112131415/** * Interface for saving the content of the non-streaming Dataset out into external storage. * * 将非流Dataset的内容保存到外部存储中的接口。 * * @group basic * @since 1.6.0 */def write: DataFrameWriter[T] = &#123; if (isStreaming) &#123; logicalPlan.failAnalysis( \"'write' can not be called on streaming Dataset/DataFrame\") &#125; new DataFrameWriter[T](this)&#125; writeStream123456789101112131415161718/** * :: Experimental :: * Interface for saving the content of the streaming Dataset out into external storage. * * 将流Dataset保存在外部存储。 * * @group basic * @since 2.0.0 */@Experimental@InterfaceStability.Evolvingdef writeStream: DataStreamWriter[T] = &#123; if (!isStreaming) &#123; logicalPlan.failAnalysis( \"'writeStream' can be called only on streaming Dataset/DataFrame\") &#125; new DataStreamWriter[T](this)&#125; toJSON1234567891011121314151617181920212223242526272829303132333435/** * Returns the content of the Dataset as a Dataset of JSON strings. * * 将Dataset转换为JSON。 * * @since 2.0.0 */def toJSON: Dataset[String] = &#123; val rowSchema = this.schema val rdd: RDD[String] = queryExecution.toRdd.mapPartitions &#123; iter =&gt; val writer = new CharArrayWriter() // create the Generator without separator inserted between 2 records val gen = new JacksonGenerator(rowSchema, writer) new Iterator[String] &#123; override def hasNext: Boolean = iter.hasNext override def next(): String = &#123; gen.write(iter.next()) gen.flush() val json = writer.toString if (hasNext) &#123; writer.reset() &#125; else &#123; gen.close() &#125; json &#125; &#125; &#125; import sparkSession.implicits.newStringEncoder sparkSession.createDataset(rdd)&#125; inputFiles12345678910111213141516171819202122/** * Returns a best-effort snapshot of the files that compose this Dataset. This method simply * asks each constituent BaseRelation for its respective files and takes the union of all results. * Depending on the source relations, this may not find all input files. Duplicates are removed. * * 返回组成这个Dataset的所有文件的最佳快照。 * 该方法简单地要求每个组件BaseRelation对其各自的文件进行处理，并联合所有结果。 * 基于源关系，应该可以找到所有的输入文件。 * 重复的也会被移除。 * * @group basic * @since 2.0.0 */def inputFiles: Array[String] = &#123; val files: Seq[String] = queryExecution.optimizedPlan.collect &#123; case LogicalRelation(fsBasedRelation: FileRelation, _, _) =&gt; fsBasedRelation.inputFiles case fr: FileRelation =&gt; fr.inputFiles &#125;.flatten files.toSet.toArray&#125; streamingisStreaming123456789101112131415161718/** * Returns true if this Dataset contains one or more sources that continuously * return data as it arrives. A Dataset that reads data from a streaming source * must be executed as a `StreamingQuery` using the `start()` method in * `DataStreamWriter`. Methods that return a single answer, e.g. `count()` or * `collect()`, will throw an [[AnalysisException]] when there is a streaming * source present. * * 如果Dataset包含一个或多个持续返回数据的源，则返回true； * 如果Dataset从streaming源读取数据，则必须像 `StreamingQuery` 一样执行：使用 `DataStreamWriter` 中的 `start()`方法。 * 返回单个值的方法，例如： `count()` or `collect()`，当存在streaming源时，将会抛出[[AnalysisException]]。 * * @group streaming * @since 2.0.0 */@Experimental@InterfaceStability.Evolvingdef isStreaming: Boolean = logicalPlan.isStreaming withWatermark123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * :: Experimental :: 实验性的 * Defines an event time watermark for this [[Dataset]]. A watermark tracks a point in time * before which we assume no more late data is going to arrive. * * 为这个[[Dataset]]定义事件时间水印。 * 我们假设没有更多的晚期数据将到达之前，一个水印跟踪一个时间点。 * * Spark will use this watermark for several purposes: * Spark用水印有几个目的： * - To know when a given time window aggregation can be finalized and thus can be emitted when * using output modes that do not allow updates. * * 可以知道何时完成给定的时间窗口聚合能够完成，因此当使用不允许更新的输出模式时能够被放出。 * - To minimize the amount of state that we need to keep for on-going aggregations. * 为了最小化我们需要持续不断的聚合的状态数量。 * * * The current watermark is computed by looking at the `MAX(eventTime)` seen across * all of the partitions in the query minus a user specified `delayThreshold`. Due to the cost * of coordinating this value across partitions, the actual watermark used is only guaranteed * to be at least `delayThreshold` behind the actual event time. In some cases we may still * process records that arrive more than `delayThreshold` late. * * 当前的水印 = 查看查询中所有分区上看到的`MAX(eventTime)` - 用户指定的`delayThreshold` * 由于在分区之间协调这个值的花销，实际使用的水印只保证在实际事件时间后至少是“delayThreshold”。 * 在某些情况下，我们可能还会处理比“delayThreshold”晚些时候到达的记录。 * * @param eventTime the name of the column that contains the event time of the row. * 包含行的事件时间的列名 * @param delayThreshold the minimum delay to wait to data to arrive late, relative to the latest * record that has been processed in the form of an interval * (e.g. \"1 minute\" or \"5 hours\"). * 等待晚到数据的最少延迟，相对于以间隔形式处理的最新记录 * @group streaming * @since 2.1.0 */@Experimental@InterfaceStability.Evolving// We only accept an existing column name, not a derived column here as a watermark that is// defined on a derived column cannot referenced elsewhere in the plan.// 我们只接受一个现有的列名，而不是作为一个在派生列上定义的水印的派生列，而不能在该计划的其他地方引用。def withWatermark(eventTime: String, delayThreshold: String): Dataset[T] = withTypedPlan &#123; val parsedDelay = Option(CalendarInterval.fromString(\"interval \" + delayThreshold)) .getOrElse(throw new AnalysisException(s\"Unable to parse time delay '$delayThreshold'\")) EventTimeWatermark(UnresolvedAttribute(eventTime), parsedDelay, logicalPlan)&#125; actionshow123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * Displays the Dataset in a tabular form. Strings more than 20 characters will be truncated, * and all cells will be aligned right. For example: * * 以表格形式显示数据集。 * 字符串超过20个字符将被截断， * 所有单元格将被对齐。 * &#123;&#123;&#123; * year month AVG('Adj Close) MAX('Adj Close) * 1980 12 0.503218 0.595103 * 1981 01 0.523289 0.570307 * 1982 02 0.436504 0.475256 * 1983 03 0.410516 0.442194 * 1984 04 0.450090 0.483521 * &#125;&#125;&#125; * * @param numRows Number of rows to show 要显示的行数 * @group action * @since 1.6.0 */def show(numRows: Int): Unit = show(numRows, truncate = true) /** * Displays the top 20 rows of Dataset in a tabular form. Strings more than 20 characters * will be truncated, and all cells will be aligned right. * 显示头20行 * * @group action * @since 1.6.0 */def show(): Unit = show(20)/** * Displays the top 20 rows of Dataset in a tabular form. * 显示头20行 * * @param truncate Whether truncate long strings. If true, strings more than 20 characters will * be truncated and all cells will be aligned right * 是否截断长字符串。如果 true：超过20个字符就会被截断 * @group action * @since 1.6.0 */def show(truncate: Boolean): Unit = show(20, truncate)/** * Displays the Dataset in a tabular form. For example: * &#123;&#123;&#123; * year month AVG('Adj Close) MAX('Adj Close) * 1980 12 0.503218 0.595103 * 1981 01 0.523289 0.570307 * 1982 02 0.436504 0.475256 * 1983 03 0.410516 0.442194 * 1984 04 0.450090 0.483521 * &#125;&#125;&#125; * * @param numRows Number of rows to show 显示的行数 * @param truncate Whether truncate long strings. If true, strings more than 20 characters will * be truncated and all cells will be aligned right * 是否截断长字符串 * @group action * @since 1.6.0 */// scalastyle:off printlndef show(numRows: Int, truncate: Boolean): Unit = if (truncate) &#123; println(showString(numRows, truncate = 20))&#125; else &#123; println(showString(numRows, truncate = 0))&#125;// scalastyle:on println/** * Displays the Dataset in a tabular form. For example: * &#123;&#123;&#123; * year month AVG('Adj Close) MAX('Adj Close) * 1980 12 0.503218 0.595103 * 1981 01 0.523289 0.570307 * 1982 02 0.436504 0.475256 * 1983 03 0.410516 0.442194 * 1984 04 0.450090 0.483521 * &#125;&#125;&#125; * * @param numRows Number of rows to show * @param truncate If set to more than 0, truncates strings to `truncate` characters and * all cells will be aligned right. * 设置 触发截断字符串的阈值 * @group action * @since 1.6.0 */// scalastyle:off printlndef show(numRows: Int, truncate: Int): Unit = println(showString(numRows, truncate)) reduce1234567891011121314151617181920212223242526272829/** * :: Experimental :: * (Scala-specific) * Reduces the elements of this Dataset using the specified binary function. The given `func` * must be commutative and associative or the result may be non-deterministic. * * 使用指定的二进制函数减少这个数据集的元素。给定的“func”必须是可交换的和关联的，否则结果可能是不确定性的。 * * @group action * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef reduce(func: (T, T) =&gt; T): T = rdd.reduce(func)/** * :: Experimental :: * (Java-specific) * Reduces the elements of this Dataset using the specified binary function. The given `func` * must be commutative and associative or the result may be non-deterministic. * * 使用指定的二进制函数减少这个数据集的元素。给定的“func”必须是可交换的和关联的，否则结果可能是不确定性的。 * * @group action * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef reduce(func: ReduceFunction[T]): T = reduce(func.call(_, _)) describe123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Computes statistics for numeric and string columns, including count, mean, stddev, min, and * max. If no columns are given, this function computes statistics for all numerical or string * columns. * * 计算数字和字符串列的统计数据，包括count、mean、stddev、min和max。 * 如果没有给出任何列，该函数计算所有数值或字符串列的统计信息。 * * This function is meant for exploratory data analysis, as we make no guarantee about the * backward compatibility of the schema of the resulting Dataset. If you want to * programmatically compute summary statistics, use the `agg` function instead. * * 这个函数用于探索性的数据分析，因为我们不能保证生成数据集的模式的向后兼容性。 * 如果您想通过编程计算汇总统计信息，可以使用“agg”函数。 * * &#123;&#123;&#123; * ds.describe(\"age\", \"height\").show() * * // output: * // summary age height * // count 10.0 10.0 * // mean 53.3 178.05 * // stddev 11.6 15.7 * // min 18.0 163.0 * // max 92.0 192.0 * &#125;&#125;&#125; * * @group action * @since 1.6.0 */ @scala.annotation.varargs def describe(cols: String*): DataFrame = withPlan &#123; // The list of summary statistics to compute, in the form of expressions. val statistics = List[(String, Expression =&gt; Expression)]( \"count\" -&gt; ((child: Expression) =&gt; Count(child).toAggregateExpression()), \"mean\" -&gt; ((child: Expression) =&gt; Average(child).toAggregateExpression()), \"stddev\" -&gt; ((child: Expression) =&gt; StddevSamp(child).toAggregateExpression()), \"min\" -&gt; ((child: Expression) =&gt; Min(child).toAggregateExpression()), \"max\" -&gt; ((child: Expression) =&gt; Max(child).toAggregateExpression())) val outputCols = (if (cols.isEmpty) aggregatableColumns.map(usePrettyExpression(_).sql) else cols).toList val ret: Seq[Row] = if (outputCols.nonEmpty) &#123; val aggExprs = statistics.flatMap &#123; case (_, colToAgg) =&gt; outputCols.map(c =&gt; Column(Cast(colToAgg(Column(c).expr), StringType)).as(c)) &#125; val row = groupBy().agg(aggExprs.head, aggExprs.tail: _*).head().toSeq // Pivot the data so each summary is one row row.grouped(outputCols.size).toSeq.zip(statistics).map &#123; case (aggregation, (statistic, _)) =&gt; Row(statistic :: aggregation.toList: _*) &#125; &#125; else &#123; // If there are no output columns, just output a single column that contains the stats. statistics.map &#123; case (name, _) =&gt; Row(name) &#125; &#125; // All columns are string type val schema = StructType( StructField(\"summary\", StringType) :: outputCols.map(StructField(_, StringType))).toAttributes // `toArray` forces materialization to make the seq serializable LocalRelation.fromExternalRows(schema, ret.toArray.toSeq) &#125; head123456789101112131415161718192021222324/** * Returns the first `n` rows. * * 返回前n行 * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 仅适用于结果很少的时候使用，因为会将结果加载进内存中 * @group action * @since 1.6.0 */def head(n: Int): Array[T] = withTypedCallback(\"head\", limit(n)) &#123; df =&gt; df.collect(needCallback = false)&#125;/** * Returns the first row. * * 返回第一行（默认1） * * @group action * @since 1.6.0 */def head(): T = head(1).head first123456789/** * Returns the first row. Alias for head(). * * 返回第一行 ，与head()一样 * * @group action * @since 1.6.0 */def first(): T = head() foreach12345678910111213141516171819202122/** * Applies a function `f` to all rows. * * 对所有行应用函数f。 * * @group action * @since 1.6.0 */def foreach(f: T =&gt; Unit): Unit = withNewExecutionId &#123; rdd.foreach(f)&#125;/** * (Java-specific) * Runs `func` on each element of this Dataset. * * 在这个数据集的每个元素上运行“func”。 * * @group action * @since 1.6.0 */def foreach(func: ForeachFunction[T]): Unit = foreach(func.call(_)) foreachPartition1234567891011121314151617181920212223/** * Applies a function `f` to each partition of this Dataset. * * 对这个数据集的每个分区应用一个函数f。 * * @group action * @since 1.6.0 */def foreachPartition(f: Iterator[T] =&gt; Unit): Unit = withNewExecutionId &#123; rdd.foreachPartition(f)&#125;/** * (Java-specific) * Runs `func` on each partition of this Dataset. * * 对这个数据集的每个分区应用一个函数f。 * * @group action * @since 1.6.0 */def foreachPartition(func: ForeachPartitionFunction[T]): Unit = foreachPartition(it =&gt; func.call(it.asJava)) take123456789101112131415/** * Returns the first `n` rows in the Dataset. * * 返回数据集中的前“n”行。 * 同head(n) * * Running take requires moving data into the application's driver process, and doing so with * a very large `n` can crash the driver process with OutOfMemoryError. * * take在driver端执行，n太大会造成oom * * @group action * @since 1.6.0 */def take(n: Int): Array[T] = head(n) takeAsList1234567891011121314/** * Returns the first `n` rows in the Dataset as a list. * * 以List形式返回 前n行 * * Running take requires moving data into the application's driver process, and doing so with * a very large `n` can crash the driver process with OutOfMemoryError. * * take在driver端执行，n太大会造成oom * * @group action * @since 1.6.0 */def takeAsList(n: Int): java.util.List[T] = java.util.Arrays.asList(take(n): _*) collect12345678910111213141516/** * Returns an array that contains all of [[Row]]s in this Dataset. * * 返回包含所有Row的 一个数组 * * Running collect requires moving all the data into the application's driver process, and * doing so on a very large dataset can crash the driver process with OutOfMemoryError. * * 会将所有数据移动到driver，所以可能会造成oom * * For Java API, use [[collectAsList]]. * * @group action * @since 1.6.0 */def collect(): Array[T] = collect(needCallback = true) collectAsList12345678910111213141516171819/** * Returns a Java list that contains all of [[Row]]s in this Dataset. * * 返回包含所有Row的一个Java List * * Running collect requires moving all the data into the application's driver process, and * doing so on a very large dataset can crash the driver process with OutOfMemoryError. * * 会将所有数据移动到driver，所以可能会造成oom * * @group action * @since 1.6.0 */def collectAsList(): java.util.List[T] = withCallback(\"collectAsList\", toDF()) &#123; _ =&gt; withNewExecutionId &#123; val values = queryExecution.executedPlan.executeCollect().map(boundEnc.fromRow) java.util.Arrays.asList(values: _*) &#125;&#125; toLocalIterator12345678910111213141516171819202122/** * Return an iterator that contains all of [[Row]]s in this Dataset. * * 返回包含所有Row的一个迭代器 * * The iterator will consume as much memory as the largest partition in this Dataset. * * 迭代器将消耗与此数据集中最大的分区一样多的内存。 * * @note this results in multiple Spark jobs, and if the input Dataset is the result * of a wide transformation (e.g. join with different partitioners), to avoid * recomputing the input Dataset should be cached first. * 这将导致多个Spark作业，如果输入数据集是宽依赖转换的结果(例如，与不同的分区连接)， * 那么为了避免重新计算输入数据，应该首先缓存输入数据集。 * @group action * @since 2.0.0 */def toLocalIterator(): java.util.Iterator[T] = withCallback(\"toLocalIterator\", toDF()) &#123; _ =&gt; withNewExecutionId &#123; queryExecution.executedPlan.executeToIterator().map(boundEnc.fromRow).asJava &#125;&#125; count1234567891011/** * Returns the number of rows in the Dataset. * * 返回总行数 * * @group action * @since 1.6.0 */def count(): Long = withCallback(\"count\", groupBy().count()) &#123; df =&gt; df.collect(needCallback = false).head.getLong(0)&#125; untypedrel-无类型转换na123456789101112/** * Returns a [[DataFrameNaFunctions]] for working with missing data. * 返回一个用于处理丢失数据的[[DataFrameNaFunctions]]。 * &#123;&#123;&#123; * // Dropping rows containing any null values. 删除包含任何null 值的行 * ds.na.drop() * &#125;&#125;&#125; * * @group untypedrel * @since 1.6.0 */def na: DataFrameNaFunctions = new DataFrameNaFunctions(toDF()) stat123456789101112/** * Returns a [[DataFrameStatFunctions]] for working statistic functions support. * 返回用于支持统计功能的[[DataFrameStatFunctions]]。 * &#123;&#123;&#123; * // Finding frequent items in column with name 'a'. 查询列名为\"a\"中的频繁数据。 * ds.stat.freqItems(Seq(\"a\")) * &#125;&#125;&#125; * * @group untypedrel * @since 1.6.0 */def stat: DataFrameStatFunctions = new DataFrameStatFunctions(toDF()) join123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180/** * Join with another `DataFrame`. * 和 另一个 `DataFrame` jion * * Behaves as an INNER JOIN and requires a subsequent join predicate. * 作为一个内部连接，并需要一个后续的连接谓词。 * * @param right Right side of the join operation. join操作的右侧 * @group untypedrel * @since 2.0.0 */ def join(right: Dataset[_]): DataFrame = withPlan &#123; Join(logicalPlan, right.logicalPlan, joinType = Inner, None) &#125; /** * Inner equi-join with another `DataFrame` using the given column. * 给定列名的内部等值连接 * * Different from other join functions, the join column will only appear once in the output, * i.e. similar to SQL's `JOIN USING` syntax. * * &#123;&#123;&#123; * // Joining df1 and df2 using the column \"user_id\" 用\"user_id\" 连接 df1 和df2 * df1.join(df2, \"user_id\") * &#125;&#125;&#125; * * @param right Right side of the join operation. join连接右侧 * @param usingColumn Name of the column to join on. This column must exist on both sides. * 列名。必须在两边都存在 * @note If you perform a self-join using this function without aliasing the input * `DataFrame`s, you will NOT be able to reference any columns after the join, since * there is no way to disambiguate which side of the join you would like to reference. * 自连接的时候，请指定 表别名。不然干不了事 * @group untypedrel * @since 2.0.0 */ def join(right: Dataset[_], usingColumn: String): DataFrame = &#123; join(right, Seq(usingColumn)) &#125; /** * Inner equi-join with another `DataFrame` using the given columns. * 根据指定多个列进行join * * Different from other join functions, the join columns will only appear once in the output, * i.e. similar to SQL's `JOIN USING` syntax. * * &#123;&#123;&#123; * // Joining df1 and df2 using the columns \"user_id\" and \"user_name\" * df1.join(df2, Seq(\"user_id\", \"user_name\")) * &#125;&#125;&#125; * * @param right Right side of the join operation. * @param usingColumns Names of the columns to join on. This columns must exist on both sides. * @note If you perform a self-join using this function without aliasing the input * `DataFrame`s, you will NOT be able to reference any columns after the join, since * there is no way to disambiguate which side of the join you would like to reference. * @group untypedrel * @since 2.0.0 */ def join(right: Dataset[_], usingColumns: Seq[String]): DataFrame = &#123; join(right, usingColumns, \"inner\") &#125; /** * Equi-join with another `DataFrame` using the given columns. * * Different from other join functions, the join columns will only appear once in the output, * i.e. similar to SQL's `JOIN USING` syntax. * * @param right Right side of the join operation. * @param usingColumns Names of the columns to join on. This columns must exist on both sides. * @param joinType One of: `inner`, `outer`, `left_outer`, `right_outer`, `leftsemi`. * 连接类型：内连接，外连接，左外连接，右外连接，左内连接 * @note If you perform a self-join using this function without aliasing the input * `DataFrame`s, you will NOT be able to reference any columns after the join, since * there is no way to disambiguate which side of the join you would like to reference. * @group untypedrel * @since 2.0.0 */ def join(right: Dataset[_], usingColumns: Seq[String], joinType: String): DataFrame = &#123; // Analyze the self join. The assumption is that the analyzer will disambiguate left vs right // by creating a new instance for one of the branch. // 自连接的时候，为其中一个分支创建一个新实例来消除左vs右的歧义。 val joined = sparkSession.sessionState.executePlan( Join(logicalPlan, right.logicalPlan, joinType = JoinType(joinType), None)) .analyzed.asInstanceOf[Join] withPlan &#123; Join( joined.left, joined.right, UsingJoin(JoinType(joinType), usingColumns), None) &#125; &#125; /** * Inner join with another `DataFrame`, using the given join expression. * 用给定的表达式进行join * &#123;&#123;&#123; * // The following two are equivalent: * df1.join(df2, $\"df1Key\" === $\"df2Key\") * df1.join(df2).where($\"df1Key\" === $\"df2Key\") * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ def join(right: Dataset[_], joinExprs: Column): DataFrame = join(right, joinExprs, \"inner\") /** * Join with another `DataFrame`, using the given join expression. The following performs * a full outer join between `df1` and `df2`. * * &#123;&#123;&#123; * // Scala: * import org.apache.spark.sql.functions._ * df1.join(df2, $\"df1Key\" === $\"df2Key\", \"outer\") * * // Java: * import static org.apache.spark.sql.functions.*; * df1.join(df2, col(\"df1Key\").equalTo(col(\"df2Key\")), \"outer\"); * &#125;&#125;&#125; * * @param right Right side of the join. * @param joinExprs Join expression. * @param joinType One of: `inner`, `outer`, `left_outer`, `right_outer`, `leftsemi`. * @group untypedrel * @since 2.0.0 */ def join(right: Dataset[_], joinExprs: Column, joinType: String): DataFrame = &#123; // Note that in this function, we introduce a hack in the case of self-join to automatically // resolve ambiguous join conditions into ones that might make sense [SPARK-6231]. // Consider this case: df.join(df, df(\"key\") === df(\"key\")) // Since df(\"key\") === df(\"key\") is a trivially true condition, this actually becomes a // cartesian join. However, most likely users expect to perform a self join using \"key\". // With that assumption, this hack turns the trivially true condition into equality on join // keys that are resolved to both sides. // Trigger analysis so in the case of self-join, the analyzer will clone the plan. // After the cloning, left and right side will have distinct expression ids. // 针对自连接的优化：正常情况下，自连接如果使用 df.join(df, df(\"key\") === df(\"key\")) // 会造成 笛卡尔积 // 这种情况下，分析器会 克隆计划，克隆完成后，左右两边则有不同的 id val plan = withPlan( Join(logicalPlan, right.logicalPlan, JoinType(joinType), Some(joinExprs.expr))) .queryExecution.analyzed.asInstanceOf[Join] // If auto self join alias is disabled, return the plan. if (!sparkSession.sessionState.conf.dataFrameSelfJoinAutoResolveAmbiguity) &#123; return withPlan(plan) &#125; // If left/right have no output set intersection, return the plan. val lanalyzed = withPlan(this.logicalPlan).queryExecution.analyzed val ranalyzed = withPlan(right.logicalPlan).queryExecution.analyzed if (lanalyzed.outputSet.intersect(ranalyzed.outputSet).isEmpty) &#123; return withPlan(plan) &#125; // Otherwise, find the trivially true predicates and automatically resolves them to both sides. // By the time we get here, since we have already run analysis, all attributes should've been // resolved and become AttributeReference. val cond = plan.condition.map &#123; _.transform &#123; case catalyst.expressions.EqualTo(a: AttributeReference, b: AttributeReference) if a.sameRef(b) =&gt; catalyst.expressions.EqualTo( withPlan(plan.left).resolve(a.name), withPlan(plan.right).resolve(b.name)) &#125; &#125; withPlan &#123; plan.copy(condition = cond) &#125; &#125; crossJoin12345678910111213/** * Explicit cartesian join with another `DataFrame`. * 显式笛卡尔积join * * @param right Right side of the join operation. * @note Cartesian joins are very expensive without an extra filter that can be pushed down. * 如果没有额外的过滤器，笛卡尔连接非常昂贵。 * @group untypedrel * @since 2.1.0 */def crossJoin(right: Dataset[_]): DataFrame = withPlan &#123; Join(logicalPlan, right.logicalPlan, joinType = Cross, None)&#125; apply123456789101112/** * Selects column based on the column name and return it as a [[Column]]. * * 选择基于列名的列，并将其作为[[Column]]返回。 * * @note The column name can also reference to a nested column like `a.b`. * * 列名也可以引用像“a.b”这样的嵌套列。 * @group untypedrel * @since 2.0.0 */def apply(colName: String): Column = col(colName) col123456789101112131415161718/** * Selects column based on the column name and return it as a [[Column]]. * * 选择基于列名的列，并将其作为[[Column]]返回。 * * @note The column name can also reference to a nested column like `a.b`. * * 列名也可以引用像“a.b”这样的嵌套列。 * @group untypedrel * @since 2.0.0 */def col(colName: String): Column = colName match &#123; case \"*\" =&gt; Column(ResolvedStar(queryExecution.analyzed.output)) case _ =&gt; val expr = resolve(colName) Column(expr)&#125; select12345678910111213141516171819202122232425262728293031/** * Selects a set of column based expressions. * &#123;&#123;&#123; * ds.select($\"colA\", $\"colB\" + 1) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */@scala.annotation.varargsdef select(cols: Column*): DataFrame = withPlan &#123; Project(cols.map(_.named), logicalPlan)&#125;/** * Selects a set of columns. This is a variant of `select` that can only select * existing columns using column names (i.e. cannot construct expressions). * * 只能是已经存在的列名 * * &#123;&#123;&#123; * // The following two are equivalent: * ds.select(\"colA\", \"colB\") * ds.select($\"colA\", $\"colB\") * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */@scala.annotation.varargsdef select(col: String, cols: String*): DataFrame = select((col +: cols).map(Column(_)): _*) selectExpr12345678910111213141516171819202122/** * Selects a set of SQL expressions. This is a variant of `select` that accepts * SQL expressions. * * 接受SQL表达式 * * &#123;&#123;&#123; * // The following are equivalent: * 以下是等价的: * ds.selectExpr(\"colA\", \"colB as newName\", \"abs(colC)\") * ds.select(expr(\"colA\"), expr(\"colB as newName\"), expr(\"abs(colC)\")) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */@scala.annotation.varargsdef selectExpr(exprs: String*): DataFrame = &#123; select(exprs.map &#123; expr =&gt; Column(sparkSession.sessionState.sqlParser.parseExpression(expr)) &#125;: _*)&#125; groupBy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Groups the Dataset using the specified columns, so we can run aggregation on them. See * [[RelationalGroupedDataset]] for all the available aggregate functions. * * 使用指定的列对数据集进行分组，这样我们就可以对它们进行聚合。 * 查看[[RelationalGroupedDataset]]为所有可用的聚合函数。 * * * &#123;&#123;&#123; * // Compute the average for all numeric columns grouped by department. * * 计算按部门分组的所有数字列的平均值。 * * ds.groupBy($\"department\").avg() * * // Compute the max age and average salary, grouped by department and gender. * ds.groupBy($\"department\", $\"gender\").agg(Map( * \"salary\" -&gt; \"avg\", * \"age\" -&gt; \"max\" * )) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */@scala.annotation.varargsdef groupBy(cols: Column*): RelationalGroupedDataset = &#123; RelationalGroupedDataset(toDF(), cols.map(_.expr), RelationalGroupedDataset.GroupByType)&#125; /** * Groups the Dataset using the specified columns, so that we can run aggregation on them. * See [[RelationalGroupedDataset]] for all the available aggregate functions. * * This is a variant of groupBy that can only group by existing columns using column names * (i.e. cannot construct expressions). * * &#123;&#123;&#123; * // Compute the average for all numeric columns grouped by department. * ds.groupBy(\"department\").avg() * * // Compute the max age and average salary, grouped by department and gender. * ds.groupBy($\"department\", $\"gender\").agg(Map( * \"salary\" -&gt; \"avg\", * \"age\" -&gt; \"max\" * )) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */@scala.annotation.varargsdef groupBy(col1: String, cols: String*): RelationalGroupedDataset = &#123; val colNames: Seq[String] = col1 +: cols RelationalGroupedDataset( toDF(), colNames.map(colName =&gt; resolve(colName)), RelationalGroupedDataset.GroupByType)&#125; rollup1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Create a multi-dimensional rollup for the current Dataset using the specified columns, * so we can run aggregation on them. * See [[RelationalGroupedDataset]] for all the available aggregate functions. * * 使用指定的列为当前数据集创建多维的汇总，因此我们可以在它们上运行聚合。 * * * &#123;&#123;&#123; * // Compute the average for all numeric columns rolluped by department and group. * * 汇总后 求平均值 * * ds.rollup($\"department\", $\"group\").avg() * * // Compute the max age and average salary, rolluped by department and gender. * ds.rollup($\"department\", $\"gender\").agg(Map( * \"salary\" -&gt; \"avg\", * \"age\" -&gt; \"max\" * )) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ @scala.annotation.varargs def rollup(cols: Column*): RelationalGroupedDataset = &#123; RelationalGroupedDataset(toDF(), cols.map(_.expr), RelationalGroupedDataset.RollupType) &#125; /** * Create a multi-dimensional rollup for the current Dataset using the specified columns, * so we can run aggregation on them. * See [[RelationalGroupedDataset]] for all the available aggregate functions. * * 使用指定的列为当前数据集创建多维的rollup，因此我们可以在它们上运行聚合。 * rollup可以实现 从右到左一次递减的多级统计，显示统计某一层次结构的聚合 * 例如 rollup(a,b,c,d) =结果=&gt; (a,b,c,d),(a,b,c),(a,b),a * * This is a variant of rollup that can only group by existing columns using column names * (i.e. cannot construct expressions). * * &#123;&#123;&#123; * // Compute the average for all numeric columns rolluped by department and group. * ds.rollup(\"department\", \"group\").avg() * * // Compute the max age and average salary, rolluped by department and gender. * ds.rollup($\"department\", $\"gender\").agg(Map( * \"salary\" -&gt; \"avg\", * \"age\" -&gt; \"max\" * )) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ @scala.annotation.varargs def rollup(col1: String, cols: String*): RelationalGroupedDataset = &#123; val colNames: Seq[String] = col1 +: cols RelationalGroupedDataset( toDF(), colNames.map(colName =&gt; resolve(colName)), RelationalGroupedDataset.RollupType) &#125; cube123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Create a multi-dimensional cube for the current Dataset using the specified columns, * so we can run aggregation on them. * See [[RelationalGroupedDataset]] for all the available aggregate functions. * * 使用指定的列为当前数据集创建多维数据集，因此我们可以在它们上运行聚合。 * * * &#123;&#123;&#123; * // Compute the average for all numeric columns cubed by department and group. * ds.cube($\"department\", $\"group\").avg() * * // Compute the max age and average salary, cubed by department and gender. * ds.cube($\"department\", $\"gender\").agg(Map( * \"salary\" -&gt; \"avg\", * \"age\" -&gt; \"max\" * )) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ @scala.annotation.varargs def cube(cols: Column*): RelationalGroupedDataset = &#123; RelationalGroupedDataset(toDF(), cols.map(_.expr), RelationalGroupedDataset.CubeType) &#125; /** * Create a multi-dimensional cube for the current Dataset using the specified columns, * so we can run aggregation on them. * See [[RelationalGroupedDataset]] for all the available aggregate functions. * * 魔方 例如：cube(a,b,c) =结果=&gt; (a,b),(a,c),a,(b,c),b,c 结果为所有的维度 * 使用指定的列为当前数据集创建多维多维数据集，因此我们可以在它们上运行聚合。 * * This is a variant of cube that can only group by existing columns using column names * (i.e. cannot construct expressions). * * 这是一个多维数据集的变体，它只能通过使用列名的现有列来分组 * * &#123;&#123;&#123; * // Compute the average for all numeric columns cubed by department and group. * ds.cube(\"department\", \"group\").avg() * * // Compute the max age and average salary, cubed by department and gender. * ds.cube($\"department\", $\"gender\").agg(Map( * \"salary\" -&gt; \"avg\", * \"age\" -&gt; \"max\" * )) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ @scala.annotation.varargs def cube(col1: String, cols: String*): RelationalGroupedDataset = &#123; val colNames: Seq[String] = col1 +: cols RelationalGroupedDataset( toDF(), colNames.map(colName =&gt; resolve(colName)), RelationalGroupedDataset.CubeType) &#125; agg123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * (Scala-specific) Aggregates on the entire Dataset without groups. * 对整个数据集进行聚合，无需分组。 * &#123;&#123;&#123; * // ds.agg(...) is a shorthand for ds.groupBy().agg(...) * ds.agg(\"age\" -&gt; \"max\", \"salary\" -&gt; \"avg\") * ds.groupBy().agg(\"age\" -&gt; \"max\", \"salary\" -&gt; \"avg\") * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ def agg(aggExpr: (String, String), aggExprs: (String, String)*): DataFrame = &#123; groupBy().agg(aggExpr, aggExprs: _*) &#125; /** * (Scala-specific) Aggregates on the entire Dataset without groups. * 对整个数据集进行聚合，无需分组。 * * &#123;&#123;&#123; * // ds.agg(...) is a shorthand for ds.groupBy().agg(...) * ds.agg(Map(\"age\" -&gt; \"max\", \"salary\" -&gt; \"avg\")) * ds.groupBy().agg(Map(\"age\" -&gt; \"max\", \"salary\" -&gt; \"avg\")) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ def agg(exprs: Map[String, String]): DataFrame = groupBy().agg(exprs) /** * (Java-specific) Aggregates on the entire Dataset without groups. * * 对整个数据集进行聚合，无需分组。 * * &#123;&#123;&#123; * // ds.agg(...) is a shorthand for ds.groupBy().agg(...) * ds.agg(Map(\"age\" -&gt; \"max\", \"salary\" -&gt; \"avg\")) * ds.groupBy().agg(Map(\"age\" -&gt; \"max\", \"salary\" -&gt; \"avg\")) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ def agg(exprs: java.util.Map[String, String]): DataFrame = groupBy().agg(exprs) /** * Aggregates on the entire Dataset without groups. * * 对整个数据集进行聚合，无需分组。 * * &#123;&#123;&#123; * // ds.agg(...) is a shorthand for ds.groupBy().agg(...) * ds.agg(max($\"age\"), avg($\"salary\")) * ds.groupBy().agg(max($\"age\"), avg($\"salary\")) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */ @scala.annotation.varargs def agg(expr: Column, exprs: Column*): DataFrame = groupBy().agg(expr, exprs: _*) explode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * (Scala-specific) Returns a new Dataset where each row has been expanded to zero or more * rows by the provided function. This is similar to a `LATERAL VIEW` in HiveQL. The columns of * the input row are implicitly joined with each row that is output by the function. * * 根据提供的方法，该数据集的每一行都被扩展为零个或更多的行，返回一个新的数据集。 * 这类似于HiveQL的“LATERAL VIEW”。 * 输入行的列 隐式地加入了由函数输出的每一行。 * * Given that this is deprecated, as an alternative, you can explode columns either using * `functions.explode()` or `flatMap()`. The following example uses these alternatives to count * the number of books that contain a given word: * * 考虑到这已经被弃用，作为替代，您可以使用“functions.explode()”或“flatMap()”来引爆列。 * 下面的示例使用这些替代方法来计算包含给定单词的图书的数量: * * &#123;&#123;&#123; * case class Book(title: String, words: String) * val ds: Dataset[Book] * * val allWords = ds.select('title, explode(split('words, \" \")).as(\"word\")) * * val bookCountPerWord = allWords.groupBy(\"word\").agg(countDistinct(\"title\")) * &#125;&#125;&#125; * * Using `flatMap()` this can similarly be exploded as: * * &#123;&#123;&#123; * ds.flatMap(_.words.split(\" \")) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 已经过时，用 flatMap() 或 functions.explode() 代替 */@deprecated(\"use flatMap() or select() with functions.explode() instead\", \"2.0.0\")def explode[A &lt;: Product : TypeTag](input: Column*)(f: Row =&gt; TraversableOnce[A]): DataFrame = &#123; val elementSchema = ScalaReflection.schemaFor[A].dataType.asInstanceOf[StructType] val convert = CatalystTypeConverters.createToCatalystConverter(elementSchema) val rowFunction = f.andThen(_.map(convert(_).asInstanceOf[InternalRow])) val generator = UserDefinedGenerator(elementSchema, rowFunction, input.map(_.expr)) withPlan &#123; Generate(generator, join = true, outer = false, qualifier = None, generatorOutput = Nil, logicalPlan) &#125;&#125;/** * (Scala-specific) Returns a new Dataset where a single column has been expanded to zero * or more rows by the provided function. This is similar to a `LATERAL VIEW` in HiveQL. All * columns of the input row are implicitly joined with each value that is output by the function. * * Given that this is deprecated, as an alternative, you can explode columns either using * `functions.explode()`: * * &#123;&#123;&#123; * ds.select(explode(split('words, \" \")).as(\"word\")) * &#125;&#125;&#125; * * or `flatMap()`: * * &#123;&#123;&#123; * ds.flatMap(_.words.split(\" \")) * &#125;&#125;&#125; * * @group untypedrel * @since 2.0.0 */@deprecated(\"use flatMap() or select() with functions.explode() instead\", \"2.0.0\")def explode[A, B: TypeTag](inputColumn: String, outputColumn: String)(f: A =&gt; TraversableOnce[B]): DataFrame = &#123; val dataType = ScalaReflection.schemaFor[B].dataType val attributes = AttributeReference(outputColumn, dataType)() :: Nil // TODO handle the metadata? val elementSchema = attributes.toStructType def rowFunction(row: Row): TraversableOnce[InternalRow] = &#123; val convert = CatalystTypeConverters.createToCatalystConverter(dataType) f(row(0).asInstanceOf[A]).map(o =&gt; InternalRow(convert(o))) &#125; val generator = UserDefinedGenerator(elementSchema, rowFunction, apply(inputColumn).expr :: Nil) withPlan &#123; Generate(generator, join = true, outer = false, qualifier = None, generatorOutput = Nil, logicalPlan) &#125;&#125; withColumn1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Returns a new Dataset by adding a column or replacing the existing column that has * the same name. * 通过添加一个列或替换具有相同名称的现有列返回新的数据集。 * * @group untypedrel * @since 2.0.0 */def withColumn(colName: String, col: Column): DataFrame = &#123; val resolver = sparkSession.sessionState.analyzer.resolver val output = queryExecution.analyzed.output val shouldReplace = output.exists(f =&gt; resolver(f.name, colName)) if (shouldReplace) &#123; val columns = output.map &#123; field =&gt; if (resolver(field.name, colName)) &#123; col.as(colName) &#125; else &#123; Column(field) &#125; &#125; select(columns: _*) &#125; else &#123; select(Column(\"*\"), col.as(colName)) &#125;&#125;/** * Returns a new Dataset by adding a column with metadata. * 通过添加带有元数据的列返回一个新的数据集。 */private[spark] def withColumn(colName: String, col: Column, metadata: Metadata): DataFrame = &#123; val resolver = sparkSession.sessionState.analyzer.resolver val output = queryExecution.analyzed.output val shouldReplace = output.exists(f =&gt; resolver(f.name, colName)) if (shouldReplace) &#123; val columns = output.map &#123; field =&gt; if (resolver(field.name, colName)) &#123; col.as(colName, metadata) &#125; else &#123; Column(field) &#125; &#125; select(columns: _*) &#125; else &#123; select(Column(\"*\"), col.as(colName, metadata)) &#125;&#125; withColumnRenamed1234567891011121314151617181920212223242526/** * Returns a new Dataset with a column renamed. * This is a no-op if schema doesn't contain existingName. * 返回一个重命名的列的新数据集。 * 如果模式不包含存在名称，那么这是不操作的。 * * @group untypedrel * @since 2.0.0 */def withColumnRenamed(existingName: String, newName: String): DataFrame = &#123; val resolver = sparkSession.sessionState.analyzer.resolver val output = queryExecution.analyzed.output val shouldRename = output.exists(f =&gt; resolver(f.name, existingName)) if (shouldRename) &#123; val columns = output.map &#123; col =&gt; if (resolver(col.name, existingName)) &#123; Column(col).as(newName) &#125; else &#123; Column(col) &#125; &#125; select(columns: _*) &#125; else &#123; toDF() &#125;&#125; drop1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Returns a new Dataset with a column dropped. This is a no-op if schema doesn't contain * column name. * * 返回删除指定列之后的新Dataset * * This method can only be used to drop top level columns. the colName string is treated * literally without further interpretation. * * 仅用于删除顶层的列 * * @group untypedrel * @since 2.0.0 */def drop(colName: String): DataFrame = &#123; drop(Seq(colName): _*)&#125;/** * Returns a new Dataset with columns dropped. * This is a no-op if schema doesn't contain column name(s). * * 删除指定的多个列，并返回新的dataset * * This method can only be used to drop top level columns. the colName string is treated literally * without further interpretation. * * @group untypedrel * @since 2.0.0 */@scala.annotation.varargsdef drop(colNames: String*): DataFrame = &#123; val resolver = sparkSession.sessionState.analyzer.resolver val allColumns = queryExecution.analyzed.output val remainingCols = allColumns.filter &#123; attribute =&gt; colNames.forall(n =&gt; !resolver(attribute.name, n)) &#125;.map(attribute =&gt; Column(attribute)) if (remainingCols.size == allColumns.size) &#123; toDF() &#125; else &#123; this.select(remainingCols: _*) &#125;&#125;/** * Returns a new Dataset with a column dropped. * This version of drop accepts a [[Column]] rather than a name. * This is a no-op if the Dataset doesn't have a column * with an equivalent expression. * * 删除指定的 列（根据Column） * * @group untypedrel * @since 2.0.0 */def drop(col: Column): DataFrame = &#123; val expression = col match &#123; case Column(u: UnresolvedAttribute) =&gt; queryExecution.analyzed.resolveQuoted( u.name, sparkSession.sessionState.analyzer.resolver).getOrElse(u) case Column(expr: Expression) =&gt; expr &#125; val attrs = this.logicalPlan.output val colsAfterDrop = attrs.filter &#123; attr =&gt; attr != expression &#125;.map(attr =&gt; Column(attr)) select(colsAfterDrop: _*)&#125; typedrel-有类型的转换joinWith123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * :: Experimental :: 实验的 * Joins this Dataset returning a `Tuple2` for each pair where `condition` evaluates to * true. * 连接这个数据集返回一个“Tuple2”对每一对的“条件”计算为true。 * * This is similar to the relation `join` function with one important difference in the * result schema. Since `joinWith` preserves objects present on either side of the join, the * result schema is similarly nested into a tuple under the column names `_1` and `_2`. * 这类似于关系“join”函数，在结果模式中有一个重要的区别。 * 由于“joinWith”保存了连接的任何一边的对象，因此结果模式类似地嵌套在列名称“_1”和“_2”下面的tuple中。 * * This type of join can be useful both for preserving type-safety with the original object * types as well as working with relational data where either side of the join has column * names in common. * 这种类型的联接既可以用于保存与原始对象类型的类型安全性， * 也可以用于处理连接的任何一端都有列名的关系数据。 * * @param other Right side of the join. * @param condition Join expression. * @param joinType One of: `inner`, `outer`, `left_outer`, `right_outer`, `leftsemi`. * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef joinWith[U](other: Dataset[U], condition: Column, joinType: String): Dataset[(T, U)] = &#123; // Creates a Join node and resolve it first, to get join condition resolved, self-join resolved, // 创建一个联接节点并首先解析它，使Join条件得到解析，self - Join解析， // etc. val joined = sparkSession.sessionState.executePlan( Join( this.logicalPlan, other.logicalPlan, JoinType(joinType), Some(condition.expr))).analyzed.asInstanceOf[Join] // For both join side, combine all outputs into a single column and alias it with \"_1\" or \"_2\", // to match the schema for the encoder of the join result. // 对于这两个连接，将所有输出合并为一个列，并将其别名为“_1”或“_2”，以匹配连接结果的编码器的模式。 // Note that we do this before joining them, to enable the join operator to return null for one // side, in cases like outer-join. // 请注意，在join它们之前，我们这样做，使join操作符在像outer - join这样的情况下返回null。 val left = &#123; val combined = if (this.exprEnc.flat) &#123; assert(joined.left.output.length == 1) Alias(joined.left.output.head, \"_1\")() &#125; else &#123; Alias(CreateStruct(joined.left.output), \"_1\")() &#125; Project(combined :: Nil, joined.left) &#125; val right = &#123; val combined = if (other.exprEnc.flat) &#123; assert(joined.right.output.length == 1) Alias(joined.right.output.head, \"_2\")() &#125; else &#123; Alias(CreateStruct(joined.right.output), \"_2\")() &#125; Project(combined :: Nil, joined.right) &#125; // Rewrites the join condition to make the attribute point to correct column/field, after we // combine the outputs of each join side. // 在将每个连接的输出组合在一起之后,重写联接条件，使属性指向正确的列/字段。 val conditionExpr = joined.condition.get transformUp &#123; case a: Attribute if joined.left.outputSet.contains(a) =&gt; if (this.exprEnc.flat) &#123; left.output.head &#125; else &#123; val index = joined.left.output.indexWhere(_.exprId == a.exprId) GetStructField(left.output.head, index) &#125; case a: Attribute if joined.right.outputSet.contains(a) =&gt; if (other.exprEnc.flat) &#123; right.output.head &#125; else &#123; val index = joined.right.output.indexWhere(_.exprId == a.exprId) GetStructField(right.output.head, index) &#125; &#125; implicit val tuple2Encoder: Encoder[(T, U)] = ExpressionEncoder.tuple(this.exprEnc, other.exprEnc) withTypedPlan(Join(left, right, joined.joinType, Some(conditionExpr)))&#125;/** * :: Experimental :: * Using inner equi-join to join this Dataset returning a `Tuple2` for each pair * where `condition` evaluates to true. * * 使用内部的等连接加入这个数据集，为每一对返回一个“Tuple2”，其中“条件”的计算结果为true。 * * @param other Right side of the join. * @param condition Join expression. * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef joinWith[U](other: Dataset[U], condition: Column): Dataset[(T, U)] = &#123; joinWith(other, condition, \"inner\")&#125; sortWithinPartitions123456789101112131415161718192021222324252627282930313233/** * Returns a new Dataset with each partition sorted by the given expressions. * * 返回一个新的数据集，每个分区按照给定的表达式排序。 * * This is the same operation as \"SORT BY\" in SQL (Hive QL). * * 这与SQL(Hive QL)中“SORT BY”的操作相同。 * * @group typedrel * @since 2.0.0 */@scala.annotation.varargsdef sortWithinPartitions(sortCol: String, sortCols: String*): Dataset[T] = &#123; sortWithinPartitions((sortCol +: sortCols).map(Column(_)): _*)&#125;/** * Returns a new Dataset with each partition sorted by the given expressions. * * 返回一个新的数据集，每个分区按照给定的表达式排序。 * * This is the same operation as \"SORT BY\" in SQL (Hive QL). * * 这与SQL(Hive QL)中“SORT BY”的操作相同。 * * @group typedrel * @since 2.0.0 */@scala.annotation.varargsdef sortWithinPartitions(sortExprs: Column*): Dataset[T] = &#123; sortInternal(global = false, sortExprs)&#125; sort1234567891011121314151617181920212223242526272829303132333435/** * Returns a new Dataset sorted by the specified column, all in ascending order. * 排序 升序 * &#123;&#123;&#123; * // The following 3 are equivalent * 下面3个是等价的 * ds.sort(\"sortcol\") * ds.sort($\"sortcol\") * ds.sort($\"sortcol\".asc) * &#125;&#125;&#125; * * @group typedrel * @since 2.0.0 */ @scala.annotation.varargs def sort(sortCol: String, sortCols: String*): Dataset[T] = &#123; sort((sortCol +: sortCols).map(apply): _*) &#125; /** * Returns a new Dataset sorted by the given expressions. For example: * * 返回一个由给定表达式排序的新数据集。例如: * * &#123;&#123;&#123; * ds.sort($\"col1\", $\"col2\".desc) * &#125;&#125;&#125; * * @group typedrel * @since 2.0.0 */ @scala.annotation.varargs def sort(sortExprs: Column*): Dataset[T] = &#123; sortInternal(global = true, sortExprs) &#125; orderBy123456789101112131415161718192021/** * Returns a new Dataset sorted by the given expressions. * This is an alias of the `sort` function. * 这是“sort”函数的别名。 * * @group typedrel * @since 2.0.0 */ @scala.annotation.varargs def orderBy(sortCol: String, sortCols: String*): Dataset[T] = sort(sortCol, sortCols: _*) /** * Returns a new Dataset sorted by the given expressions. * This is an alias of the `sort` function. * 这是“sort”函数的别名。 * * @group typedrel * @since 2.0.0 */ @scala.annotation.varargs def orderBy(sortExprs: Column*): Dataset[T] = sort(sortExprs: _*) as12345678910111213141516171819/** * Returns a new Dataset with an alias set. * * 返回一个具有别名集的新数据集。 * * @group typedrel * @since 1.6.0 */ def as(alias: String): Dataset[T] = withTypedPlan &#123; SubqueryAlias(alias, logicalPlan, None) &#125; /** * (Scala-specific) Returns a new Dataset with an alias set. * * @group typedrel * @since 2.0.0 */ def as(alias: Symbol): Dataset[T] = as(alias.name) alias12345678910111213141516/** * Returns a new Dataset with an alias set. Same as `as`. * 返回一个具有别名集的新数据集。与“as”相同。 * * @group typedrel * @since 2.0.0 */ def alias(alias: String): Dataset[T] = as(alias) /** * (Scala-specific) Returns a new Dataset with an alias set. Same as `as`. * * @group typedrel * @since 2.0.0 */ def alias(alias: Symbol): Dataset[T] = as(alias) select1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * :: Experimental :: * Returns a new Dataset by computing the given [[Column]] expression for each element. * * 通过计算每个元素的给定[[列]]表达式返回一个新的数据集。 * * &#123;&#123;&#123; * val ds = Seq(1, 2, 3).toDS() * val newDS = ds.select(expr(\"value + 1\").as[Int]) * &#125;&#125;&#125; * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def select[U1](c1: TypedColumn[T, U1]): Dataset[U1] = &#123; implicit val encoder = c1.encoder val project = Project(c1.withInputType(exprEnc, logicalPlan.output).named :: Nil, logicalPlan) if (encoder.flat) &#123; new Dataset[U1](sparkSession, project, encoder) &#125; else &#123; // Flattens inner fields of U1 // 使U1的内部区域变平 new Dataset[Tuple1[U1]](sparkSession, project, ExpressionEncoder.tuple(encoder)).map(_._1) &#125; &#125; /** * :: Experimental :: * Returns a new Dataset by computing the given [[Column]] expressions for each element. * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def select[U1, U2](c1: TypedColumn[T, U1], c2: TypedColumn[T, U2]): Dataset[(U1, U2)] = selectUntyped(c1, c2).asInstanceOf[Dataset[(U1, U2)]] /** * :: Experimental :: * Returns a new Dataset by computing the given [[Column]] expressions for each element. * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def select[U1, U2, U3]( c1: TypedColumn[T, U1], c2: TypedColumn[T, U2], c3: TypedColumn[T, U3]): Dataset[(U1, U2, U3)] = selectUntyped(c1, c2, c3).asInstanceOf[Dataset[(U1, U2, U3)]] /** * :: Experimental :: * Returns a new Dataset by computing the given [[Column]] expressions for each element. * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def select[U1, U2, U3, U4]( c1: TypedColumn[T, U1], c2: TypedColumn[T, U2], c3: TypedColumn[T, U3], c4: TypedColumn[T, U4]): Dataset[(U1, U2, U3, U4)] = selectUntyped(c1, c2, c3, c4).asInstanceOf[Dataset[(U1, U2, U3, U4)]] /** * :: Experimental :: * Returns a new Dataset by computing the given [[Column]] expressions for each element. * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def select[U1, U2, U3, U4, U5]( c1: TypedColumn[T, U1], c2: TypedColumn[T, U2], c3: TypedColumn[T, U3], c4: TypedColumn[T, U4], c5: TypedColumn[T, U5]): Dataset[(U1, U2, U3, U4, U5)] = selectUntyped(c1, c2, c3, c4, c5).asInstanceOf[Dataset[(U1, U2, U3, U4, U5)]] filter12345678910111213141516171819202122232425262728293031323334/** * Filters rows using the given condition. * * 用给定的条件过滤rows * * &#123;&#123;&#123; * // The following are equivalent: * 以下是等价的： * peopleDs.filter($\"age\" &gt; 15) * peopleDs.where($\"age\" &gt; 15) * &#125;&#125;&#125; * * @group typedrel * @since 1.6.0 */ def filter(condition: Column): Dataset[T] = withTypedPlan &#123; Filter(condition.expr, logicalPlan) &#125; /** * Filters rows using the given SQL expression. * * 用给定的 SQL 表达式 过滤rows * * &#123;&#123;&#123; * peopleDs.filter(\"age &gt; 15\") * &#125;&#125;&#125; * * @group typedrel * @since 1.6.0 */ def filter(conditionExpr: String): Dataset[T] = &#123; filter(Column(sparkSession.sessionState.sqlParser.parseExpression(conditionExpr))) &#125; where1234567891011121314151617181920212223242526272829303132/** * Filters rows using the given condition. This is an alias for `filter`. * * 使用给定条件过滤行。 * 这是“filter”的别名。 * * &#123;&#123;&#123; * // The following are equivalent: * peopleDs.filter($\"age\" &gt; 15) * peopleDs.where($\"age\" &gt; 15) * &#125;&#125;&#125; * * @group typedrel * @since 1.6.0 */ def where(condition: Column): Dataset[T] = filter(condition) /** * Filters rows using the given SQL expression. * * 使用给定的 SQL 表达式 过滤 rows * * &#123;&#123;&#123; * peopleDs.where(\"age &gt; 15\") * &#125;&#125;&#125; * * @group typedrel * @since 1.6.0 */ def where(conditionExpr: String): Dataset[T] = &#123; filter(Column(sparkSession.sessionState.sqlParser.parseExpression(conditionExpr))) &#125; groupByKey12345678910111213141516171819202122232425262728293031323334353637/** * :: Experimental :: * (Scala-specific) * Returns a [[KeyValueGroupedDataset]] where the data is grouped by the given key `func`. * 返回一个[[KeyValueGroupedDataset]]，数据由给定键' func '分组。 * * @group typedrel * @since 2.0.0 */@Experimental@InterfaceStability.Evolvingdef groupByKey[K: Encoder](func: T =&gt; K): KeyValueGroupedDataset[K, T] = &#123; val inputPlan = logicalPlan val withGroupingKey = AppendColumns(func, inputPlan) val executed = sparkSession.sessionState.executePlan(withGroupingKey) new KeyValueGroupedDataset( encoderFor[K], encoderFor[T], executed, inputPlan.output, withGroupingKey.newColumns)&#125;/** * :: Experimental :: * (Java-specific) * Returns a [[KeyValueGroupedDataset]] where the data is grouped by the given key `func`. * 返回一个[[KeyValueGroupedDataset]]，数据由给定键' func '分组。 * * @group typedrel * @since 2.0.0 */@Experimental@InterfaceStability.Evolvingdef groupByKey[K](func: MapFunction[T, K], encoder: Encoder[K]): KeyValueGroupedDataset[K, T] = groupByKey(func.call(_))(encoder) limit123456789101112131415/** * Returns a new Dataset by taking the first `n` rows. The difference between this function * and `head` is that `head` is an action and returns an array (by triggering query execution) * while `limit` returns a new Dataset. * * 通过使用第一个“n”行返回一个新的数据集。 * 这个函数和“head”的区别在于“head”是一个动作， * 并返回一个数组(通过触发查询执行)，而“limit”则返回一个新的数据集。 * * @group typedrel * @since 2.0.0 */def limit(n: Int): Dataset[T] = withTypedPlan &#123; Limit(Literal(n), logicalPlan)&#125; unionAll-已过时1234567891011121314151617/** * Returns a new Dataset containing union of rows in this Dataset and another Dataset. * This is equivalent to `UNION ALL` in SQL. * * 返回一个新的数据集，该数据集包含该数据集中的行和另一个数据集。 * 这相当于SQL中的“UNION ALL”。 * * To do a SQL-style set union (that does deduplication of elements), use this function followed * by a [[distinct]]. * * 如果需要去重的话，在该方法后继续直接 [[distinct]] * * @group typedrel * @since 2.0.0 已经过时 */@deprecated(\"use union()\", \"2.0.0\")def unionAll(other: Dataset[T]): Dataset[T] = union(other) union123456789101112131415161718192021/** * Returns a new Dataset containing union of rows in this Dataset and another Dataset. * This is equivalent to `UNION ALL` in SQL. * * 返回一个新的数据集，该数据集包含该数据集中的行和另一个数据集。 * 这相当于SQL中的“UNION ALL”。 * * To do a SQL-style set union (that does deduplication of elements), use this function followed * by a [[distinct]]. * * 如果需要去重的话，在该方法后继续直接 [[distinct]] * * @group typedrel * @since 2.0.0 */def union(other: Dataset[T]): Dataset[T] = withSetOperator &#123; // This breaks caching, but it's usually ok because it addresses a very specific use case: // using union to union many files or partitions. // 这打破了缓存，但通常是可以的，因为它解决了一个非常具体的用例:使用union来联合许多文件或分区。 CombineUnions(Union(logicalPlan, other.logicalPlan))&#125; intersect-交集123456789101112131415161718/** * Returns a new Dataset containing rows only in both this Dataset and another Dataset. * This is equivalent to `INTERSECT` in SQL. * * 返回一个新的数据集，只包含该数据集和另一个数据集相同的行. * 这相当于在SQL中“INTERSECT”。 * 会去重. * * @note Equality checking is performed directly on the encoded representation of the data * and thus is not affected by a custom `equals` function defined on `T`. * * 等式检查直接执行数据的编码表示，因此不受定义为“T”的自定义“equals”函数的影响。 * @group typedrel * @since 1.6.0 */def intersect(other: Dataset[T]): Dataset[T] = withSetOperator &#123; Intersect(logicalPlan, other.logicalPlan)&#125; except-只显示另个Dataset中没有的值12345678910111213141516/** * Returns a new Dataset containing rows in this Dataset but not in another Dataset. * This is equivalent to `EXCEPT` in SQL. * * 返回一个新的数据集，该数据集包含该数据集中的行，而不是在另一个数据集。 * 这等价于SQL中的“EXCEPT”。 * 会去重. * * @note Equality checking is performed directly on the encoded representation of the data * and thus is not affected by a custom `equals` function defined on `T`. * @group typedrel * @since 2.0.0 */def except(other: Dataset[T]): Dataset[T] = withSetOperator &#123; Except(logicalPlan, other.logicalPlan)&#125; sample-随机抽样1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Returns a new [[Dataset]] by sampling a fraction of rows, using a user-supplied seed. * * 通过使用用户提供的种子，通过抽样的方式返回一个新的[[Dataset]]。 * * @param withReplacement Sample with replacement or not. * 样本已经取过的值是否放回 * @param fraction Fraction of rows to generate. * 每一行数据被取样的概率 * @param seed Seed for sampling. * 取样种子（与随机数生成有关） * @note This is NOT guaranteed to provide exactly the fraction of the count * of the given [[Dataset]]. * 不能保证准确的按照给定的分数取样。（一般结果会在概率值*总数左右） * @group typedrel * @since 1.6.0 */def sample(withReplacement: Boolean, fraction: Double, seed: Long): Dataset[T] = &#123; require(fraction &gt;= 0, s\"Fraction must be nonnegative, but got $&#123;fraction&#125;\") withTypedPlan &#123; Sample(0.0, fraction, withReplacement, seed, logicalPlan)() &#125;&#125;/** * Returns a new [[Dataset]] by sampling a fraction of rows, using a random seed. * * 通过程序随机的种子，抽样返回新的DataSet * * @param withReplacement Sample with replacement or not. * 取样结果是否放回 * @param fraction Fraction of rows to generate. * 每行数据被取样的概率 * @note This is NOT guaranteed to provide exactly the fraction of the total count * of the given [[Dataset]]. * 不能保证准确的按照给定的分数取样。（一般结果会在概率值*总数左右） * @group typedrel * @since 1.6.0 */def sample(withReplacement: Boolean, fraction: Double): Dataset[T] = &#123; sample(withReplacement, fraction, Utils.random.nextLong)&#125; randomSplit-按照权重分割1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Randomly splits this Dataset with the provided weights. * * 随机将此数据集按照所提供的权重进行分割。 * * @param weights weights for splits, will be normalized if they don't sum to 1. * 切分的权重。如果和不为1就会被标准化。 * @param seed Seed for sampling. * 取样的种子（影响随机数生成器） * * For Java API, use [[randomSplitAsList]]. * Java API 使用 [[randomSplitAsList]]. * @group typedrel * @since 2.0.0 */ def randomSplit(weights: Array[Double], seed: Long): Array[Dataset[T]] = &#123; require(weights.forall(_ &gt;= 0), s\"Weights must be nonnegative, but got $&#123;weights.mkString(\"[\", \",\", \"]\")&#125;\") require(weights.sum &gt; 0, s\"Sum of weights must be positive, but got $&#123;weights.mkString(\"[\", \",\", \"]\")&#125;\") // It is possible that the underlying dataframe doesn't guarantee the ordering of rows in its // constituent partitions each time a split is materialized which could result in // overlapping splits. To prevent this, we explicitly sort each input partition to make the // ordering deterministic. // MapType cannot be sorted. val sorted = Sort(logicalPlan.output.filterNot(_.dataType.isInstanceOf[MapType]) .map(SortOrder(_, Ascending)), global = false, logicalPlan) val sum = weights.sum // scanLeft 从右到右依次累计算 scanLeft(0.0d)(_+_): (0.0,(0.0+0.2),(0.0+0.2+0.8)) val normalizedCumWeights = weights.map(_ / sum).scanLeft(0.0d)(_ + _) // sliding(n) 每次取n个值，以步长为1向右滑动，如：(0.0,0.2,0.8).sliding(2)=(0.0,0.2),(0.2,0.8) normalizedCumWeights.sliding(2).map &#123; x =&gt; new Dataset[T]( sparkSession, Sample(x(0), x(1), withReplacement = false, seed, sorted)(), encoder) &#125;.toArray &#125; /** * Randomly splits this Dataset with the provided weights. * * 程序自动生成随机数种子，随机将此数据集按照所提供的权重进行分割。 * * @param weights weights for splits, will be normalized if they don't sum to 1. * 切分的权重。如果和不为1就会被标准化。 * @group typedrel * @since 2.0.0 */ def randomSplit(weights: Array[Double]): Array[Dataset[T]] = &#123; randomSplit(weights, Utils.random.nextLong) &#125; /** * Randomly splits this Dataset with the provided weights. Provided for the Python Api. * Python 使用该方法 * * @param weights weights for splits, will be normalized if they don't sum to 1. * @param seed Seed for sampling. */ private[spark] def randomSplit(weights: List[Double], seed: Long): Array[Dataset[T]] = &#123; randomSplit(weights.toArray, seed) &#125; randomSplitAsList12345678910111213141516/** * Returns a Java list that contains randomly split Dataset with the provided weights. * * 根据提供的权重分割DataFrames，返回Java list * * @param weights weights for splits, will be normalized if they don't sum to 1. * 切分的权重。如果和不为1就会被标准化。 * @param seed Seed for sampling. * 取样的种子（影响随机数生成器） * @group typedrel * @since 2.0.0 */def randomSplitAsList(weights: Array[Double], seed: Long): java.util.List[Dataset[T]] = &#123; val values = randomSplit(weights, seed) java.util.Arrays.asList(values: _*)&#125; dropDuplicates-去重123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Returns a new Dataset that contains only the unique rows from this Dataset. * This is an alias for `distinct`. * * 删除重复的row数据，是distinct的别名 * * @group typedrel * @since 2.0.0 */def dropDuplicates(): Dataset[T] = dropDuplicates(this.columns)/** * (Scala-specific) Returns a new Dataset with duplicate rows removed, considering only * the subset of columns. * * 只删除指定列的重复数据 * * @group typedrel * @since 2.0.0 */def dropDuplicates(colNames: Seq[String]): Dataset[T] = withTypedPlan &#123; val resolver = sparkSession.sessionState.analyzer.resolver val allColumns = queryExecution.analyzed.output val groupCols = colNames.flatMap &#123; colName =&gt; // It is possibly there are more than one columns with the same name, // so we call filter instead of find. val cols = allColumns.filter(col =&gt; resolver(col.name, colName)) if (cols.isEmpty) &#123; throw new AnalysisException( s\"\"\"Cannot resolve column name \"$colName\" among ($&#123;schema.fieldNames.mkString(\", \")&#125;)\"\"\") &#125; cols &#125; val groupColExprIds = groupCols.map(_.exprId) val aggCols = logicalPlan.output.map &#123; attr =&gt; if (groupColExprIds.contains(attr.exprId)) &#123; attr &#125; else &#123; // Removing duplicate rows should not change output attributes. We should keep // the original exprId of the attribute. Otherwise, to select a column in original // dataset will cause analysis exception due to unresolved attribute. // 删除重复行不应该更改输出属性。 // 我们应该保留这个属性的原始属性。 // 否则，在原始数据集中选择一个列将导致分析异常，原因是未解析的属性。 Alias(new First(attr).toAggregateExpression(), attr.name)(exprId = attr.exprId) &#125; &#125; Aggregate(groupCols, aggCols, logicalPlan)&#125;/** * Returns a new Dataset with duplicate rows removed, considering only * the subset of columns. * * 只针对特定列做去重 * * @group typedrel * @since 2.0.0 */def dropDuplicates(colNames: Array[String]): Dataset[T] = dropDuplicates(colNames.toSeq)/** * Returns a new [[Dataset]] with duplicate rows removed, considering only * the subset of columns. * * 只针对特定多列做去重 * * @group typedrel * @since 2.0.0 */@scala.annotation.varargsdef dropDuplicates(col1: String, cols: String*): Dataset[T] = &#123; val colNames: Seq[String] = col1 +: cols dropDuplicates(colNames)&#125; transform-自定义转换1234567891011121314151617/** * Concise syntax for chaining custom transformations. * * 用于链接自定义转换的简明语法。 * * &#123;&#123;&#123; * def featurize(ds: Dataset[T]): Dataset[U] = ... * * ds * .transform(featurize) * .transform(...) * &#125;&#125;&#125; * * @group typedrel * @since 1.6.0 */def transform[U](t: Dataset[T] =&gt; Dataset[U]): Dataset[U] = t(this) filter-过滤12345678910111213141516171819202122232425262728293031/** * :: Experimental :: * (Scala-specific) * Returns a new Dataset that only contains elements where `func` returns `true`. * * 该数据集只包含“func”返回“true”的元素。 * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def filter(func: T =&gt; Boolean): Dataset[T] = &#123; withTypedPlan(TypedFilter(func, logicalPlan)) &#125; /** * :: Experimental :: * (Java-specific) * Returns a new Dataset that only contains elements where `func` returns `true`. * * 返回一个新数据集，该数据集只包含“func”返回“true”的元素。 * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def filter(func: FilterFunction[T]): Dataset[T] = &#123; withTypedPlan(TypedFilter(func, logicalPlan)) &#125; map1234567891011121314151617181920212223242526272829303132/** * :: Experimental :: * (Scala-specific) * Returns a new Dataset that contains the result of applying `func` to each element. * * 返回一个新的数据集，该数据集包含对每个元素应用“func”的结果。 * * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef map[U: Encoder](func: T =&gt; U): Dataset[U] = withTypedPlan &#123; MapElements[T, U](func, logicalPlan)&#125;/** * :: Experimental :: * (Java-specific) * Returns a new Dataset that contains the result of applying `func` to each element. * * 返回一个新的数据集，该数据集包含对每个元素应用“func”的结果。 * * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef map[U](func: MapFunction[T, U], encoder: Encoder[U]): Dataset[U] = &#123; implicit val uEnc = encoder withTypedPlan(MapElements[T, U](func, logicalPlan))&#125; mapPartitions1234567891011121314151617181920212223242526272829303132333435/** * :: Experimental :: * (Scala-specific) * Returns a new Dataset that contains the result of applying `func` to each partition. * * 返回一个新的数据集，该数据集包含对每个分区应用“func”的结果。 * * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef mapPartitions[U: Encoder](func: Iterator[T] =&gt; Iterator[U]): Dataset[U] = &#123; new Dataset[U]( sparkSession, MapPartitions[T, U](func, logicalPlan), implicitly[Encoder[U]])&#125;/** * :: Experimental :: * (Java-specific) * Returns a new Dataset that contains the result of applying `f` to each partition. * * 返回一个新的数据集，该数据集包含对每个分区应用“f”的结果。 * * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef mapPartitions[U](f: MapPartitionsFunction[T, U], encoder: Encoder[U]): Dataset[U] = &#123; val func: (Iterator[T]) =&gt; Iterator[U] = x =&gt; f.call(x.asJava).asScala mapPartitions(func)(encoder)&#125; flatMap-将map结果flat扁平化123456789101112131415161718192021222324252627282930313233/** * :: Experimental :: * (Scala-specific) * Returns a new Dataset by first applying a function to all elements of this Dataset, * and then flattening the results. * * 返回一个新的数据集，首先对该数据集的所有元素应用一个函数，然后将结果扁平化。 * * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef flatMap[U: Encoder](func: T =&gt; TraversableOnce[U]): Dataset[U] = mapPartitions(_.flatMap(func))/** * :: Experimental :: * (Java-specific) * Returns a new Dataset by first applying a function to all elements of this Dataset, * and then flattening the results. * * 返回一个新的数据集，首先对该数据集的所有元素应用一个函数，然后将结果扁平化。 * * @group typedrel * @since 1.6.0 */@Experimental@InterfaceStability.Evolvingdef flatMap[U](f: FlatMapFunction[T, U], encoder: Encoder[U]): Dataset[U] = &#123; val func: (T) =&gt; Iterator[U] = x =&gt; f.call(x).asScala flatMap(func)(encoder)&#125; repartition-重分区123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Returns a new Dataset that has exactly `numPartitions` partitions. * * 返回一个 给定分区数量的新DataSet * * @group typedrel * @since 1.6.0 */ def repartition(numPartitions: Int): Dataset[T] = withTypedPlan &#123; Repartition(numPartitions, shuffle = true, logicalPlan) &#125; /** * Returns a new Dataset partitioned by the given partitioning expressions into * `numPartitions`. The resulting Dataset is hash partitioned. * * 返回一个由给定的分区表达式划分为“num分区”的新数据集。 * 生成的Dataset是哈希分区的。 * * This is the same operation as \"DISTRIBUTE BY\" in SQL (Hive QL). * * 和 SQL (Hive QL) 中的 \"DISTRIBUTE BY\" 作用相同 * * @group typedrel * @since 2.0.0 */ @scala.annotation.varargs def repartition(numPartitions: Int, partitionExprs: Column*): Dataset[T] = withTypedPlan &#123; RepartitionByExpression(partitionExprs.map(_.expr), logicalPlan, Some(numPartitions)) &#125; /** * Returns a new Dataset partitioned by the given partitioning expressions, using * `spark.sql.shuffle.partitions` as number of partitions. * The resulting Dataset is hash partitioned. * * 根据指定的分区表达式进行重分区。 * 分区数量由`spark.sql.shuffle.partitions` 获得。 * 结果Dataset 是哈希分区的。 * * This is the same operation as \"DISTRIBUTE BY\" in SQL (Hive QL). * * 和 SQL (Hive QL) 中的 \"DISTRIBUTE BY\" 作用相同 * * @group typedrel * @since 2.0.0 */ @scala.annotation.varargs def repartition(partitionExprs: Column*): Dataset[T] = withTypedPlan &#123; RepartitionByExpression(partitionExprs.map(_.expr), logicalPlan, numPartitions = None) &#125; coalesce-合并分区1234567891011121314151617/** * Returns a new Dataset that has exactly `numPartitions` partitions. * Similar to coalesce defined on an `RDD`, this operation results in a narrow dependency, e.g. * if you go from 1000 partitions to 100 partitions, there will not be a shuffle, instead each of * the 100 new partitions will claim 10 of the current partitions. * * 合并。 * 返回确定分区数量的Dataset。 * 和RDD中的合并方法类似，这个操作导致了一个窄依赖。 * 例如：将1000个分区合并为100个分区，这个过程没有shuffle，而是100个新分区中的每个分区将声明当前的10个分区。 * * @group typedrel * @since 1.6.0 */ def coalesce(numPartitions: Int): Dataset[T] = withTypedPlan &#123; Repartition(numPartitions, shuffle = false, logicalPlan) &#125; distinct-去重1234567891011121314/** * Returns a new Dataset that contains only the unique rows from this Dataset. * This is an alias for `dropDuplicates`. * * 去重。 * 返回去重后的Dataset。 * 和 `dropDuplicates` 方法一致。 * * @note Equality checking is performed directly on the encoded representation of the data * and thus is not affected by a custom `equals` function defined on `T`. * @group typedrel * @since 2.0.0 */ def distinct(): Dataset[T] = dropDuplicates()","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"},{"name":"源码","slug":"源码","permalink":"https://freehubs.github.io/tags/源码/"}]},{"title":"JavaRDDLike.scala","slug":"JavaRDDLike-scala","date":"2017-11-21T14:21:23.000Z","updated":"2020-09-09T04:36:35.745Z","comments":true,"path":"2017/11/21/JavaRDDLike-scala/","link":"","permalink":"https://freehubs.github.io/2017/11/21/JavaRDDLike-scala/","excerpt":"\n            使用Java开发Spark程序，JavaRDD的功能算子中英文注释JavaRDDLike的实现应该扩展这个虚拟抽象类，而不是直接继承这个特性。\n          \n\nJavaRDD1234567891011121314151617181920package org.apache.spark.api.javaprivate[spark] abstract class AbstractJavaRDDLike[T, This &lt;: JavaRDDLike[T, This]]  extends JavaRDDLike[T, This]/**  * Defines operations common to several Java RDD implementations.  *  * 定义几个Java RDD实现的常见操作。  *  * @note This trait is not intended to be implemented by user code.  *  *       该特性不打算由用户代码实现。  */trait JavaRDDLike[T, This &lt;: JavaRDDLike[T, This]] extends Serializable &#123;  def wrapRDD(rdd: RDD[T]): This  implicit val classTag: ClassTag[T]  def rdd: RDD[T]","text":"使用Java开发Spark程序，JavaRDD的功能算子中英文注释JavaRDDLike的实现应该扩展这个虚拟抽象类，而不是直接继承这个特性。 JavaRDD1234567891011121314151617181920package org.apache.spark.api.javaprivate[spark] abstract class AbstractJavaRDDLike[T, This &lt;: JavaRDDLike[T, This]] extends JavaRDDLike[T, This]/** * Defines operations common to several Java RDD implementations. * * 定义几个Java RDD实现的常见操作。 * * @note This trait is not intended to be implemented by user code. * * 该特性不打算由用户代码实现。 */trait JavaRDDLike[T, This &lt;: JavaRDDLike[T, This]] extends Serializable &#123; def wrapRDD(rdd: RDD[T]): This implicit val classTag: ClassTag[T] def rdd: RDD[T] partitions1234/** Set of partitions in this RDD. * 在这个RDD中设置的分区。 * */def partitions: JList[Partition] = rdd.partitions.toSeq.asJava getNumPartitions12345/** Return the number of partitions in this RDD. * 返回该RDD中的分区数。 * */@Since(\"1.6.0\")def getNumPartitions: Int = rdd.getNumPartitions partitioner1234/** The partitioner of this RDD. * 这个RDD的分区。 * */def partitioner: Optional[Partitioner] = JavaUtils.optionToOptional(rdd.partitioner) context12345/** The [[org.apache.spark.SparkContext]] that this RDD was created on. * * 这个RDD是在[[org.apache.spark.SparkContext]]上面创建的。 * */def context: SparkContext = rdd.context id1234/** A unique ID for this RDD (within its SparkContext). * 这个RDD的惟一ID(在它的SparkContext内)。 * */def id: Int = rdd.id name1def name(): String = rdd.name getStorageLevel1234/** Get the RDD's current storage level, or StorageLevel.NONE if none is set. * 获取RDD的当前存储级别，或StorageLevel。如果没有设置就没有。 * */def getStorageLevel: StorageLevel = rdd.getStorageLevel iterator12345678910/** * Internal method to this RDD; will read from cache if applicable, or otherwise compute it. * This should ''not'' be called by users directly, but is available for implementors of custom * subclasses of RDD. * 内部方法的RDD;将从缓存读取，如果适用的话，或者计算它。 * 这应该“不是”直接由用户调用，而是用于RDD的自定义子类的实现者 * */def iterator(split: Partition, taskContext: TaskContext): JIterator[T] = rdd.iterator(split, taskContext).asJavs Transformations (return a new RDD)map1234567/** * Return a new RDD by applying a function to all elements of this RDD. * 将一个函数应用于这个RDD的所有元素，返回一个新的RDD。 * */def map[R](f: JFunction[T, R]): JavaRDD[R] = new JavaRDD(rdd.map(f)(fakeClassTag))(fakeClassTag) mapPartitionsWithIndex1234567891011/** * Return a new RDD by applying a function to each partition of this RDD, while tracking the index * of the original partition. * 通过在RDD的每个分区上应用一个函数来返回一个新的RDD，同时跟踪原始分区的索引。 * */def mapPartitionsWithIndex[R]( f: JFunction2[jl.Integer, JIterator[T], JIterator[R]], preservesPartitioning: Boolean = false): JavaRDD[R] = new JavaRDD(rdd.mapPartitionsWithIndex((a, b) =&gt; f.call(a, b.asJava).asScala, preservesPartitioning)(fakeClassTag))(fakeClassTag) mapToDouble1234567/** * Return a new RDD by applying a function to all elements of this RDD. * 将一个函数应用于这个RDD的所有元素，返回一个新的RDD。 */def mapToDouble[R](f: DoubleFunction[T]): JavaDoubleRDD = &#123; new JavaDoubleRDD(rdd.map(f.call(_).doubleValue()))&#125; mapToPair123456789/** * Return a new RDD by applying a function to all elements of this RDD. * 将一个函数应用于这个RDD的所有元素，返回一个新的RDD。 * */def mapToPair[K2, V2](f: PairFunction[T, K2, V2]): JavaPairRDD[K2, V2] = &#123; def cm: ClassTag[(K2, V2)] = implicitly[ClassTag[(K2, V2)]] new JavaPairRDD(rdd.map[(K2, V2)](f)(cm))(fakeClassTag[K2], fakeClassTag[V2])&#125; flatMap12345678910/** * Return a new RDD by first applying a function to all elements of this * RDD, and then flattening the results. * 返回一个新的RDD，首先将一个函数应用于这个RDD的所有元素，然后将结果扁平化。 * */def flatMap[U](f: FlatMapFunction[T, U]): JavaRDD[U] = &#123; def fn: (T) =&gt; Iterator[U] = (x: T) =&gt; f.call(x).asScala JavaRDD.fromRDD(rdd.flatMap(fn)(fakeClassTag[U]))(fakeClassTag[U])&#125; flatMapToDouble12345678910/** * Return a new RDD by first applying a function to all elements of this * RDD, and then flattening the results. * 返回一个新的RDD，首先将一个函数应用于这个RDD的所有元素，然后将结果扁平化。 * */def flatMapToDouble(f: DoubleFlatMapFunction[T]): JavaDoubleRDD = &#123; def fn: (T) =&gt; Iterator[jl.Double] = (x: T) =&gt; f.call(x).asScala new JavaDoubleRDD(rdd.flatMap(fn).map(_.doubleValue()))&#125; flatMapToPair1234567891011/** * Return a new RDD by first applying a function to all elements of this * RDD, and then flattening the results. * 返回一个新的RDD，首先将一个函数应用于这个RDD的所有元素，然后将结果扁平化。 * */def flatMapToPair[K2, V2](f: PairFlatMapFunction[T, K2, V2]): JavaPairRDD[K2, V2] = &#123; def fn: (T) =&gt; Iterator[(K2, V2)] = (x: T) =&gt; f.call(x).asScala def cm: ClassTag[(K2, V2)] = implicitly[ClassTag[(K2, V2)]] JavaPairRDD.fromRDD(rdd.flatMap(fn)(cm))(fakeClassTag[K2], fakeClassTag[V2])&#125; mapPartitions12345678910111213141516171819202122232425/** * Return a new RDD by applying a function to each partition of this RDD. * 通过将一个函数应用于这个RDD的每个分区，返回一个新的RDD。 * */def mapPartitions[U](f: FlatMapFunction[JIterator[T], U]): JavaRDD[U] = &#123; def fn: (Iterator[T]) =&gt; Iterator[U] = &#123; (x: Iterator[T]) =&gt; f.call(x.asJava).asScala &#125; JavaRDD.fromRDD(rdd.mapPartitions(fn)(fakeClassTag[U]))(fakeClassTag[U])&#125;/** * Return a new RDD by applying a function to each partition of this RDD. * 通过将一个函数应用于这个RDD的每个分区，返回一个新的RDD。 * */def mapPartitions[U](f: FlatMapFunction[JIterator[T], U], preservesPartitioning: Boolean): JavaRDD[U] = &#123; def fn: (Iterator[T]) =&gt; Iterator[U] = &#123; (x: Iterator[T]) =&gt; f.call(x.asJava).asScala &#125; JavaRDD.fromRDD( rdd.mapPartitions(fn, preservesPartitioning)(fakeClassTag[U]))(fakeClassTag[U])&#125; mapPartitionsToDouble12345678910111213141516171819202122232425/** * Return a new RDD by applying a function to each partition of this RDD. * 通过将一个函数应用于这个RDD的每个分区，返回一个新的RDD。 * */def mapPartitionsToDouble(f: DoubleFlatMapFunction[JIterator[T]]): JavaDoubleRDD = &#123; def fn: (Iterator[T]) =&gt; Iterator[jl.Double] = &#123; (x: Iterator[T]) =&gt; f.call(x.asJava).asScala &#125; new JavaDoubleRDD(rdd.mapPartitions(fn).map(_.doubleValue()))&#125;/** * Return a new RDD by applying a function to each partition of this RDD. * 通过将一个函数应用于这个RDD的每个分区，返回一个新的RDD。 * */def mapPartitionsToDouble(f: DoubleFlatMapFunction[JIterator[T]], preservesPartitioning: Boolean): JavaDoubleRDD = &#123; def fn: (Iterator[T]) =&gt; Iterator[jl.Double] = &#123; (x: Iterator[T]) =&gt; f.call(x.asJava).asScala &#125; new JavaDoubleRDD(rdd.mapPartitions(fn, preservesPartitioning) .map(_.doubleValue()))&#125; mapPartitionsToPair1234567891011121314151617181920212223242526/** * Return a new RDD by applying a function to each partition of this RDD. * 通过将一个函数应用于这个RDD的每个分区，返回一个新的RDD。 * */def mapPartitionsToPair[K2, V2](f: PairFlatMapFunction[JIterator[T], K2, V2]):JavaPairRDD[K2, V2] = &#123; def fn: (Iterator[T]) =&gt; Iterator[(K2, V2)] = &#123; (x: Iterator[T]) =&gt; f.call(x.asJava).asScala &#125; JavaPairRDD.fromRDD(rdd.mapPartitions(fn))(fakeClassTag[K2], fakeClassTag[V2])&#125;/** * Return a new RDD by applying a function to each partition of this RDD. * 通过将一个函数应用于这个RDD的每个分区，返回一个新的RDD。 * */def mapPartitionsToPair[K2, V2](f: PairFlatMapFunction[JIterator[T], K2, V2], preservesPartitioning: Boolean): JavaPairRDD[K2, V2] = &#123; def fn: (Iterator[T]) =&gt; Iterator[(K2, V2)] = &#123; (x: Iterator[T]) =&gt; f.call(x.asJava).asScala &#125; JavaPairRDD.fromRDD( rdd.mapPartitions(fn, preservesPartitioning))(fakeClassTag[K2], fakeClassTag[V2])&#125; foreachPartition12345678/** * Applies a function f to each partition of this RDD. * 将函数f应用于该RDD的每个分区。 * */def foreachPartition(f: VoidFunction[JIterator[T]]): Unit = &#123; rdd.foreachPartition(x =&gt; f.call(x.asJava))&#125; glom1234567/** * Return an RDD created by coalescing all elements within each partition into an array. * 返回一个RDD，它将每个分区中的所有元素合并到一个数组中。 * */def glom(): JavaRDD[JList[T]] = new JavaRDD(rdd.glom().map(_.toSeq.asJava)) cartesian12345678/** * Return the Cartesian product of this RDD and another one, that is, the RDD of all pairs of * elements (a, b) where a is in `this` and b is in `other`. * 返回这个RDD和另一个的笛卡尔乘积，即所有元素对的RDD(a,b) ：a在该RDD中，b在另一个RDD中 * */def cartesian[U](other: JavaRDDLike[U, _]): JavaPairRDD[T, U] = JavaPairRDD.fromRDD(rdd.cartesian(other.rdd)(other.classTag))(classTag, other.classTag) groupBy123456789101112131415161718192021222324252627/** * Return an RDD of grouped elements. Each group consists of a key and a sequence of elements * mapping to that key. * 返回分组元素的RDD。 * 每个组由一个键和一个映射到该键的元素序列组成。 * */def groupBy[U](f: JFunction[T, U]): JavaPairRDD[U, JIterable[T]] = &#123; // The type parameter is U instead of K in order to work around a compiler bug; see SPARK-4459 // 类型参数是U而不是K，是为了绕过编译器错误 implicit val ctagK: ClassTag[U] = fakeClassTag implicit val ctagV: ClassTag[JList[T]] = fakeClassTag JavaPairRDD.fromRDD(groupByResultToJava(rdd.groupBy(f)(fakeClassTag)))&#125;/** * Return an RDD of grouped elements. Each group consists of a key and a sequence of elements * mapping to that key. * 返回分组元素的RDD。 * 每个组由一个键和一个映射到该键的元素序列组成。 */def groupBy[U](f: JFunction[T, U], numPartitions: Int): JavaPairRDD[U, JIterable[T]] = &#123; // The type parameter is U instead of K in order to work around a compiler bug; see SPARK-4459 implicit val ctagK: ClassTag[U] = fakeClassTag implicit val ctagV: ClassTag[JList[T]] = fakeClassTag JavaPairRDD.fromRDD(groupByResultToJava(rdd.groupBy(f, numPartitions)(fakeClassTag[U])))&#125; pipe123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Return an RDD created by piping elements to a forked external process. * 返回由管道元素调用外部程序返回新的RDD * */def pipe(command: String): JavaRDD[String] = &#123; rdd.pipe(command)&#125;/** * Return an RDD created by piping elements to a forked external process. * 返回由管道元素调用外部程序返回新的RDD * */def pipe(command: JList[String]): JavaRDD[String] = &#123; rdd.pipe(command.asScala)&#125;/** * Return an RDD created by piping elements to a forked external process. * 返回由管道元素调用外部程序返回新的RDD * */def pipe(command: JList[String], env: JMap[String, String]): JavaRDD[String] = &#123; rdd.pipe(command.asScala, env.asScala)&#125;/** * Return an RDD created by piping elements to a forked external process. * 返回由管道元素调用外部程序返回新的RDD * */def pipe(command: JList[String], env: JMap[String, String], separateWorkingDir: Boolean, bufferSize: Int): JavaRDD[String] = &#123; rdd.pipe(command.asScala, env.asScala, null, null, separateWorkingDir, bufferSize)&#125;/** * Return an RDD created by piping elements to a forked external process. * 返回由管道元素调用外部程序返回新的RDD * */def pipe(command: JList[String], env: JMap[String, String], separateWorkingDir: Boolean, bufferSize: Int, encoding: String): JavaRDD[String] = &#123; rdd.pipe(command.asScala, env.asScala, null, null, separateWorkingDir, bufferSize, encoding)&#125; zip123456789101112/** * Zips this RDD with another one, returning key-value pairs with the first element in each RDD, * second element in each RDD, etc. Assumes that the two RDDs have the *same number of * partitions* and the *same number of elements in each partition* (e.g. one was made through * a map on the other). * 将此RDD与另一个RDD进行Zips，返回键值对，每个RDD中的第一个元素，每个RDD中的第二个元素，等等。 * 假设两个RDDs拥有相同数量的分区和每个分区中相同数量的元素 * (例如，一个是通过另一个map的)。 */def zip[U](other: JavaRDDLike[U, _]): JavaPairRDD[T, U] = &#123; JavaPairRDD.fromRDD(rdd.zip(other.rdd)(other.classTag))(classTag, other.classTag)&#125; zipPartitions1234567891011121314151617/** * Zip this RDD's partitions with one (or more) RDD(s) and return a new RDD by * applying a function to the zipped partitions. Assumes that all the RDDs have the * *same number of partitions*, but does *not* require them to have the same number * of elements in each partition. * 用一个(或多个)RDD(或多个)来压缩这个RDD的分区，并返回一个新的RDD将函数应用于压缩分区。 * 假设所有RDDs拥有相同数量的分区，但不要求它们在每个分区中拥有相同数量的元素。 */def zipPartitions[U, V]( other: JavaRDDLike[U, _], f: FlatMapFunction2[JIterator[T], JIterator[U], V]): JavaRDD[V] = &#123; def fn: (Iterator[T], Iterator[U]) =&gt; Iterator[V] = &#123; (x: Iterator[T], y: Iterator[U]) =&gt; f.call(x.asJava, y.asJava).asScala &#125; JavaRDD.fromRDD( rdd.zipPartitions(other.rdd)(fn)(other.classTag, fakeClassTag[V]))(fakeClassTag[V])&#125; zipWithUniqueId1234567891011/** * Zips this RDD with generated unique Long ids. Items in the kth partition will get ids k, n+k, * 2*n+k, ..., where n is the number of partitions. So there may exist gaps, but this method * won't trigger a spark job, which is different from [[org.apache.spark.rdd.RDD#zipWithIndex]]. * 用生成的唯一长的id来压缩这个RDD。 * 第k个分区的项将得到id k,n + k,2 *n+ k，…，其中n是分区数。 * 因此，可能存在差距，但这种方法不会触发spark作业，它与[org .apache.spark. spark.rdd. rdd. rdd # zipWithIndex]不同。 */def zipWithUniqueId(): JavaPairRDD[T, jl.Long] = &#123; JavaPairRDD.fromRDD(rdd.zipWithUniqueId()).asInstanceOf[JavaPairRDD[T, jl.Long]]&#125; zipWithIndex12345678910111213141516/** * Zips this RDD with its element indices. The ordering is first based on the partition index * and then the ordering of items within each partition. So the first item in the first * partition gets index 0, and the last item in the last partition receives the largest index. * This is similar to Scala's zipWithIndex but it uses Long instead of Int as the index type. * This method needs to trigger a spark job when this RDD contains more than one partitions. * * 用它的元素索引来压缩这个RDD。 * 排序首先基于分区索引，然后是每个分区中的条目的排序。 * 因此，第一个分区中的第一个项的索引值为0，最后一个分区中的最后一个项得到最大的索引。 * 这类似于Scala的zipWithIndex，但它使用的是Long而不是Int作为索引类型。 * 当这个RDD包含多个分区时，这个方法需要触发一个spark作业。 */def zipWithIndex(): JavaPairRDD[T, jl.Long] = &#123; JavaPairRDD.fromRDD(rdd.zipWithIndex()).asInstanceOf[JavaPairRDD[T, jl.Long]]&#125; Actions (launch a job to return a value to the user program)foreach1234567/** * Applies a function f to all elements of this RDD. * 将函数f应用于该RDD的所有元素。 */def foreach(f: VoidFunction[T]) &#123; rdd.foreach(x =&gt; f.call(x))&#125; collect12345678910/** * Return an array that contains all of the elements in this RDD. * 返回包含该RDD中所有元素的数组。 * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 该方法只在预期的数组很小的情况下使用，因为所有的数据都被加载到驱动程序的内存中。 */def collect(): JList[T] = rdd.collect().toSeq.asJava toLocalIterator123456789/** * Return an iterator that contains all of the elements in this RDD. * 返回包含该RDD中所有元素的迭代器。 * * The iterator will consume as much memory as the largest partition in this RDD. * 迭代器将消耗与此RDD中最大的分区一样多的内存。 */def toLocalIterator(): JIterator[T] = asJavaIteratorConverter(rdd.toLocalIterator).asJava collectPartitions1234567891011 /** * Return an array that contains all of the elements in a specific partition of this RDD. * 返回包含该RDD的特定分区中的所有元素的数组。 */def collectPartitions(partitionIds: Array[Int]): Array[JList[T]] = &#123; // This is useful for implementing `take` from other language frontends // like Python where the data is serialized. // 这有助于从其他语言的前沿实现“take”，如Python，数据被序列化。 val res = context.runJob(rdd, (it: Iterator[T]) =&gt; it.toArray, partitionIds) res.map(_.toSeq.asJava)&#125; reduce123456/** * Reduces the elements of this RDD using the specified commutative and associative binary * operator. * 使用指定的交换和关联二元运算符来减少该RDD的元素。 */def reduce(f: JFunction2[T, T, T]): T = rdd.reduce(f) treeReduce12345678910111213/** * Reduces the elements of this RDD in a multi-level tree pattern. * 将此RDD的元素简化为多层树模式。 * * @param depth suggested depth of the tree 建议树的深度 * @see [[org.apache.spark.api.java.JavaRDDLike#reduce]] */def treeReduce(f: JFunction2[T, T, T], depth: Int): T = rdd.treeReduce(f, depth)/** * [[org.apache.spark.api.java.JavaRDDLike#treeReduce]] 建议深度 2 . */def treeReduce(f: JFunction2[T, T, T]): T = treeReduce(f, 2) fold123456789101112131415161718192021 /** * Aggregate the elements of each partition, and then the results for all the partitions, using a * given associative function and a neutral \"zero value\". The function * op(t1, t2) is allowed to modify t1 and return it as its result value to avoid object * allocation; however, it should not modify t2. * 对每个分区的元素进行聚合，然后使用给定的关联函数和中立的“零值”，对所有分区进行结果。 * 函数op(t1,t2)被允许修改t1，并将其作为其结果值返回，以避免对象分配;但是，它不应该修改t2。 * * This behaves somewhat differently from fold operations implemented for non-distributed * collections in functional languages like Scala. This fold operation may be applied to * partitions individually, and then fold those results into the final result, rather than * apply the fold to each element sequentially in some defined ordering. For functions * that are not commutative, the result may differ from that of a fold applied to a * non-distributed collection. * 这与在Scala等函数式语言中实现非分布式集合的折叠操作有一定的不同。 * 这个折叠操作可以单独应用于分区，然后将这些结果折叠到最终结果中，而不是在某些定义的排序中顺序地对每个元素进行折叠。 * 对于非交换的函数，结果可能与应用于非分布式集合的函数不同。 * */def fold(zeroValue: T)(f: JFunction2[T, T, T]): T = rdd.fold(zeroValue)(f) aggregate12345678910111213141516 /** * Aggregate the elements of each partition, and then the results for all the partitions, using * given combine functions and a neutral \"zero value\". This function can return a different result * type, U, than the type of this RDD, T. Thus, we need one operation for merging a T into an U * and one operation for merging two U's, as in scala.TraversableOnce. Both of these functions are * allowed to modify and return their first argument instead of creating a new U to avoid memory * allocation. * 对每个分区的元素进行聚合，然后使用给定的组合函数和一个中立的“零值”，对所有分区进行结果。 * 这个函数可以返回一个不同的结果类型U，而不是这个RDD的类型。 * 因此，我们需要一个操作来将一个T合并到一个U和一个合并两个U的操作，就像在scala . traversableonce中那样。 * 这两个函数都可以修改和返回第一个参数，而不是创建一个新的U，以避免内存分配。 * */def aggregate[U](zeroValue: U)(seqOp: JFunction2[U, T, U], combOp: JFunction2[U, U, U]): U = rdd.aggregate(zeroValue)(seqOp, combOp)(fakeClassTag[U]) treeAggregate12345678910111213141516171819202122232425 /** * Aggregates the elements of this RDD in a multi-level tree pattern. * 将此RDD的元素聚集在多层树模式中。 * * @param depth suggested depth of the tree 建议的树的深度 * @see [[org.apache.spark.api.java.JavaRDDLike#aggregate]] */def treeAggregate[U]( zeroValue: U, seqOp: JFunction2[U, T, U], combOp: JFunction2[U, U, U], depth: Int): U = &#123; rdd.treeAggregate(zeroValue)(seqOp, combOp, depth)(fakeClassTag[U])&#125;/** * [[org.apache.spark.api.java.JavaRDDLike#treeAggregate]] with suggested depth 2. * 建议的树的深度为 2 */def treeAggregate[U]( zeroValue: U, seqOp: JFunction2[U, T, U], combOp: JFunction2[U, U, U]): U = &#123; treeAggregate(zeroValue, seqOp, combOp, 2)&#125; count123456/** * Return the number of elements in the RDD. * 返回RDD中元素的数量。 * */def count(): Long = rdd.count() countApprox12345678910111213141516171819202122232425262728293031323334353637 /** * Approximate version of count() that returns a potentially incomplete result * within a timeout, even if not all tasks have finished. * 近似版本的count()，即使不是所有的任务都完成了，也会在一个超时中返回一个潜在的不完整的结果。 * * * The confidence is the probability that the error bounds of the result will * contain the true value. That is, if countApprox were called repeatedly * with confidence 0.9, we would expect 90% of the results to contain the * true count. The confidence must be in the range [0,1] or an exception will * be thrown. * 置信值是结果的误差边界包含真实值的概率。 * 也就是说，如果countApprox被反复调用，confidence 0.9，我们将期望90%的结果包含真实的计数。 * confidence必须在范围[0,1]中，否则将抛出异常。 * * * @param timeout maximum time to wait for the job, in milliseconds * 等待工作的最大时间，以毫秒为单位 * @param confidence the desired statistical confidence in the result * 对结果的期望的统计信心 * @return a potentially incomplete result, with error bounds * 一个可能不完整的结果，有错误界限 */def countApprox(timeout: Long, confidence: Double): PartialResult[BoundedDouble] = rdd.countApprox(timeout, confidence)/** * Approximate version of count() that returns a potentially incomplete result * within a timeout, even if not all tasks have finished. * 近似版本的count()，即使不是所有的任务都完成了，也会在一个超时中返回一个潜在的不完整的结果。 * * * @param timeout maximum time to wait for the job, in milliseconds * 等待工作的最大时间，以毫秒为单位 */def countApprox(timeout: Long): PartialResult[BoundedDouble] = rdd.countApprox(timeout) countByValue123456789/** * Return the count of each unique value in this RDD as a map of (value, count) pairs. The final * combine step happens locally on the master, equivalent to running a single reduce task. * 将此RDD中的每个惟一值的计数作为(值、计数)对的映射。 * 最后的联合步骤在master的本地发生，相当于运行一个reduce任务。 * */def countByValue(): JMap[T, jl.Long] = mapAsSerializableJavaMap(rdd.countByValue()).asInstanceOf[JMap[T, jl.Long]] countByValueApprox1234567891011121314151617181920212223242526272829303132333435363738 /** * Approximate version of countByValue(). * countByValue()近似的版本。 * * The confidence is the probability that the error bounds of the result will * contain the true value. That is, if countApprox were called repeatedly * with confidence 0.9, we would expect 90% of the results to contain the * true count. The confidence must be in the range [0,1] or an exception will * be thrown. * 置信值是结果的误差边界包含真实值的概率。 * 也就是说，如果countApprox被反复调用，confidence 0.9，我们将期望90%的结果包含真实的计数。 * confidence必须在范围[0,1]中，否则将抛出异常。 * * * @param timeout maximum time to wait for the job, in milliseconds * 等待工作的最大时间，毫秒为单位。 * @param confidence the desired statistical confidence in the result * 对结果的期望的统计信心 * @return a potentially incomplete result, with error bounds * 一个可能不完整的结果，有错误界限 */def countByValueApprox( timeout: Long, confidence: Double ): PartialResult[JMap[T, BoundedDouble]] = rdd.countByValueApprox(timeout, confidence).map(mapAsSerializableJavaMap)/** * Approximate version of countByValue(). * countByValue().的近似版本. * * @param timeout maximum time to wait for the job, in milliseconds * 等待工作的最大时间，毫秒为单位。 * @return a potentially incomplete result, with error bounds * 一个可能不完整的结果，有错误界限 */def countByValueApprox(timeout: Long): PartialResult[JMap[T, BoundedDouble]] = rdd.countByValueApprox(timeout).map(mapAsSerializableJavaMap) take12345678910111213141516 /** * Take the first num elements of the RDD. This currently scans the partitions *one by one*, so * it will be slow if a lot of partitions are required. In that case, use collect() to get the * whole RDD instead. * 获取RDD的第一个num元素。 * 这将会一次一个地扫描分区，所以如果需要很多分区，它将会很慢。 * 在这种情况下，使用collect()来获得整个RDD。 * * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 该方法只在预期的数组很小的情况下使用，因为所有的数据都被加载到驱动程序的内存中。 * */def take(num: Int): JList[T] = rdd.take(num).toSeq.asJava takeSample12345def takeSample(withReplacement: Boolean, num: Int): JList[T] = takeSample(withReplacement, num, Utils.random.nextLong)def takeSample(withReplacement: Boolean, num: Int, seed: Long): JList[T] = rdd.takeSample(withReplacement, num, seed).toSeq.asJava first12345 /** * Return the first element in this RDD. * 返回这个RDD中的第一个元素。 */def first(): T = rdd.first() isEmpty1234567/** * @return true if and only if the RDD contains no elements at all. Note that an RDD * may be empty even when it has at least 1 partition. * 当且仅当RDD不包含任何元素，则为真。 * 请注意，即使在至少有一个分区的情况下，RDD也可能是空的。 */def isEmpty(): Boolean = rdd.isEmpty() saveAsTextFile123456789101112131415/** * Save this RDD as a text file, using string representations of elements. * 将此RDD保存为文本文件，使用元素的字符串表示形式。 */def saveAsTextFile(path: String): Unit = &#123; rdd.saveAsTextFile(path)&#125;/** * Save this RDD as a compressed text file, using string representations of elements. * 将此RDD保存为一个压缩文本文件，使用元素的字符串表示形式。 */def saveAsTextFile(path: String, codec: Class[_ &lt;: CompressionCodec]): Unit = &#123; rdd.saveAsTextFile(path, codec)&#125; saveAsObjectFile1234567/** * Save this RDD as a SequenceFile of serialized objects. * 将此RDD保存为序列化对象的序列文件。 */def saveAsObjectFile(path: String): Unit = &#123; rdd.saveAsObjectFile(path)&#125; keyBy12345678910/** * Creates tuples of the elements in this RDD by applying `f`. * 通过应用“f”创建这个RDD中元素的元组。 */def keyBy[U](f: JFunction[T, U]): JavaPairRDD[U, T] = &#123; // The type parameter is U instead of K in order to work around a compiler bug; see SPARK-4459 // 类型参数用U替代K，为了绕过编译器错误; implicit val ctag: ClassTag[U] = fakeClassTag JavaPairRDD.fromRDD(rdd.keyBy(f))&#125; checkpoint12345678910111213141516/** * Mark this RDD for checkpointing. It will be saved to a file inside the checkpoint * directory set with SparkContext.setCheckpointDir() and all references to its parent * RDDs will be removed. This function must be called before any job has been * executed on this RDD. It is strongly recommended that this RDD is persisted in * memory, otherwise saving it on a file will require recomputation. * 将此RDD标记为检查点。 * 它将被保存到由SparkContext.setCheckpointDir()设置的检查点目录下的文件中。 * 所有对其父RDDs的引用将被删除。 * 在此RDD上执行任何作业之前，必须调用此函数。 * 强烈建议将此RDD保存在内存中，否则将其保存在文件中需要重新计算。 * */def checkpoint(): Unit = &#123; rdd.checkpoint()&#125; isCheckpointed12345/** * Return whether this RDD has been checkpointed or not * 返回 RDD是否已被检查过 */def isCheckpointed: Boolean = rdd.isCheckpointed getCheckpointFile1234567/** * Gets the name of the file to which this RDD was checkpointed * 获取该RDD所指向的checkpointed文件的名称 */def getCheckpointFile(): Optional[String] = &#123; JavaUtils.optionToOptional(rdd.getCheckpointFile)&#125; toDebugString123456/** A description of this RDD and its recursive dependencies for debugging. * 对该RDD及其对调试的递归依赖的描述。 * */def toDebugString(): String = &#123; rdd.toDebugString&#125; top12345678910111213141516171819202122232425262728293031323334/** * Returns the top k (largest) elements from this RDD as defined by * the specified Comparator[T] and maintains the order. * 根据指定的比较器[T]，从这个RDD中返回最大的k(最大)元素，并维护顺序。 * * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 该方法只在预期的数组很小的情况下使用，因为所有的数据都被加载到驱动程序的内存中。 * * @param num k, the number of top elements to return 返回的元素数量 * @param comp the comparator that defines the order 定义排序的比较器 * @return an array of top elements 返回最大元素的数组 */def top(num: Int, comp: Comparator[T]): JList[T] = &#123; rdd.top(num)(Ordering.comparatorToOrdering(comp)).toSeq.asJava&#125;/** * Returns the top k (largest) elements from this RDD using the * natural ordering for T and maintains the order. * 使用T的自然顺序，从这个RDD中返回最大的k(最大)元素，并维护顺序。 * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 该方法只在预期的数组很小的情况下使用，因为所有的数据都被加载到驱动程序的内存中。 * * @param num k, the number of top elements to return 返回的元素数量 * @return an array of top elements 最大元素的数组 */def top(num: Int): JList[T] = &#123; val comp = com.google.common.collect.Ordering.natural().asInstanceOf[Comparator[T]] top(num, comp)&#125; takeOrdered123456789101112131415161718192021222324252627282930313233/** * Returns the first k (smallest) elements from this RDD as defined by * the specified Comparator[T] and maintains the order. * 从这个RDD中返回第一个k(最小)元素，由指定的Comparator[T]定义，并维护该顺序。 * * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 该方法只在预期的数组很小的情况下使用，因为所有的数据都被加载到驱动程序的内存中。 * * @param num k, the number of elements to return 返回的元素数量 * @param comp the comparator that defines the order 排序比较器 * @return an array of top elements 元素数组 */def takeOrdered(num: Int, comp: Comparator[T]): JList[T] = &#123; rdd.takeOrdered(num)(Ordering.comparatorToOrdering(comp)).toSeq.asJava&#125;/** * Returns the first k (smallest) elements from this RDD using the * natural ordering for T while maintain the order. * 使用原生的 T排序比较器，返回 k个 最小值，并维护这个顺序 * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 尽量应用于小的数组，因为会加载到driver内存中。 * @param num k, the number of top elements to return * @return an array of top elements */def takeOrdered(num: Int): JList[T] = &#123; val comp = com.google.common.collect.Ordering.natural().asInstanceOf[Comparator[T]] takeOrdered(num, comp)&#125; max123456789101112/** * Returns the maximum element from this RDD as defined by the specified * Comparator[T]. * 按照指定比较器[T]定义的RDD， * 返回最大元素。 * * @param comp the comparator that defines ordering 指定的比较器 * @return the maximum of the RDD 最大值 */def max(comp: Comparator[T]): T = &#123; rdd.max()(Ordering.comparatorToOrdering(comp))&#125; min123456789101112/** * Returns the minimum element from this RDD as defined by the specified * Comparator[T]. * 按照指定比较器[T]定义的RDD， * 返回最小元素。 * * @param comp the comparator that defines ordering 指定的比较器 * @return the minimum of the RDD 最小值 */def min(comp: Comparator[T]): T = &#123; rdd.min()(Ordering.comparatorToOrdering(comp))&#125; countApproxDistinct123456789101112131415161718/*** Return approximate number of distinct elements in the RDD.* 返回RDD中不重复元素的数量近似数。** The algorithm used is based on streamlib's implementation of \"HyperLogLog in Practice:* Algorithmic Engineering of a State of The Art Cardinality Estimation Algorithm\", available * &lt;a href=\"http://dx.doi.org/10.1145/2452376.2452456\"&gt;here&lt;/a&gt;. * 所使用的算法是基于streamlib在实践中的“HyperLogLog”的实现: * “一种艺术基数估计算法状态的算法工程”， * * * @param relativeSD Relative accuracy. Smaller values create counters that require more space. * It must be greater than 0.000017. * 相对精度。 * 较小的值创建需要更多空间的计数器。 * 它必须大于0.000017。 */ def countApproxDistinct(relativeSD: Double): Long = rdd.countApproxDistinct(relativeSD) countAsync12345678/** * The asynchronous version of `count`, which returns a * future for counting the number of elements in this RDD. * “count”的异步版本，它为计算这个RDD中元素的数量返回一个未来。 */def countAsync(): JavaFutureAction[jl.Long] = &#123;new JavaFutureActionWrapper[Long, jl.Long](rdd.countAsync(), jl.Long.valueOf)&#125; collectAsync12345678910111213/** * The asynchronous version of `collect`, which returns a future for * retrieving an array containing all of the elements in this RDD. * “collect”的异步版本， * 它返回一个用于检索包含该RDD中所有元素的数组的未来。 * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. * 尽量应用于小数量数组。 */def collectAsync(): JavaFutureAction[JList[T]] = &#123;new JavaFutureActionWrapper(rdd.collectAsync(), (x: Seq[T]) =&gt; x.asJava)&#125; takeAsync123456789101112/** * The asynchronous version of the `take` action, which returns a * future for retrieving the first `num` elements of this RDD. * “take”操作的异步版本， * 它将返回用于检索此RDD的第一个“num”元素的未来。 * * @note this method should only be used if the resulting array is expected to be small, as * all the data is loaded into the driver's memory. */def takeAsync(num: Int): JavaFutureAction[JList[T]] = &#123;new JavaFutureActionWrapper(rdd.takeAsync(num), (x: Seq[T]) =&gt; x.asJava)&#125; foreachAsync1234567891011/** * The asynchronous version of the `foreach` action, which * applies a function f to all the elements of this RDD. * “foreach”操作的异步版本， * 它将函数f应用于这个RDD的所有元素。 * */def foreachAsync(f: VoidFunction[T]): JavaFutureAction[Void] = &#123;new JavaFutureActionWrapper[Unit, Void](rdd.foreachAsync(x =&gt; f.call(x)),&#123; x =&gt; null.asInstanceOf[Void] &#125;)&#125; foreachPartitionAsync1234567891011/** * The asynchronous version of the `foreachPartition` action, which * applies a function f to each partition of this RDD. * “foreachPartition”操作的异步版本， * 它将函数f应用于该RDD的每个分区。 */def foreachPartitionAsync(f: VoidFunction[JIterator[T]]): JavaFutureAction[Void] = &#123;new JavaFutureActionWrapper[Unit, Void](rdd.foreachPartitionAsync(x =&gt; f.call(x.asJava)),&#123; x =&gt; null.asInstanceOf[Void] &#125;)&#125;&#125;","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"},{"name":"源码","slug":"源码","permalink":"https://freehubs.github.io/tags/源码/"}]},{"title":"spark源码注释翻译","slug":"spark源码注释翻译","date":"2017-11-06T16:57:05.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/11/06/spark源码注释翻译/","link":"","permalink":"https://freehubs.github.io/2017/11/06/spark源码注释翻译/","excerpt":"\n            版本：spark2.1.1目的：方便中文用户阅读源码，把时间花在理解而不是翻译上\n          \n\n初衷开始立项进行翻译，一方面方便日后阅读源码，另一方面先粗粒度的熟悉下spark框架和组件。优化完之后希望能帮助更多的中文用户，节省翻译时间。","text":"版本：spark2.1.1目的：方便中文用户阅读源码，把时间花在理解而不是翻译上 初衷开始立项进行翻译，一方面方便日后阅读源码，另一方面先粗粒度的熟悉下spark框架和组件。优化完之后希望能帮助更多的中文用户，节省翻译时间。 进度已完成： 正在作：spark core模块 模块名 模块介绍 完成度 api broadcast deploy executor 执行器：用于启动线程池，是真正负责执行task的部件 已完成 input internal io launcher mapred memory metrics network partial rdd rpc scheduler 调度器：spark应用程序的任务调度器 正在作 security serializer shuffle status.api.v1 storage util","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"}]},{"title":"spark关于parquet的优化","slug":"spark关于parquet的优化","date":"2017-11-01T14:53:13.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/11/01/spark关于parquet的优化/","link":"","permalink":"https://freehubs.github.io/2017/11/01/spark关于parquet的优化/","excerpt":"\n            parquet是一种列式存储。可以提供面向列的存储和查询。\n          \nParquet的优势在sparkSQL程序中使用parquet格式存储文件，在存储空间和查询性能方面都有很高的效率。\n存储方面因为是面向列的存储，同一列的类型相同，因而在存储的过程中可以使用更高效的压缩方案，可以节省大量的存储空间。\n查询方面在执行查询任务时，只会扫描需要的列，而不是全部，高度灵活性使查询变得非常高效。","text":"parquet是一种列式存储。可以提供面向列的存储和查询。 Parquet的优势在sparkSQL程序中使用parquet格式存储文件，在存储空间和查询性能方面都有很高的效率。 存储方面因为是面向列的存储，同一列的类型相同，因而在存储的过程中可以使用更高效的压缩方案，可以节省大量的存储空间。 查询方面在执行查询任务时，只会扫描需要的列，而不是全部，高度灵活性使查询变得非常高效。 实例测试 测试数据大小 存储类型 存储所占空间 查询性能 1T TEXTFILE 897.9G 698s 1T Parquet 231.4G 21s Parquet的使用使用parquet的简单demo： 12345678910111213141516171819202122// Encoders for most common types are automatically provided by importing spark.implicits._import spark.implicits._val peopleDF = spark.read.json(\"examples/src/main/resources/people.json\")// DataFrames can be saved as Parquet files, maintaining the schema informationpeopleDF.write.parquet(\"people.parquet\")// Read in the parquet file created above// Parquet files are self-describing so the schema is preserved// The result of loading a Parquet file is also a DataFrameval parquetFileDF = spark.read.parquet(\"people.parquet\")// Parquet files can also be used to create a temporary view and then used in SQL statementsparquetFileDF.createOrReplaceTempView(\"parquetFile\")val namesDF = spark.sql(\"SELECT name FROM parquetFile WHERE age BETWEEN 13 AND 19\")namesDF.map(attributes =&gt; \"Name: \" + attributes(0)).show()// +------------+// | value|// +------------+// |Name: Justin|// +------------+ Parquet 的问题 spark 写入数据到 hive 中，使用 Parquet 存储格式，查询该表时报错如下： 1Error: java.io.IOException: org.apache.parquet.io.ParquetDecodingException: Can not read value at 0 in block -1 in file 当时设置的字段属性为： 经过比对，发现是 decimal 类型出了问题，查询 decimal 的字段时候就会报错，而查询其他的并不会报错。（这应该是 spark 引起的，因为在 hive 客户端执行 decimal 类型的操作时并不会出错。） 查阅网上，也有些朋友遇到了类似的事情，应该是官方的 bug ，暂时的解决办法是: 121. 将 Parquet 的存储格式转换为 ORC 2. 或将 decimal 换为 double 类型存储字段","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"},{"name":"parquet","slug":"parquet","permalink":"https://freehubs.github.io/tags/parquet/"}]},{"title":"三步走战略","slug":"三步走战略","date":"2017-11-01T10:45:09.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/11/01/三步走战略/","link":"","permalink":"https://freehubs.github.io/2017/11/01/三步走战略/","excerpt":"\n            设定中长期规划稳扎稳打，逐个击破，实现技术上的重大突破\n          ","text":"设定中长期规划稳扎稳打，逐个击破，实现技术上的重大突破 第一步深刻了解spark运行机制第二步深度剖析sparkSQL和sparkStreaming第三步实现对spark机器学习的深度掌握","raw":null,"content":null,"categories":[{"name":"规划","slug":"规划","permalink":"https://freehubs.github.io/categories/规划/"}],"tags":[{"name":"规划","slug":"规划","permalink":"https://freehubs.github.io/tags/规划/"}]},{"title":"手把手搭建vps和shadowsocks","slug":"手把手搭建vps和shadowsocks","date":"2017-10-31T00:16:22.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/10/31/手把手搭建vps和shadowsocks/","link":"","permalink":"https://freehubs.github.io/2017/10/31/手把手搭建vps和shadowsocks/","excerpt":"\n            记性不好，做个记录，日后有需要时难得费神。\n          \n名词解释了解一些原理，熟悉一些名词，也方便理解接下来安装过程中的操作。\nvpsVPS(Virtual private server) 译作虚拟专用伺服器。你可以把它简单地理解为一台在远端的强劲电脑。当你租用了它以后，可以给它安装操作系统、软件，并通过一些工具连接和远程操控它。\nvultrVultr 是一家 VPS 服务器提供商，有美国、亚洲、欧洲等多地的 VPS。它家的服务器以性价比高闻名，按时间计费，最低的资费为每月 $2.5。\nlinuxLinux 是免费开源的操作系统，大概被世界上过半服务器所采用。有大量优秀的开源软件可以安装，上述 Shadowsocks 就是其一。你可以通过命令行来直接给 Linux 操作系统「下命令」，比如 $ cd ~/Desktop 就是进入你根目录下的 Desktop 文件夹。\nssh SSH 是一种网络协议，作为每一台 Linux 电脑的标准配置，用于计算机之间的加密登录。当你为租用的 VPS 安装 Linux 系统后，只要借助一些工具，就可以用 SSH 在你自己的 Mac/PC 电脑上远程登录该 VPS 了。\nshadowsocksShadowsocks(ss) 是由 Clowwindy 开发的一款软件，其作用本来是加密传输资料。当然，也正因为它加密传输资料的特性，使得 GFW 没法将由它传输的资料和其他普通资料区分开来，也就不能干扰我们访问那些「不存在」的网站了。","text":"记性不好，做个记录，日后有需要时难得费神。 名词解释了解一些原理，熟悉一些名词，也方便理解接下来安装过程中的操作。 vpsVPS(Virtual private server) 译作虚拟专用伺服器。你可以把它简单地理解为一台在远端的强劲电脑。当你租用了它以后，可以给它安装操作系统、软件，并通过一些工具连接和远程操控它。 vultrVultr 是一家 VPS 服务器提供商，有美国、亚洲、欧洲等多地的 VPS。它家的服务器以性价比高闻名，按时间计费，最低的资费为每月 $2.5。 linuxLinux 是免费开源的操作系统，大概被世界上过半服务器所采用。有大量优秀的开源软件可以安装，上述 Shadowsocks 就是其一。你可以通过命令行来直接给 Linux 操作系统「下命令」，比如 $ cd ~/Desktop 就是进入你根目录下的 Desktop 文件夹。 ssh SSH 是一种网络协议，作为每一台 Linux 电脑的标准配置，用于计算机之间的加密登录。当你为租用的 VPS 安装 Linux 系统后，只要借助一些工具，就可以用 SSH 在你自己的 Mac/PC 电脑上远程登录该 VPS 了。 shadowsocksShadowsocks(ss) 是由 Clowwindy 开发的一款软件，其作用本来是加密传输资料。当然，也正因为它加密传输资料的特性，使得 GFW 没法将由它传输的资料和其他普通资料区分开来，也就不能干扰我们访问那些「不存在」的网站了。 搭建vps目的就是搭建梯子。无建站的需求。推荐vultr，最便宜的有2.5美元一个月。500g流量完全够用了。且现在支持支付宝付款，颇为方便。现阶段的优惠活动是新注册的用户完成指定的任务会获得3美元的奖励。（详细情况可依参见官网。） 注册首先点击右侧注册链接：https://www.vultr.com/2017Promo，然后会来到下图所示的注册页面。 第一个框中填写注册邮箱，第二个框中填写注册密码（至少包含1个小写字母、1个大写字母和1个数字），最后点击Create Account创建账户。 创建账户后注册邮箱会收到一封验证邮件，我们需要点击Verify Your E-mail来验证邮箱。 如果注册邮箱收不到验证邮件请更换注册邮箱后重复第一步。 验证邮箱后我们会来到下图所示的登录界面，按下图中指示填写信息，然后点击Login登录。 登陆后我们会来到充值界面。Vultr要求新账户充值后才可以正常创建服务器。Vultr已经支持支付宝了，在这里推荐大家使用支付宝充值，最低金额为10美元。 购买充值完毕后点击右上角的蓝色加号按钮进入创建服务器界面。 首先需要选择Server Location即机房位置，从左到右、从上到下依次为东京、新加坡、伦敦、法兰克福、巴黎、阿姆斯特丹、迈阿密、亚特兰大、芝加哥、硅谷、达拉斯、洛杉矶、纽约、西雅图、悉尼。 然后需要选择Server Type即服务类型，这里大家需要选择安装Debian 7 x64系统，因为这个系统折腾起来比较容易，搭建东西也简单便捷。 然后需要选择Server Size即方案类型，这里大家可以按照需要自行选择，如果只是普通使用那么选择第二个5美元方案即可。 然后Additional Features、Startup Script、SSH Keys以及Server Hostname &amp; Label等四部分大家保持默认即可，最后点击右下方的蓝色Deploy Now按钮确认创建服务器。 创建服务器后我们会看到下图所示界面。 上图中我们需要耐心等待3~4分钟，等红色Installing字变为绿色Running字后，点击Cloud Instance即可进入服务器详细信息界面，如下图所示。 左侧红框内四行信息依次为机房位置、IP地址、登录用户名、登录密码。IP地址后面的按钮为复制IP地址，登录密码后面的按钮为复制密码及显示/隐藏密码。右上角红框内后面四个按钮分别是关闭服务器、重启服务器、重装系统、删除服务器。 远程登录安装远程登录软件。这里以windos端的xshell为例。使用mac的同学可以下载iTerm。 下载安装后打开软件。根据下图中的指示，我们点击会话框中的新建按钮。 点击新建按钮后会弹出下图所示界面。根据图中指示，我们首先填写IP地址，然后点击确定按钮。 点击确定按钮后我们会回到下图所示界面。根据图中指示，我们双击打开新建会话或者点击下方连接按钮打开新建会话。 开新建会话后会弹出下图所示界面。根据图中指示，我们点击接受并保存按钮。 点击接受并保存按钮会弹出下图所示界面。根据图中指示，我们首先填写SSH连接密码，然后打钩记住密码，最后点击确定按钮。 如果提示需要输入用户名（登录名），那么请输入root！ 点击确定按钮后服务器会自动连接，连接完毕后我们会来到下图所示界面 部署shadowsocks这里采用网上整理的一键部署的方案。简单方便操作。 首先复制以下内容： 1wget -N --no-check-certificate https://0123.cool/download/55r.sh &amp;&amp; chmod +x 55r.sh &amp;&amp; ./55r.sh 然后回到Xshell软件，右击选择粘贴，粘贴完毕后回车继续。 回车后系统会自行下载脚本文件并运行。根据下图图中指示，我们依次输入SSR的各项连接信息，最后回车继续。 安装完成后会出现下图所示界面。根据图中指示，我们将红框圈中的信息保存到记事本内。 配置锐意加速根据下图图中指示，我们继续复制下列信息： 1wget -N --no-check-certificate https://0123.cool/download/rs.sh &amp;&amp; bash rs.sh install 然后回到Xshell软件，右击选择粘贴，粘贴完毕后回车继续。 回车后系统会自行下载脚本文件并运行。根据下图图中指示，我们依次输入锐速的各项配置信息，最后回车继续。 回车后，系统自动执行命令完成破解版锐速安装，如下图所示。 我们首先输入： 1reboot 然后回车，Xshell会断开连接，系统会在1分钟后重启完毕，此时可以关闭Xshell软件了。 搭建教程到此结束，亲测成功。如果不能连接的，请检查自己的每一步操作。","raw":null,"content":null,"categories":[{"name":"vps","slug":"vps","permalink":"https://freehubs.github.io/categories/vps/"}],"tags":[{"name":"vps","slug":"vps","permalink":"https://freehubs.github.io/tags/vps/"}]},{"title":"spark报错集","slug":"spark报错集","date":"2017-10-30T13:58:58.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/10/30/spark报错集/","link":"","permalink":"https://freehubs.github.io/2017/10/30/spark报错集/","excerpt":"有话要说针对一个老毛病：有些错误屡犯屡改，屡改屡犯，没有引起根本上的注意，或者没有从源头理解错误发生的底层原理，导致做很多无用功。\n总结历史，并从中吸取教训，减少无用功造成的时间浪费。特此将从目前遇到的spark问题全部记录在这里，搞清楚问题，自信向前。","text":"有话要说针对一个老毛病：有些错误屡犯屡改，屡改屡犯，没有引起根本上的注意，或者没有从源头理解错误发生的底层原理，导致做很多无用功。 总结历史，并从中吸取教训，减少无用功造成的时间浪费。特此将从目前遇到的spark问题全部记录在这里，搞清楚问题，自信向前。 问题汇总问题1：spark-hive classes are not found概述：1Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Unable to instantiate SparkSession with Hive support because Hive classes are not found. 场景：在本地调试spark程序，连接虚拟机上的集群，尝试执行sparkSQL时，启动任务就报错。 原理：缺少sparkSQL连接hive的必要和依赖jar包，添加相应的依赖包即可。 办法：123456789在项目／模块的pom.xml中添加相关的spark-hive依赖jar包。&lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-hive_2.11 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-hive_2.11&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;重新编译项目／模块即可。 问题2：Spark Local 模式写 Hive，user=xialinsheng概述：1Caused by: org.apache.hadoop.security.AccessControlException: Permission denied: user=xialinsheng, access=WRITE, inode=&quot;/user/hive/warehouse/xls002&quot;:hadoop:supergroup:drwxr-xr-x 场景：Spark Local 模式连接集群，对 Hadoop 无操作权限。 原理：Spark 在 Local 模式时，如果在本地机器没有设定 HADOOP_USER_NAME ，程序会使用本地的机器名作为 HADOOP_USER_NAME ，这就导致在 Hadoop 集群中无法识别该用户名，从而没权限操作 Hadoop 。 获取 HADOOP_USER_NAME 的核心源码如下： 1234567if (!isSecurityEnabled() &amp;&amp; (user == null)) &#123; String envUser = System.getenv(HADOOP_USER_NAME); if (envUser == null) &#123; envUser = System.getProperty(HADOOP_USER_NAME); &#125; user = envUser == null ? null : new User(envUser);&#125; 从源码可知，要想解决该问题，只要在本机的环境变量中添加 HADOOP_USER_NAME = Hadoop （对 Hadoop 集群有操作权限的用户，具体视自身情况而定。）参考博客：点我了解更多 解决：因为我的需求只是在测试的时候会使用 Local 模式连接集群上的 Hive 表，因而我的处理方式则是在程序代码中指定 ： 1System.setProperty(\"HADOOP_USER_NAME\",\"Hadoop有权限的用户名\"); 问题3：javax.servlet.FilterRegistration概述：在idea上运行spark程序时，出现以下信息： 1Spark error class &quot;javax.servlet.FilterRegistration&quot;&apos;s signer information does not match signer information of other classes in the same package 如图： 原理：包冲突导致。 解决：按照以下步骤操作： 右键模块项目 Open Module Settings 选择Dependencies 找到 javax.servlet:servlet-api:xx 移动到列表的最末端 Apply，Ok 如下图：","raw":null,"content":null,"categories":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/categories/spark/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://freehubs.github.io/tags/spark/"},{"name":"报错集","slug":"报错集","permalink":"https://freehubs.github.io/tags/报错集/"}]},{"title":"life","slug":"life","date":"2017-10-29T11:00:42.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/10/29/life/","link":"","permalink":"https://freehubs.github.io/2017/10/29/life/","excerpt":"\n\nvar dplayer0 = new DPlayer({\"element\":document.getElementById(\"dplayer0\"),\"autoplay\":0,\"theme\":\"#FADFA3\",\"loop\":1,\"video\":{\"url\":\"http://oliji9s3j.bkt.clouddn.com/Unbroken%20-%20Motivational%20Video.mp4\",\"pic\":\"/images/pic/life.jpeg\"}});\n\n            Life is simple &amp;&amp; funny.\n          ","text":"var dplayer0 = new DPlayer({\"element\":document.getElementById(\"dplayer0\"),\"autoplay\":0,\"theme\":\"#FADFA3\",\"loop\":1,\"video\":{\"url\":\"http://oliji9s3j.bkt.clouddn.com/Unbroken%20-%20Motivational%20Video.mp4\",\"pic\":\"/images/pic/life.jpeg\"}}); Life is simple &amp;&amp; funny.","raw":null,"content":null,"categories":[{"name":"movie","slug":"movie","permalink":"https://freehubs.github.io/categories/movie/"}],"tags":[{"name":"movie","slug":"movie","permalink":"https://freehubs.github.io/tags/movie/"}]},{"title":"杂乱无章","slug":"杂乱无章","date":"2017-10-29T01:31:31.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/10/29/杂乱无章/","link":"","permalink":"https://freehubs.github.io/2017/10/29/杂乱无章/","excerpt":"\n            时光的机器，加足马力冲回过去历史的长河，丝丝涟漪涌向未来\n          ","text":"时光的机器，加足马力冲回过去历史的长河，丝丝涟漪涌向未来 道不清楚，说不明白，夜深人静的时候，说一些想到的废话。窗外隆隆作响，不知疲倦的机器不知疲倦的执行着不知疲倦的动作。窗内屏幕暗淡，双眼干涩，思索着宇宙外的回想。 小时候，望向星空，那时的天空群星闪烁，哪像现在，嘿，享受了大城市的霓虹，哪里再给你无垠的星空，贪。 躺在草地，微风轻拂脸颊，初秋的夜晚，有点微凉。 仰望星河，也想着外面的世界，多精彩。 揣摩着无垠的宇宙，翻过地球，越过银河，驶向无限拓展的星际，身上的烦恼，微风一吹，全散了。 风轻拂，静静望着天空，思考着外面的朋友或许也在渴望着远方的我，伸手触摸这天空，抓一把星辰贪婪的放入梦。 深邃的夜空，望不尽的远方，是光明中的无尽黑暗，也似黑暗道路的一束亮光，洒向我，思绪跟着遨游，呵，世界与我万千美好，我与世界却念念叨叨，琐琐碎碎，麻麻烦烦。心里是想放飞的。 夜深，车水呼啸，诉说着城市的不眠，可我困，关窗，闷。开窗，嘿，不知疲倦的机器又开始不知疲倦的执行不知疲倦的动作。这样的夜晚，眠难。 深夜思考，写作。夜使我宁静，内心的宁静，这白天的大城市给予不了。感谢夜的馈赠，接收这无上的加冕，驰骋在思绪的星空，痛快，精彩，精彩。 杂乱无章，呵，可以。","raw":null,"content":null,"categories":[{"name":"think","slug":"think","permalink":"https://freehubs.github.io/categories/think/"}],"tags":[{"name":"think","slug":"think","permalink":"https://freehubs.github.io/tags/think/"}]},{"title":"闲谈","slug":"闲谈","date":"2017-10-28T11:07:14.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/10/28/闲谈/","link":"","permalink":"https://freehubs.github.io/2017/10/28/闲谈/","excerpt":"\n            春回大地\n          ","text":"春回大地","raw":null,"content":null,"categories":[{"name":"think","slug":"think","permalink":"https://freehubs.github.io/categories/think/"}],"tags":[{"name":"think","slug":"think","permalink":"https://freehubs.github.io/tags/think/"}]},{"title":"这个杀手不太冷","slug":"这个杀手不太冷","date":"2017-10-28T01:18:04.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/10/28/这个杀手不太冷/","link":"","permalink":"https://freehubs.github.io/2017/10/28/这个杀手不太冷/","excerpt":"\n            Is life always this hard,or is it just when you’re a kid?Always like this.\n          \n","text":"Is life always this hard,or is it just when you’re a kid?Always like this.","raw":null,"content":null,"categories":[{"name":"movie","slug":"movie","permalink":"https://freehubs.github.io/categories/movie/"}],"tags":[{"name":"movie","slug":"movie","permalink":"https://freehubs.github.io/tags/movie/"}]},{"title":"mac使用小技巧","slug":"mac使用小技巧","date":"2017-10-28T01:13:44.000Z","updated":"2020-09-09T04:36:35.749Z","comments":true,"path":"2017/10/28/mac使用小技巧/","link":"","permalink":"https://freehubs.github.io/2017/10/28/mac使用小技巧/","excerpt":"\n            前言\n          \n记录mac使用的小技巧和一些问题。不定期更新ing\n            文件损坏的解决办法\n          在安装一些网上下载的应用时，如果报错显示：文件已经损坏，请移至废纸篓。请不要惊慌，其实别不是文件真的损坏了，根本原因是 mac 系统的安全验证机制，默认是不允许某些应用的安装。要想避开该安全认证，其实方法也很简单，如下：\n第一步：打开系统偏好设置中的 安全性与隐私 ，解开锁，选择 任何来源 ，完成。\n第二步：在这里关键是很多朋友没找到这个 任何来源 ，不要着急，咱们接着往来下，打开 终端，输入如下命令：\n12cd ~sudo spctl --master-disable\n成功输入以上命令，再去执行第一步操作，完成，现在可以去开心的安装应用了。","text":"前言 记录mac使用的小技巧和一些问题。不定期更新ing 文件损坏的解决办法 在安装一些网上下载的应用时，如果报错显示：文件已经损坏，请移至废纸篓。请不要惊慌，其实别不是文件真的损坏了，根本原因是 mac 系统的安全验证机制，默认是不允许某些应用的安装。要想避开该安全认证，其实方法也很简单，如下： 第一步：打开系统偏好设置中的 安全性与隐私 ，解开锁，选择 任何来源 ，完成。 第二步：在这里关键是很多朋友没找到这个 任何来源 ，不要着急，咱们接着往来下，打开 终端，输入如下命令： 12cd ~sudo spctl --master-disable 成功输入以上命令，再去执行第一步操作，完成，现在可以去开心的安装应用了。 终端 command not found 问题 在初次使用 mac 终端的时候，终端除了能执行 cd 命令，其余的貌似都不得行，会报 command not found 的问题，下面给出解决方案。 原因：出现该问题的原因是没有将这些命令添加进环境变量中，导致系统无法识别。 第一步：先设置临时的环境变量，以使我们能继续进行下面的操作。 1export PATH=/usr/bin:/usr/sbin:/bin:/sbin 第二步：进入到用户的目录，并打开存储环境变量的文件 .bash_profile , vi 是操作文件的利器，如果没有文件会新建文件。 12cd ~vi .bash_profile 第三步：在打开的文件页面，输入 i 执行编辑操作，可看到页面的左下角有个 insert 的字样即可，然后添加环境变量信息： 1export PATH=/usr/bin:/usr/sbin:/bin:/sbin 添加完以上信息之后，按 esc 键退出编辑模式，然后输入 :wq 保存并退出编辑页面。 第四步：使刚才编辑的环境变量文件生效。 source 命令即可。 1source .bash_profile 完成之后则可以重启 终端 ，并执行如 ls 等 Linux 操作，验证是否成功。 开启充电提示音（类似于iphone充电提示音，默认关闭） 终端输入（开启）： 1defaults write com.apple.PowerChime ChimeOnAllHardware -bool true; open /System/Library/CoreServices/PowerChime.app &amp; 关闭： 1defaults write com.apple.PowerChime ChimeOnAllHardware -bool false;killall PowerChime 隐藏文件夹 更好的保护学习资料，有时候需要设置隐藏文件夹： 1mv foldername .foldername 查看隐藏文件夹 mac最新版本： 1⌘⇧.(Command + Shift + .) #隐藏 和显示 Macbook Pro 用外接显示器时，如何关闭笔记本屏幕，同时开盖使用 12sudo nvram boot-args=\"iog=0x0\" #(10.10以前版本)sudo nvram boot-args=\"niog=1\" #(10.10及以后版本)这个命令的意思就是外接显示器时关闭自身屏幕，重启生效 开机流程：连上电源和外接显示器，按开机键，立即合盖，等外接显示器有信号时开盖即可如果报错 (已知 10.11/10.12 会报错)nvram: Error setting variable - ‘boot-args’: (iokit/common) general error 重启，按住command + r 进入恢复界面左上角菜单里面找到终端，输入nvram boot-args=”niog=1”，回车问题解决。重启生效","raw":null,"content":null,"categories":[{"name":"mac","slug":"mac","permalink":"https://freehubs.github.io/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://freehubs.github.io/tags/mac/"}]}]}